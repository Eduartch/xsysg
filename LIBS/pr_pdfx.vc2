*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="pr_pdfx.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pdfasimagelistener AS reportlistener 		&& Listener to Create PDF Files as Images
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "hpdf_consts.h"
	*<DefinedPropArrayMethod>
		*m: addblankpage
		*m: cleardlls
		*m: declaredll		&& Method to Start Dll Declarations
		*m: encryptpdf		&& Method to Encrypt the Pdf Document
		*m: shellexec
		*m: startpdfdocument		&& Method to start pdf generation
		*m: writepdfinformation		&& Writes Information About the File
		*p: cmasterpassword		&& Master Password of the Pdf Document
		*p: cpdfauthor		&& Pdf Author
		*p: cpdfcreator		&& Pdf Creator
		*p: cpdfkeywords		&& Pdf Keywords
		*p: cpdfsubject		&& Pdf Subject
		*p: cpdftitle		&& Pdf Title
		*p: ctargetfilename
		*p: cuserpassword		&& User Pasword of the Document
		*p: encryptdocument		&& Property to Know if the Document Will Be Encrypted
		*p: lcanaddnotes
		*p: lcancopy
		*p: lcanedit
		*p: lcanprint		&& If .T. User will be allowed to print the document, if 0 he won't
		*p: lencryptdocument
		*p: lopenviewer		&& If .T. Adobe Reader will be opened
		*p: mergedocument
		*p: mergedocumentname
		*p: nencryptionlevel		&& Accepts a Value of 0 Or 1, 0 = Standard 40-bit encryption. 1 = Advanced 128-bit encryption.
		*p: npageheight
		*p: npgcounter
		*p: oimagescollection		&& Collection of images files used in the report
		*p: opage		&& Property to Store the Page Object
		*p: oprogress		&& Property to Store Progress Bar
		*p: oregistry
		*p: pageheight		&& Height of The Report Pages
		*p: pagewidth		&& Width of Report Pages
		*p: pdfhandle		&& Handle for the Pdf Document To Generate
		*p: waitfornextreport
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cmasterpassword = 		&& Master Password of the Pdf Document
	cpdfauthor = 		&& Pdf Author
	cpdfcreator = 		&& Pdf Creator
	cpdfkeywords = 		&& Pdf Keywords
	cpdfsubject = 		&& Pdf Subject
	cpdftitle = 		&& Pdf Title
	ctargetfilename = 
	cuserpassword = 		&& User Pasword of the Document
	encryptdocument = .F.		&& Property to Know if the Document Will Be Encrypted
	FRXDataSession = -1
	Height = 23
	lcanaddnotes = .F.
	lcancopy = .T.
	lcanedit = .F.
	lcanprint = .T.		&& If .T. User will be allowed to print the document, if 0 he won't
	lencryptdocument = .F.
	ListenerType = 2
	lopenviewer = .F.		&& If .T. Adobe Reader will be opened
	mergedocument = .F.
	mergedocumentname = 
	Name = "pdfasimagelistener"
	nencryptionlevel = 5		&& Accepts a Value of 0 Or 1, 0 = Standard 40-bit encryption. 1 = Advanced 128-bit encryption.
	npageheight = 0
	npgcounter = 0
	oimagescollection = .NULL.		&& Collection of images files used in the report
	opage = .NULL.		&& Property to Store the Page Object
	oprogress = .F.		&& Property to Store Progress Bar
	oregistry = .F.
	pageheight = 0		&& Height of The Report Pages
	pagewidth = 0		&& Width of Report Pages
	pdfhandle = 0		&& Handle for the Pdf Document To Generate
	waitfornextreport = .F.
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="pdfhandle" type="property" display="PdfHandle"/>
		<memberdata name="pageheight" type="property" display="PageHeight"/>
		<memberdata name="pagewidth" type="property" display="PageWidth"/>
		<memberdata name="encryptdocument" type="property" display="EncryptDocument"/>
		<memberdata name="oprogress" type="property" display="oProgress"/>
		<memberdata name="oregistry" type="property" display="oRegistry"/>
		<memberdata name="mergedocument" type="property" display="MergeDocument"/>
		<memberdata name="mergedocumentname" type="property" display="MergeDocumentName"/>
		<memberdata name="opage" type="property" display="oPage"/>
		<memberdata name="oimagescollection" type="property" display="oImagesCollection"/>
		<memberdata name="cpdfauthor" type="property" display="cPdfAuthor"/>
		<memberdata name="cuserpassword" type="property" display="cUserPassword"/>
		<memberdata name="lencryptdocument" type="property" display="lEncryptDocument"/>
		<memberdata name="nencryptionlevel" type="property" display="nEncryptionLevel"/>
		<memberdata name="addblankpage" type="method" display="AddBlankPage"/>
		<memberdata name="npageheight" type="property" display="nPageHeight"/>
		<memberdata name="lcanedit" type="property" display="lCanEdit"/>
		<memberdata name="lcancopy" type="property" display="lCanCopy"/>
		<memberdata name="lcanaddnotes" type="property" display="lCanAddNotes"/>
		<memberdata name="lcanprint" type="property" display="lCanPrint"/>
		<memberdata name="cleardlls" type="method" display="ClearDLLS"/>
		<memberdata name="encryptpdf" type="method" display="EncryptPdf"/>
		<memberdata name="shellexec" type="method" display="ShellExec"/>
		<memberdata name="startpdfdocument" type="method" display="StartPdfDocument"/>
		<memberdata name="writepdfinformation" type="method" display="WritePdfInformation"/>
		<memberdata name="lopenviewer" type="property" display="lOpenViewer"/>
		<memberdata name="cmasterpassword" type="property" display="cMasterPassword"/>
		<memberdata name="ctargetfilename" type="property" display="cTargetFileName"/>
		<memberdata name="declaredll" type="method" display="DeclareDll"/>
		<memberdata name="cpdfcreator" type="property" display="cPdfCreator"/>
		<memberdata name="cpdfkeywords" type="property" display="cPdfKeyWords"/>
		<memberdata name="cpdfsubject" type="property" display="cPdfSubject"/>
		<memberdata name="cpdftitle" type="property" display="cPdfTitle"/>
		<memberdata name="previewcontainer" type="property" display="PreviewContainer"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addblankpage
		With This
			.oPage=HPDF_AddPage(.pdfHandle) &&Add a New Page
			HPDF_Page_SetWidth(.oPage, (.GetPageWidth()/960)*72) &&Establish the Width of the page
			.nPageHeight=(.GetPageHeight()/960)*72
			HPDF_Page_SetHeight(.oPage, .nPageHeight) &&Establish the Height of the page
		EndWith
	ENDPROC

	PROCEDURE AfterReport
		DoDefault()
		With This
		
			IF NOT .WaitForNextReport 
				HPDF_SaveToFile(.pdfHandle, .cTargetFileName)
				HPDF_Free(.pdfHandle)
				If .lOpenViewer Then
					.ShellExec(.cTargetFileName)
				EndIf
			ENDIF 
		
			* CChalom
			* Reset the report page counter
			This.nPgCounter = 0
		
		EndWith
	ENDPROC

	PROCEDURE BeforeReport
		This.oImagesCollection=CreateObject("Collection")
		This.DeclareDLL()
	ENDPROC

	PROCEDURE cleardlls
		Clear Dlls "HPDF_New,HPDF_Free","HPDF_SaveToFile","HPDF_SetPageMode","HPDF_AddPage","HPDF_Page_SetWidth","HPDF_Page_SetHeight",;
		"HPDF_LoadJpegImageFromFile","HPDF_SetInfoAttr","HPDF_SetPassword","HPDF_SetPermission","HPDF_SetEncryptionMode",;
		"HPDF_SetCompressionMode","HPDF_Page_Concat","HPDF_Page_DrawImage"
	ENDPROC

	PROCEDURE declaredll		&& Method to Start Dll Declarations
		Declare Integer HPDF_New In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Free In libhpdf.dll Integer
		Declare Integer HPDF_SaveToFile In libhpdf.dll Integer, String
		Declare Integer HPDF_SetPageMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_AddPage In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetWidth In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetHeight In libhpdf.dll Integer, Single
		Declare Integer HPDF_LoadJpegImageFromFile In libhpdf.dll Integer, String
		Declare Integer HPDF_SetInfoAttr In  libhpdf.dll Integer, Integer, String
		Declare Integer HPDF_SetPassword In  libhpdf.dll Integer, String, String
		Declare Integer HPDF_SetPermission In libhpdf.dll Integer, Integer
		Declare Integer HPDF_SetEncryptionMode In libhpdf.dll Integer, Integer, Integer
		Declare Integer HPDF_SetCompressionMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Page_Concat In libhpdf.dll Integer, Single, Single, Single, Single, Single, Single
		Declare Integer HPDF_Page_DrawImage In libhpdf.dll Integer, Integer, Single, Single, Single, Single
	ENDPROC

	PROCEDURE encryptpdf		&& Method to Encrypt the Pdf Document
		With This
			If .lEncryptDocument Then &&Protect the document with password
				If !Empty(.cMasterPassword) Then
					If .cMasterPassword!=.cUserPassword Then &&User Password and Master Password can't be the same
						HPDF_SetPassword(.pdfHandle, .cMasterPassword, .cUserPassword)
						Local lnPermit As Integer
						lnPermit=0
						&&Establish PDF files permissions
						If .lCanPrint Then
							lnPermit = lnPermit + HPDF_ENABLE_PRINT
						EndIf
						If .lCanEdit Then
							lnPermit = lnPermit + HPDF_ENABLE_EDIT_ALL
						EndIf
						If .lCanCopy Then
							lnPermit = lnPermit + HPDF_ENABLE_COPY
						EndIf
						If .lCanAddNotes Then
							lnPermit = lnPermit + HPDF_ENABLE_EDIT
						EndIf
						HPDF_SetPermission(This.pdfHandle, lnPermit)
						If .nEncriptionLevel!=5 Then
							HPDF_SetEncryptionMode(.pdfHandle, HPDF_ENCRYPT_R3, .nEncriptionLevel)
						Else
							HPDF_SetEncryptionMode(.pdfHandle, HPDF_ENCRYPT_R2, .nEncriptionLevel)
						EndIf
					EndIf
				EndIf
			EndIf
		EndWith
	ENDPROC

	PROCEDURE OutputPage
		Lparameters nPageNo, eDevice, nDeviceType, nLeft, nTop, nWidth, nHeight, nClipLeft, nClipTop, nClipWidth, nClipHeight
		#Define OutputNothing -1
		#Define OutputTIFF 101
		#Define OutputTIFFAdditive (OutputTIFF+100)
		#Define OutPutJPEG 102
		#Define COULDNTCREATE "Could Not Create PDF Document"
		Local lnHandle As Integer, lcFile As String
		With This
			If (nDeviceType == OutputNothing) Then
				If nPageNo == 1 Then
					nDeviceType = OutputJPEG && Start JPEG Generation Process
					.DeclareDll()
					.StartPdfDocument()
				Else
					.AddBlankPage() 
					nDeviceType = OutputJPEG && Start JPEG GEneration Process
				EndIf
				lcFile=GetEnv("TEMP")+"\"+Sys(2015)+".Jpg"
				.OutputPage(nPageNo, lcFile, nDeviceType)
				lnHandle=HPDF_LoadJpegImageFromFile(.pdfHandle, lcFile)
				HPDF_Page_DrawImage(.oPage, lnHandle, 0, 0, (.GetPageWidth()/960)*72, (.GetPageHeight()/960)*72)
				.oImagesCollection.Add(lcFile)
				NoDefault
			EndIf
		EndWith
	ENDPROC

	PROCEDURE shellexec
		Lparameter lcLink As String, lcAction As String, lcParms As String
		lcAction = Iif(Empty(lcAction), "Open", lcAction)
		lcParms = Iif(Empty(lcParms), "", lcParms)
		Declare Integer ShellExecute In SHELL32.Dll Integer nWinHandle, String cOperation, String cFileName, String cParameters, String cDirectory, Integer nShowWindow
		Declare Integer FindWindow In WIN32API String cNull,String cWinName
		Return ShellExecute(FindWindow(0, _Screen.Caption), lcAction, lcLink, lcParms, Sys(2023), 1)
	ENDPROC

	PROCEDURE startpdfdocument		&& Method to start pdf generation
		With This
			.pdfHandle=HPDF_New(0, 0) &&Create a New Document
			HPDF_SetCompressionMode(.pdfHandle, HPDF_COMP_ALL) &&Set Document Compression Method
			HPDF_SetPageMode(.pdfHandle, HPDF_PAGE_MODE_USE_OUTLINE) &&Set the how Document should be displayed
			.WritePdfInformation() &&Stablish PDF File Information
			.EncryptPdf()
			.AddBlankPage()
		EndWith
	ENDPROC

	PROCEDURE UnloadReport
		DODEFAULT()
		With This
			* CChalom 2010-01-20
			* Added "WaitForNextReport" property in order to allow merging reports
			* If another report is expected to come, don't close the objects and handles
			IF Not .WaitForNextReport 
				If Vartype(.oImagesCollection)="O" Then &&Cleanup Temporary Images Files
					Local lcItem As String
					For Each lcItem In .oImagesCollection FOXOBJECT
						Delete File (lcItem)
					EndFor
					.oImagesCollection=Null
				EndIf
				.ClearDLLS()
			ENDIF 
		ENDWITH
	ENDPROC

	PROCEDURE writepdfinformation		&& Writes Information About the File
		With This
			If !Empty(.cPdfAuthor) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_AUTHOR, .cPdfAuthor)
			EndIf
			If !Empty(.cPdfTitle) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_TITLE, .cPdfTitle)
			EndIf
			If !Empty(.cPdfSubject) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_SUBJECT, .cPdfSubject)
			EndIf
			If !Empty(.cPdfKeyWords) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_KEYWORDS, .cPdfKeywords)
			EndIf
			If !Empty(.cPdfCreator) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_CREATOR, .cPdfCreator)
			EndIf
		EndWith
	ENDPROC

ENDDEFINE

DEFINE CLASS pdflistener AS reportlistener 		&& PDF Listener using HARU Library
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "hpdf_consts.h"
	*<DefinedPropArrayMethod>
		*m: addblankpage		&& Method to add a Blank Page to the document
		*m: addpdfstandardfonts
		*m: cleardlls		&& Method to Clear from Memory all the DLL Calls
		*m: cropimage		&& Method to Crop an Image, uses code from Cesar Chalom Samples
		*m: declaredll		&& Method to Declare all DLL required for the Job
		*m: encryptpdf
		*m: findfontfilename		&& Method to find the real filename of a True Type Font, it will look in the Registry for it
		*m: getpicturehandle		&& Used to get the picture handle when pictures are not in general fields
		*m: parseunderlinetext		&& Method to prepare the text to be drawed as underline
		*m: processdynamics		&& Method to process the dynamics properties of VFP9 SP2
		*m: processfields
		*m: processlabel
		*m: processlines
		*m: processpictures
		*m: processshapes
		*m: resetdatasession
		*m: searchfont
		*m: setfrxdatasession
		*m: shellexec
		*m: startpdfdocument
		*m: writepdfinformation
		*p: ccodepage		&& Code Page to be used by the pdf listener when loading fonts
		*p: cmasterpassword		&& Master Password for the PDF document
		*p: cpdfauthor		&& Author of the Pdf File
		*p: cpdfcreator		&& Name of the Pdf Creator
		*p: cpdfkeywords		&& Keywords of the PDF Document
		*p: cpdfsubject		&& Subject of the PDF File
		*p: cpdftitle		&& Title of the PDF Document
		*p: ctargetfilename		&& Name of the PDF File to create
		*p: ctextstyle		&& Internal to the Class
		*p: cuserpassword		&& User Password for the PDF document
		*p: lcanaddnotes		&& Property to know if the user can add or modify annotations
		*p: lcancopy		&& Property to know if user can copy the document contents
		*p: lcanedit		&& Property to know if user can Edit the contents of the document
		*p: lcanprint		&& Property to know if user can print or can't print the document
		*p: lembedfont		&& Property to Know if the font is Embedded into the document, if .T. file size will increase
		*p: lencryptdocument		&& Property to know if the document should be Encripted
		*p: lopenviewer		&& Flag to execute the default PDF reader of the pc
		*p: lstarted		&& Property to know if the conversion procces has started
		*p: lunderline		&& Property to know if the text being draw should use underline style
		*p: ndivisionfactor		&& Factor to be used for the conversion between unit of measures
		*p: nencriptionlevel		&& A Value Between 5(40bit) and 16(128bit) can be specified for length of the key
		*p: nglobalpgcounter
		*p: nlastpageproccesed		&& Number of the last page proccesed by the system
		*p: npageheight		&& Height of the page, used to invert the coordinate system of the pdf library
		*p: npagemode		&& How the document should be displayed - 0 = USE_NONE; 1 = USE_OUTLINE; 2 = USE_THUMBS; 3 = FULL_SCREEN
		*p: npgcounter
		*p: nspacesfortab		&& Number of Spaces per TAB character
		*p: odynamics		&& Property to store the object used to store temporary values of the dynamics properties
		*p: ofonts		&& Fonts Collection used in the library
		*p: opage		&& Current Page object returned by the library
		*p: opicturehandles		&& Used to store the handle of pictures used in the PDF generation
		*p: oregistry		&& Property to store the Registry Object, this object will provide access to windows registry
		*p: otempimagescollection		&& Property to store the collection of temporary Images used in the PDF Generation
		*p: pdfhandle		&& Handle to the PDF file to create by the DLL
		*p: waitfornextreport		&& Logical, keep the PDF handles opened, waiting for a new report to be joined.
		*p: _lsetconsole
		*p: _lsettalk
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lstarted,lunderline,nlastpageproccesed,npageheight
	ccodepage = CP1252		&& Code Page to be used by the pdf listener when loading fonts
	cmasterpassword = 		&& Master Password for the PDF document
	cpdfauthor = 		&& Author of the Pdf File
	cpdfcreator = 		&& Name of the Pdf Creator
	cpdfkeywords = 		&& Keywords of the PDF Document
	cpdfsubject = 		&& Subject of the PDF File
	cpdftitle = 		&& Title of the PDF Document
	ctargetfilename = 		&& Name of the PDF File to create
	ctextstyle = 		&& Internal to the Class
	cuserpassword = 		&& User Password for the PDF document
	FRXDataSession = -1
	Height = 23
	lcanaddnotes = .F.		&& Property to know if the user can add or modify annotations
	lcancopy = .T.		&& Property to know if user can copy the document contents
	lcanedit = .F.		&& Property to know if user can Edit the contents of the document
	lcanprint = .T.		&& Property to know if user can print or can't print the document
	lembedfont = .F.		&& Property to Know if the font is Embedded into the document, if .T. file size will increase
	lencryptdocument = .F.		&& Property to know if the document should be Encripted
	lopenviewer = .F.		&& Flag to execute the default PDF reader of the pc
	lstarted = .F.		&& Property to know if the conversion procces has started
	lunderline = .F.		&& Property to know if the text being draw should use underline style
	Name = "pdflistener"
	ndivisionfactor = 0		&& Factor to be used for the conversion between unit of measures
	nencriptionlevel = 5		&& A Value Between 5(40bit) and 16(128bit) can be specified for length of the key
	nglobalpgcounter = 0
	nlastpageproccesed = 0		&& Number of the last page proccesed by the system
	npageheight = 0		&& Height of the page, used to invert the coordinate system of the pdf library
	npagemode = 0		&& How the document should be displayed - 0 = USE_NONE; 1 = USE_OUTLINE; 2 = USE_THUMBS; 3 = FULL_SCREEN
	npgcounter = 0
	nspacesfortab = 4		&& Number of Spaces per TAB character
	odynamics = .NULL.		&& Property to store the object used to store temporary values of the dynamics properties
	ofonts = .NULL.		&& Fonts Collection used in the library
	opage = .NULL.		&& Current Page object returned by the library
	opicturehandles = .NULL.		&& Used to store the handle of pictures used in the PDF generation
	oregistry = .NULL.		&& Property to store the Registry Object, this object will provide access to windows registry
	otempimagescollection = .NULL.		&& Property to store the collection of temporary Images used in the PDF Generation
	pdfhandle = 0		&& Handle to the PDF file to create by the DLL
	SendGDIPlusImage = 1
	waitfornextreport = .F.		&& Logical, keep the PDF handles opened, waiting for a new report to be joined.
	Width = 23
	_lsetconsole = .F.
	_lsettalk = .F.
	_memberdata = <VFPData>
		<memberdata name="declaredll" type="method" display="DeclareDLL"/>
		<memberdata name="setfrxdatasession" type="method" display="SetFRXDataSession"/>
		<memberdata name="writepdfinformation" type="method" display="WritePDFInformation"/>
		<memberdata name="searchfont" type="method" display="SearchFont"/>
		<memberdata name="shellexec" type="method" display="ShellExec"/>
		<memberdata name="startpdfdocument" type="method" display="StartPdfDocument"/>
		<memberdata name="cleardlls" type="method" display="ClearDLLS"/>
		<memberdata name="encryptpdf" type="method" display="EncryptPdf"/>
		<memberdata name="resetdatasession" type="method" display="ResetDataSession"/>
		<memberdata name="pdfhandle" type="property" display="pdfHandle"/>
		<memberdata name="nlastpageproccesed" type="property" display="nLastPageProccesed"/>
		<memberdata name="ndivisionfactor" type="property" display="nDivisionFactor"/>
		<memberdata name="cpdfauthor" type="property" display="cPdfAuthor"/>
		<memberdata name="cpdftitle" type="property" display="cpdfTitle"/>
		<memberdata name="cpdfsubject" type="property" display="cPdfSubject"/>
		<memberdata name="cpdfkeywords" type="property" display="cPdfKeywords"/>
		<memberdata name="cpdfcreator" type="property" display="cPDFCreator"/>
		<memberdata name="lcanprint" type="property" display="lCanPrint"/>
		<memberdata name="lcancopy" type="property" display="lCanCopy"/>
		<memberdata name="lcanedit" type="property" display="lCanEdit"/>
		<memberdata name="lcanaddnotes" type="property" display="lCanAddNotes"/>
		<memberdata name="lencryptdocument" type="property" display="lEncryptDocument"/>
		<memberdata name="cuserpassword" type="property" display="cUserPassword"/>
		<memberdata name="cmasterpassword" type="property" display="cMasterPassword"/>
		<memberdata name="nencriptionlevel" type="property" display="nEncriptionLevel"/>
		<memberdata name="opage" type="property" display="oPage"/>
		<memberdata name="lstarted" type="property" display="lStarted"/>
		<memberdata name="addblankpage" type="method" display="AddBlankPage"/>
		<memberdata name="ctargetfilename" type="property" display="cTargetFileName"/>
		<memberdata name="lopenviewer" type="property" display="lOpenViewer"/>
		<memberdata name="ofonts" type="property" display="oFonts"/>
		<memberdata name="addpdfstandardfonts" type="method" display="AddPDFStandardFonts"/>
		<memberdata name="findfontfilename" type="method" display="FindFontFileName"/>
		<memberdata name="oregistry" type="property" display="oRegistry"/>
		<memberdata name="npageheight" type="property" display="nPageHeight"/>
		<memberdata name="nspacesfortab" type="property" display="nSpacesforTab"/>
		<memberdata name="lembedfont" type="property" display="lEmbedFont"/>
		<memberdata name="cropimage" type="method" display="CropImage"/>
		<memberdata name="ccodepage" type="property" display="cCodePage"/>
		<memberdata name="lunderline" type="property" display="lUnderline"/>
		<memberdata name="ctextstyle" type="property" display="cTextStyle"/>
		<memberdata name="parseunderlinetext" type="method" display="ParseUnderLineText"/>
		<memberdata name="processdynamics" type="method" display="ProcessDynamics"/>
		<memberdata name="odynamics" type="property" display="oDynamics"/>
		<memberdata name="listenertype" type="property" display="ListenerType"/>
		<memberdata name="processfields" type="method" display="ProcessFields"/>
		<memberdata name="processshapes" type="method" display="ProcessShapes"/>
		<memberdata name="processlabel" type="method" display="ProcessLabel"/>
		<memberdata name="processpictures" type="method" display="ProcessPictures"/>
		<memberdata name="processlines" type="method" display="ProcessLines"/>
		<memberdata name="dynamiclineheight" type="property" display="DynamicLineHeight"/>
		<memberdata name="waitfornextreport" display="WaitForNextReport"/>
		<memberdata name="npgcounter" display="nPgCounter"/>
		<memberdata name="nglobalpgcounter" display="nGlobalPgCounter"/>
		<memberdata name="otempimagescollection" display="oTempImagesCollection"/>
		<memberdata name="opicturehandles" display="oPictureHandles"/>
		<memberdata name="getpicturehandle" display="GetPictureHandle"/>
		<memberdata name="npagemode" display="nPageMode"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addblankpage		&& Method to add a Blank Page to the document
		*!* Change page coordinates and measure system
		With This
			.oPage = HPDF_AddPage(.pdfHandle) &&Add a New Page
			HPDF_Page_SetWidth(.oPage, (.GetPageWidth() / 960) * 72) &&Establish the Width of the page
			.nPageHeight = (.GetPageHeight() / 960) * 72
			HPDF_Page_SetHeight(.oPage, .nPageHeight) &&Establish the Height of the page
		EndWith
	ENDPROC

	PROTECTED PROCEDURE addpdfstandardfonts
		With This.oFonts
			.Add("Courier", "Courier")
			.Add("Courier-Bold", "Courier-Bold")
			.Add("Courier-Oblique", "Courier-Oblique")
			.Add("Courier-BoldOblique", "Courier-BoldOblique")
			.Add("Helvetica", "Helvetica")
			.Add("Helvetica-Bold", "Helvetica-Bold")
			.Add("Helvetica-Oblique", "Helvetica-Oblique")
			.Add("Helvetica-BoldOblique", "Helvetica-BoldOblique")
			.Add("Times-Roman", "Times-Roman")
			.Add("Times-Bold", "Times-Bold")
			.Add("Times-Italic", "Times-Italic")
			.Add("Times-BoldItalic", "Times-BoldItalic")
			.Add("Symbol", "Symbol")
			.Add("ZapfDingbats", "ZapfDingbats")
		EndWith
	ENDPROC

	PROCEDURE AfterReport
		DoDefault()
		With This
		
			IF NOT .WaitForNextReport 
				HPDF_SaveToFile(.pdfHandle, .cTargetFileName)
				HPDF_Free(.pdfHandle)
				If .lOpenViewer Then
					.ShellExec(.cTargetFileName)
				EndIf
			ENDIF 
		
			* CChalom
			* Reset the report page counter
			This.nPgCounter = 0
		
		EndWith
	ENDPROC

	PROCEDURE BeforeReport
		DoDefault()
		
		With This
			IF VARTYPE(.oFonts) <> "O"
				.oFonts = CreateObject("Collection")
				.AddPDFStandardFonts()
				.DeclareDLL()
		
				._lSetConsole = SET("Console")
				._lSetTalk = SET("Talk")
				
				SET TALK OFF 
				SET CONSOLE OFF 
		
			ENDIF 
		EndWith
	ENDPROC

	PROCEDURE cleardlls		&& Method to Clear from Memory all the DLL Calls
		Clear Dlls "HPDF_New","HPDF_Free","HPDF_SaveToFile","HPDF_GetError","HPDF_ResetError","HPDF_SetPageMode",;
		"HPDF_GetCurrentPage","HPDF_AddPage","HPDF_Page_SetWidth","HPDF_Page_SetHeight","HPDF_GetFont","HPDF_LoadTTFontFromFile",;
		"HPDF_GetEncoder","HPDF_GetCurrentEncoder","HPDF_SetCurrentEncoder","HPDF_Encoder_GetType","HPDF_Encoder_GetByteType",;
		"HPDF_Encoder_GetUnicode","HPDF_Encoder_GetWritingMode","HPDF_UseJPEncodings","HPDF_UseKREncodings","HPDF_UseCNSEncodings",;
		"HPDF_UseCNTEncodings","HPDF_LoadPngImageFromFile","HPDF_LoadJpegImageFromFile","HPDF_Image_GetWidth","HPDF_Image_GetHeight",;
		"HPDF_SetInfoAttr","HPDF_SetPassword","HPDF_SetPermission","HPDF_SetEncryptionMode","HPDF_SetCompressionMode",;
		"HPDF_Font_MeasureText","HPDF_Page_GetWidth","HPDF_Page_GetHeight","HPDF_Page_TextWidth","HPDF_Page_GetCurrentFont",;
		"HPDF_Page_MeasureText","HPDF_Page_GetRGBFill","HPDF_Page_GetCurrentFont","HPDF_Page_GetCurrentFontSize","HPDF_Page_SetLineWidth",;
		"HPDF_Page_SetDash","HPDF_Page_MoveTo","HPDF_Page_LineTo","HPDF_Page_ClosePath","HPDF_Page_Rectangle","HPDF_Page_Concat",;
		"HPDF_Page_SetCharSpace","HPDF_Page_SetWordSpace","HPDF_Page_SetHorizontalScalling","HPDF_Page_SetTextLeading",;
		"HPDF_Page_SetTextRise","HPDF_Page_Stroke","HPDF_Page_ClosePathStroke","HPDF_Page_Fill","HPDF_Page_FillStroke",;
		"HPDF_Page_EndPath","HPDF_Page_BeginText","HPDF_Page_EndText","HPDF_Page_SetFontAndSize","HPDF_Page_SetTextRenderingMode",;
		"HPDF_Page_MoveTextPos","HPDF_Page_MoveToNextLine","HPDF_Page_SetRGBFill","HPDF_Page_SetRGBStroke","HPDF_Page_Ellipse",;
		"HPDF_Page_DrawImage","HPDF_Page_TextRect","HPDF_Page_TextOut","HPDF_Page_SetTextMatrix","HPDF_Page_ShowText","HPDF_Page_CurveTo"
	ENDPROC

	PROCEDURE cropimage		&& Method to Crop an Image, uses code from Cesar Chalom Samples
		Lparameters lcFile As String, lnHeight As Integer, lnWidth As Integer
		
		* CChalom 2010-01-17
		* Removed the dependance of having "System.App" from GdiPlusX
		* Now using _Gdiplus.vcx that is already embedded in ReportOutput.App
		
		*!* Original code
		
		*!*	If Vartype(_Screen.System)!="O" Then
		*!*		Do System.App &&Initializes GDIPLUSX
		*!*	EndIf
		*!*	With _Screen.System.Drawing
		*!*		.Graphics.PageUnit = .GraphicsUnit.Point 
		*!*		Local loBmp As xfcBitmap
		*!*		loBmp = .Bitmap.FromFile(lcFile)
		*!*		* Crop Image
		*!*		Local loCropped As xfcBitmap, loRect As xfcRectangle
		*!*		loRect = .Rectangle.New(0, 0, lnWidth, lnHeight)
		*!*		loCropped = loBmp.Clone(loRect)
		*!*		lcFile = Substr(lcFile, 1, Len(lcFile)-3)+"Png"
		*!*		loCropped.Save(lcFile, .Imaging.ImageFormat.Png)
		*!*		Return lcFile
		*!*	ENDWITH
		
		Local loBmp As gpBitmap OF HOME() + "ffc\_gdiplus.vcx"
		loBmp = NEWOBJECT("GpBitmap", "_GdiPlus.vcx")
		
		loBmp.CreateFromFile(lcFile)
		
		LOCAL lhBitmap
		lhBitmap = 0
		=pdfxGdipCloneBitmapAreaI(0, 0, lnWidth, lnHeight, 0, loBmp.GetHandle(), @lhBitmap))
		
		Local loCropped As gpBitmap OF HOME() + "ffc\_gdiplus.vcx"
		loCropped = NEWOBJECT("GpBitmap", "_GdiPlus.vcx")
		
		loCropped.SetHandle(lhBitmap)
		
		LOCAL lcEXT, lcEncoder
		lcEXT = UPPER(JUSTEXT(lcFile))
		lcEncoder = IIF(lcEXT = "PNG", "image/png", "image/jpeg")
		
		LOCAL lcCroppedFile
		lcCroppedFile = FORCEEXT(GetEnv("TEMP") + "\" + Sys(2015), lcEXT)
		loCropped.SaveToFile(lcCroppedFile, lcEncoder)
		loBMP = NULL
		loCropped = NULL
		
		IF lcEXT = "PNG"
			lnHandle = HPDF_LoadPngImageFromFile(This.pdfHandle, lcCroppedFile)
		ELSE
			lnHandle = HPDF_LoadJpegImageFromFile(This.pdfHandle, lcCroppedFile)
		ENDIF 
		
		DELETE FILE (lcFile)
		DELETE FILE (lcCroppedFile)
		
		RETURN lnHandle
		*---
	ENDPROC

	PROCEDURE declaredll		&& Method to Declare all DLL required for the Job
		Declare Integer HPDF_New In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Free In libhpdf.dll Integer
		Declare Integer HPDF_SaveToFile In libhpdf.dll Integer, String
		Declare Integer HPDF_GetError In libhpdf.dll Integer
		Declare Integer HPDF_ResetError In libhpdf.dll Integer
		Declare Integer HPDF_SetPageMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_GetCurrentPage In libhpdf.dll Integer
		Declare Integer HPDF_AddPage In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetWidth In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetHeight In libhpdf.dll Integer, Single
		Declare Integer HPDF_GetFont In libhpdf.dll Integer, String, String
		Declare String  HPDF_LoadTTFontFromFile In libhpdf.dll Integer, String, Integer
		Declare Integer HPDF_GetEncoder In libhpdf.dll Integer, String
		Declare Integer HPDF_GetCurrentEncoder In libhpdf.dll Integer
		Declare Integer HPDF_SetCurrentEncoder In libhpdf.dll Integer, String
		Declare Integer HPDF_Encoder_GetType In libhpdf.dll Integer
		Declare Integer HPDF_Encoder_GetByteType In libhpdf.dll Integer, String, Integer
		Declare String  HPDF_Encoder_GetUnicode In libhpdf.dll Integer, String
		Declare Integer HPDF_Encoder_GetWritingMode In libhpdf.dll Integer
		Declare Integer HPDF_UseJPEncodings In libhpdf.dll Integer
		Declare Integer HPDF_UseKREncodings In libhpdf.dll Integer
		Declare Integer HPDF_UseCNSEncodings In libhpdf.dll Integer
		Declare Integer HPDF_UseCNTEncodings In libhpdf.dll Integer
		Declare Integer HPDF_LoadPngImageFromFile In libhpdf.dll Integer, String
		Declare Integer HPDF_LoadJpegImageFromFile In libhpdf.dll Integer, String
		Declare Integer HPDF_Image_GetWidth In libhpdf.dll Integer
		Declare Integer HPDF_Image_GetHeight In libhpdf.dll Integer
		Declare Integer HPDF_SetInfoAttr In libhpdf.dll Integer, Integer, String
		Declare Integer HPDF_SetPassword In libhpdf.dll Integer, String, String
		Declare Integer HPDF_SetPermission In libhpdf.dll Integer, Integer
		Declare Integer HPDF_SetEncryptionMode In libhpdf.dll Integer, Integer, Integer
		Declare Integer HPDF_SetCompressionMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Font_MeasureText In libhpdf.dll Integer, String, Integer, Single, Single, Single, Single, Integer, Single @
		Declare Single  HPDF_Page_GetWidth In libhpdf.dll Integer
		Declare Single  HPDF_Page_GetHeight In libhpdf.dll Integer
		Declare Single  HPDF_Page_TextWidth In libhpdf.dll Integer, String
		Declare Integer HPDF_Page_GetCurrentFont In libhpdf.dll Integer
		Declare Integer HPDF_Page_MeasureText In libhpdf.dll Integer, String, Single, Integer, Single @
		Declare Integer HPDF_Page_GetRGBFill In libhpdf.dll Integer
		Declare Integer HPDF_Page_GetCurrentFont In libhpdf.dll Integer
		Declare Single  HPDF_Page_GetCurrentFontSize In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetLineWidth In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetDash In libhpdf.dll Integer, String, Integer, Integer
		Declare Integer HPDF_Page_MoveTo In libhpdf.dll Integer, Single, Single
		Declare Integer HPDF_Page_LineTo In libhpdf.dll Integer, Single, Single
		Declare Integer HPDF_Page_ClosePath In libhpdf.dll Integer
		Declare Integer HPDF_Page_Rectangle In libhpdf.dll Integer, Single, Single, Single, Single
		Declare Integer HPDF_Page_Concat In libhpdf.dll Integer, Single, Single, Single, Single, Single, Single
		Declare Integer HPDF_Page_SetCharSpace In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetWordSpace In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetHorizontalScalling In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetTextLeading In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetTextRise In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_Stroke In libhpdf.dll Integer
		Declare Integer HPDF_Page_ClosePathStroke In libhpdf.dll Integer
		Declare Integer HPDF_Page_Fill In libhpdf.dll Integer
		Declare Integer HPDF_Page_FillStroke In libhpdf.dll Integer
		Declare Integer HPDF_Page_EndPath In libhpdf.dll Integer
		Declare Integer HPDF_Page_BeginText In libhpdf.dll Integer
		Declare Integer HPDF_Page_EndText In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetFontAndSize In libhpdf.dll Integer, Integer, Single
		Declare Integer HPDF_Page_SetTextRenderingMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Page_MoveTextPos In libhpdf.dll Integer, Single, Single
		Declare Integer HPDF_Page_MoveToNextLine In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetRGBFill In libhpdf.dll Integer, Single, Single, Single
		Declare Integer HPDF_Page_SetRGBStroke In libhpdf.dll Integer, Single, Single, Single
		Declare Integer HPDF_Page_Ellipse In libhpdf.dll Integer, Single, Single, Single, Single
		Declare Integer HPDF_Page_DrawImage In libhpdf.dll Integer, Integer, Single, Single, Single, Single
		Declare Integer HPDF_Page_TextRect In libhpdf.dll Integer, Single, Single, Single, Single, String, Integer, Integer
		Declare Integer HPDF_Page_TextOut In libhpdf.dll Integer, Single, Single, String
		Declare Integer HPDF_Page_SetTextMatrix In libhpdf.dll Integer ,Single, Single, Single, Single, Single, Single
		Declare Integer HPDF_Page_ShowText In libhpdf.dll Integer, String
		Declare Integer HPDF_Page_CurveTo In libhpdf.dll Integer, Single, Single, Single, Single, Single, Single
		
		* CChalom 2010-01-17
		* Removed the dependance of having "System.App" from GdiPlusX
		* Now using _Gdiplus.vcx that is already embedded in ReportOutput.App
		* Added a GdiPlus.dll declaration missing in the embedded classes
		* Function used in the CropImage method
		DECLARE Long GdipCloneBitmapAreaI IN GDIPLUS.DLL AS pdfxGdipCloneBitmapAreaI Long x, Long y, Long nWidth, Long Height, Long PixelFormat, Long srcBitmap, Long @dstBitmap
		*---
	ENDPROC

	PROCEDURE encryptpdf
		With This
			If .lEncryptDocument Then &&Protect the document with password
				If !Empty(.cMasterPassword) Then
					If .cMasterPassword!=.cUserPassword Then &&User Password and Master Password can't be the same
						HPDF_SetPassword(.pdfHandle, .cMasterPassword, .cUserPassword)
						Local lnPermit As Integer
						lnPermit=0
						&&Establish PDF files permissions
						If .lCanPrint Then
							lnPermit = lnPermit + HPDF_ENABLE_PRINT
						EndIf
						If .lCanEdit Then
							lnPermit = lnPermit + HPDF_ENABLE_EDIT_ALL
						EndIf
						If .lCanCopy Then
							lnPermit = lnPermit + HPDF_ENABLE_COPY
						EndIf
						If .lCanAddNotes Then
							lnPermit = lnPermit + HPDF_ENABLE_EDIT
						EndIf
						HPDF_SetPermission(.pdfHandle, lnPermit)
						If .nEncriptionLevel!=5 Then
							HPDF_SetEncryptionMode(.pdfHandle, HPDF_ENCRYPT_R3, .nEncriptionLevel)
						Else
							HPDF_SetEncryptionMode(.pdfHandle, HPDF_ENCRYPT_R2, .nEncriptionLevel)
						EndIf
					EndIf
				EndIf
			EndIf
		EndWith
	ENDPROC

	PROTECTED PROCEDURE findfontfilename		&& Method to find the real filename of a True Type Font, it will look in the Registry for it
		Lparameters lcFontName As String
		Local lcFileName As String, lcFolder As String
		If Vartype(This.oRegistry)!="O" Then
			This.oRegistry = NewObject("Registry", This.ClassLibrary)
		EndIf
		lcFolder = Iif(Os(3) < "5","SOFTWARE\Microsoft\Windows\CurrentVersion\Fonts","Software\Microsoft\Windows NT\CurrentVersion\Fonts")
		lcFileName = GetEnv("windir") + "\Fonts\" + This.oRegistry.ReadRegistryString(HKEY_LOCAL_MACHINE,lcFolder,lcFontName + " (TrueType)")
		If !IsNull(lcFileName) Then
		*!*		errorn=HPDF_GetError(This.pdfHandle)
		*!*		HPDF_ResetError(This.pdfHandle)
			Return HPDF_LoadTTFontFromFile(This.pdfHandle, lcFileName, This.lEmbedFont)
		Else
			Return ""
		EndIf
	ENDPROC

	PROTECTED PROCEDURE getpicturehandle		&& Used to get the picture handle when pictures are not in general fields
		LParameters lcInternalName As String, lcExternalName As String, lnPicWidth As Integer, lnPicHeight As Integer
		Local lcFileStream As String, lnHandle As Integer, lcExtension As String 
		lcFileStream = FileToStr(lcInternalName)
		Try
			StrToFile(lcFileStream, lcExternalName, 0)
		Catch
		EndTry
		If Vartype(This.oPictureHandles) != "O" Then
			This.oPictureHandles = CreateObject("Collection")
		EndIf
		lnHandle = This.oPictureHandles.GetKey(lcInternalName)
		If lnHandle = 0 Then
			lcExtension = Upper(JustExt(lcExternalName))
			Do Case
				Case lcExtension = "JPG" Or lcExtension = "JPEG"
					lnHandle = HPDF_LoadJpegImageFromFile(This.pdfHandle, lcExternalName)
				Case lcExtension = "PNG"
					lnHandle = HPDF_LoadPngImageFromFile(This.pdfHandle, lcExternalName)
				Otherwise
			EndCase
		
			IF lnHandle = 0
				* CChalom
				* This is being done outside the DOCASE statement because sometimes HARU may fail loading the image
				* So, here we give it another chance to load the image, this time using a converted image by GdiPlus
		
				* Not Supported Format, will never happen when is a general field
				* Convert all images to PNG, that is a safer image type for HPDF
				Local loBmp2 as GpBitmap, lcFile as String, lcFile2 As String
				lcFile  = lcExternalName
				lcFile2 = GetEnv("TEMP") + "\" + Sys(2015) + ".PNG"
				*loBmp2 = NewObject("GpBitmap", "_GdiPlus.vcx", _ReportOutPut)
				loBmp2 = NewObject("GpBitmap", "_GdiPlus.vcx")
				loBmp2.CreateFromFile(lcFile)
				loBmp2.SaveToFile(lcFile2, "image/png")
				lnPicWidth = loBmp2.ImageWidth
				lnPicHeight = loBmp2.ImageHeight
				loBmp2 = Null
				Delete File (lcFile)
				lcFile = lcFile2
				* Try loading the image
				lnHandle = HPDF_LoadPngImageFromFile(This.pdfHandle, lcFile)
			ENDIF 
		
		
			This.oPictureHandles.Add(lnHandle, lcInternalName)
		Else
			lnHandle = This.oPictureHandles.Item(lnHandle)
		EndIf
		Return lnHandle
	ENDPROC

	PROTECTED PROCEDURE parseunderlinetext		&& Method to prepare the text to be drawed as underline
		Lparameters lcText As String, nWidth As Number, lnAncho As Number
		Local lnI As Integer, lcTemp As String, lnLen As Integer, lcRetorno As String
		lnLen = Len(lcText)
		lcTemp = ""
		lcRetorno = ""
		For lnI=1 To lnLen
			If HPDF_Page_TextWidth(This.oPage, lcTemp + Substr(lcText, lnI, 1)) < nWidth Then
				lcTemp = lcTemp + Substr(lcText, lnI, 1)
			Else
				lcRetorno = lcRetorno + lcTemp + " "
				lcTemp = "" 
			EndIf
		EndFor
		Return lcRetorno + lcTemp
	ENDPROC

	PROTECTED PROCEDURE processdynamics		&& Method to process the dynamics properties of VFP9 SP2
		LParameters lcStyle As String, lcType As String
		Local lbReturn As Boolean, lcCursor As String
		lcCursor=Select()
		Try
			XMLToCursor(lcStyle, "_TempDynamics")
		Catch
			lbReturn = .F.
		EndTry
		
		This.oDynamics = Null
		
		* CChalom 2010-06-15
		* Included verification for IF USED("_TempDynamics")
		* for the case of an invalid XML
		IF USED("_TempDynamics") AND Reccount("_TempDynamics") > 0 Then
			This.oDynamics = CreateObject("Empty")
			Select _TempDynamics
			If InList(lcType,"FIELD","SHAPE","PICTURE")
				Scan For !Empty(_TempDynamics.ExecWhen)
					Try
						If Evaluate(_TempDynamics.ExecWhen)
							Do Case
								Case lcType="FIELD"
									AddProperty(This.oDynamics, "cValue", _TempDynamics.Script) &&Corresponds to the Replace Expression With
									AddProperty(This.oDynamics, "cExecWhen", _TempDynamics.ExecWhen) &&Corresponds to the expresion to be evaluate it
									AddProperty(This.oDynamics, "cFontName", _TempDynamics.FName) &&Corresponds to the font name applied if expresion is true
									AddProperty(This.oDynamics, "nFontSize", Iif(Vartype(_TempDynamics.FSize)="N", _TempDynamics.FSize, 0)) &&Corresponds to the font size applied if expresion is true
									AddProperty(This.oDynamics, "nFontStyle",Iif(Vartype(_TempDynamics.FStyle)="N", _TempDynamics.FStyle, 0)) &&Corresponds to the font style applied if expresion is true
									If Cast(_TempDynamics.PenRgb As I)!= -1 Then
										*!* This color transformation was taken from samples provided by Çetin Basöz
										AddProperty(This.oDynamics, "nPenRed", Bitrshift(Bitand(Iif(Vartype(_TempDynamics.PenRgb)="C", Int(Val(_TempDynamics.PenRgb)), _TempDynamics.PenRgb), 0x0000FF),0))
										AddProperty(This.oDynamics, "nPenGreen", Bitrshift(Bitand(Iif(Vartype(_TempDynamics.PenRgb)="C", Int(Val(_TempDynamics.PenRgb)), _TempDynamics.PenRgb), 0x00FF00),8))
										AddProperty(This.oDynamics, "nPenBlue", Bitrshift(Bitand(Iif(Vartype(_TempDynamics.PenRgb)="C", Int(Val(_TempDynamics.PenRgb)), _TempDynamics.PenRgb), 0xFF0000),16))
									Else
										AddProperty(This.oDynamics, "nPenRed", -1)
										AddProperty(This.oDynamics, "nPenGreen", -1)
										AddProperty(This.oDynamics, "nPenBlue", -1)
									EndIf
									If Cast(_TempDynamics.FillRgb As I)!= -1 Then
										AddProperty(This.oDynamics, "nFillRed", Bitrshift(Bitand(Iif(Vartype(_TempDynamics.FillRgb)="C", Int(Val(_TempDynamics.FillRgb)), _TempDynamics.FillRgb), 0x0000FF),0))
										AddProperty(This.oDynamics, "nFillGreen", Bitrshift(Bitand(Iif(Vartype(_TempDynamics.FillRgb)="C", Int(Val(_TempDynamics.FillRgb)), _TempDynamics.FillRgb), 0x00FF00),8))
										AddProperty(This.oDynamics, "nFillBlue", Bitrshift(Bitand(Iif(Vartype(_TempDynamics.FillRgb)="C", Int(Val(_TempDynamics.FillRgb)), _TempDynamics.FillRgb), 0xFF0000),16))
									Else
										AddProperty(This.oDynamics, "nFillRed", -1)
										AddProperty(This.oDynamics, "nFillGreen", -1)
										AddProperty(This.oDynamics, "nFillBlue", -1)
									EndIf
									lbReturn = .T.
									Exit
								Case lcType="SHAPE" Or lcType="IMAGE"
									AddProperty(This.oDynamics, "cExecWhen", _TempDynamics.ExecWhen) &&Corresponds to the expresion to be evaluate it
									AddProperty(This.oDynamics, "nWidth", Iif(Vartype(_TempDynamics.Width)="C", Int(Val(_TempDynamics.Width)), _TempDynamics.Width)) &&Corresponds to the width assigned
									AddProperty(This.oDynamics, "nHeight", Iif(Vartype(_TempDynamics.Height)="C", Int(Val(_TempDynamics.Height)), _TempDynamics.Height)) &&Corresponds to the width assigned
									lbReturn = .T.
									Exit
							EndCase
						EndIf
					Catch
						lbReturn = .F.
					EndTry
				EndScan
			EndIf
			*!* No check for Rotation Values
			Scan For _TempDynamics.Name="Microsoft.VFP.Reporting.Builder.Rotate"
				AddProperty(This.oDynamics, "nRotationDegree", Iif(Vartype(_TempDynamics.Execute)="C", Int(Val(_TempDynamics.Execute)), _TempDynamics.Execute))
				lbReturn = .T.
			EndScan
			Select (lcCursor)
			Return lbReturn
		Else
			lbReturn = .F.
		EndIf
		Select (lcCursor)
		Return lbReturn
	ENDPROC

	PROCEDURE processfields
		Lparameters lcFontFace As String, liFontStyle As Integer, lnFontSize As Number, lnPenRed As Number, lnPenGreen As Number,;
			lnPenBlue As Number, lnFillRed As Number, lnFillGreen As Number, lnFillBlue As Number, nLeft As Number, nTop As Number,;
			lcContents As String, lcFillChar As String, lnOffset As Integer, lbStretch As Boolean, lnCodePage As Integer, nHeight As Number, ;
			nWidth As Integer, lcStyle As String, lnMode As Integer, lcUser As String
		
		Local lnOcurrences As Integer, lnAncho As Integer, lnFontHandle As Integer, lnAlto As Integer, lcUnderLineText As String, lnRotate As Integer, lnCharWidth As Integer
		lnRotate = 0
		With This
			*!* Code to handle the Dynamic Options added in SP2
			If !Empty(lcStyle) Then &&Dynamic Properties are stored here as xml
				TRY 
					If .ProcessDynamics(lcStyle, "FIELD") Then
						lcFontFace = Iif(PemStatus(.oDynamics, "cFontName", 5), .oDynamics.cFontName, lcFontFace)
						lnFontSize = Iif(PemStatus(.oDynamics, "nFontSize",5),  Iif(.oDynamics.nFontSize!=0, .oDynamics.nFontSize, lnFontSize), lnFontSize)
						liFontStyle = Iif(PemStatus(.oDynamics, "nFontStyle",5), Iif(.oDynamics.nFontStyle!=0, .oDynamics.nFontStyle, liFontStyle), liFontStyle)
						lcContents = Iif(PemStatus(.oDynamics, "cValue",5), Iif(!Empty(.oDynamics.cValue), .oDynamics.cValue, lcContents), lcContents)
						lnPenRed = Iif(PemStatus(.oDynamics, "nPenRed",5), .oDynamics.nPenRed, lnPenRed)
						lnPenBlue = Iif(PemStatus(.oDynamics, "nPenBlue",5), .oDynamics.nPenBlue, lnPenBlue)
						lnPenGreen = Iif(PemStatus(.oDynamics, "nPenGreen",5), .oDynamics.nPenGreen, lnPenGreen)
						lnFillRed = Iif(PemStatus(.oDynamics, "nFillRed",5), .oDynamics.nFillRed, lnFillRed)
						lnFillBlue = Iif(PemStatus(.oDynamics, "nFillBlue",5), .oDynamics.nFillBlue, lnFillBlue)
						lnFillGreen = Iif(PemStatus(.oDynamics, "nFillGreen",5), .oDynamics.nFillGreen, lnFillGreen)
						lnRotate = Iif(PemStatus(.oDynamics, "nRotationDegree", 5), .oDynamics.nRotationDegree, 0)
					EndIf
				CATCH
				ENDTRY 
			ENDIF
			
			If lnFillRed=-1 And lnFillBlue=-1 And lnFillGreen=-1 Then &&Default Colors of VFP Report Designer
				Store 255 To lnFillRed, lnFillBlue, lnFillGreen
			EndIf
		
		
			* Draw the field background
			IF lnMode = 0 && Mode: 0 = Opaque background; 1 = Transparent
				lnPenSize = 0
				lnPenPat = 0
				lnFillPat = 1
				lcStyle = ""
		
				This.ProcessShapes(lnFillRed, lnFillGreen, lnFillBlue, ;
						lnFillRed, lnFillGreen, lnFillBlue, ;
						nLeft, nTop, nWidth, nHeight, lnOffset, ;
						lnPenSize, lnPenPat, lnFillPat, lcStyle, lnMode)
			ENDIF 
			
			
			
			
			
			nTop = .nPageHeight - nTop &&Change the Top Coordinates Because of the PDF Coordinate System
			lnFontHandle = HPDF_GetFont(.pdfHandle, .SearchFont(lcFontFace, liFontStyle), Iif(Empty(.cCodePage), Null, .cCodePage)) &&Find and select the font	
			HPDF_Page_BeginText(.oPage) &&Change to Text Mode
			HPDF_Page_SetFontAndSize(.oPage, lnFontHandle, lnFontSize) &&Find and choose the font
			lnOcurrences = Occurs(Chr(9), lcContents)
			lnCharWidth = FontMetric(7, lcFontFace, lnFontSize, .cTextStyle)
			If lnOcurrences > 0 Then &&Replace TAB with spaces
				lcContents=Chrtranc(lcContents, Chr(9), Replicate(" ", .nSpacesforTab))
			EndIf
			If lnPenRed=-1 And lnPenBlue=-1 And lnPenGreen=-1 Then &&Default Colors of VFP Report Designer
				Store 0 To lnPenBlue, lnPenRed, lnPenGreen
			EndIf
			lnAncho = HPDF_Page_TextWidth(.oPage, lcContents) &&Get the size of the text width
		*	lnAlto = HPDF_Page_GetCurrentFontSize(.oPage) &&Get the height of the current font
			lnAlto = FontMetric(1, lcFontFace, lnFontSize, .cTextStyle)
			*!* Process Underline, currently being tested
			If Bittest(liFontStyle, 2) Then
				lcUnderLineText = Replicate("_", Round(lnAncho / HPDF_Page_TextWidth(.oPage, "_"), 0))
				If HPDF_Page_TextWidth(.oPage, lcUnderLineText) > nWidth Then
					lcUnderLineText = .ParseUnderLineText(lcUnderLineText, nWidth, lnAncho)
				EndIf
				.lUnderline = .T.
			Else
				.lUnderline = .F.
			EndIf
			HPDF_Page_SetRGBFill(.oPage, lnPenRed / 255, lnPenGreen / 255, lnPenBlue / 255) &&Convert colors to PDF mode
			HPDF_Page_SetTextLeading(.oPage, lnFontSize) &&Space between lines
			If lnRotate = 0 Then &&No Text Rotation
				*!* 10/03/2010 Luis Navas, change to draw justified text
				If lcUser = "<FJ>" Then
					HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + nWidth, nTop - nHeight - lnAlto, lcContents, HPDF_TALIGN_JUSTIFY, 0)
				Else
					Do Case
						Case lnOffset = 0 &&Left Aligned
							HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + nWidth, nTop - nHeight - lnAlto, lcContents, HPDF_TALIGN_LEFT, 0)
							If .lUnderline Then &&Draw fake underline text
								HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + nWidth , nTop - nHeight - lnAlto, lcUnderLineText, HPDF_TALIGN_LEFT, 0)
							EndIf
						Case lnOffset = 1 &&Right Aligned
							HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + nWidth, nTop - nHeight - lnAlto, lcContents, HPDF_TALIGN_RIGHT, 0)
							If .lUnderline Then &&Draw fake underline text
								HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + nWidth, nTop - nHeight - lnAlto, lcUnderLineText, HPDF_TALIGN_RIGHT, 0)
							EndIf
						Case lnOffset = 2 &&Center Aligned
							HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + nWidth, nTop - nHeight - lnAlto, lcContents, HPDF_TALIGN_CENTER, 0)
							If .lUnderline Then &&Draw fake underline text
								HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + nWidth, nTop - nHeight - lnAlto, lcUnderLineText, HPDF_TALIGN_CENTER, 0)
							EndIf
					EndCase
				EndIf
			Else
				*!* Let's Draw the rotated text
				Local lnRad As Number
				lnRad = ((lnRotate * -1) / 180) * Pi()
				HPDF_Page_SetTextMatrix(.oPage, Cos(lnRad), Sin(lnRad), -Sin(lnRad), Cos(lnRad), nLeft, nTop)
		    	HPDF_Page_ShowText(.oPage, lcContents)
			EndIf
			HPDF_Page_EndText(.oPage)
		ENDWITH
	ENDPROC

	PROCEDURE processlabel
		Lparameters lcFontFace As String, liFontStyle As Integer, lnFontSize As Number, lnPenRed As Number, lnPenGreen As Number,;
			lnPenBlue As Number, lnFillRed As Number, lnFillGreen As Number, lnFillBlue As Number, nLeft As Number, nTop As Number,;
			lcContents As String, lcFillChar As String, lnOffset As Integer, nWidth As Integer, lnCodePage As Integer, nHeight As Number,;
			lcPicture As String, lcStyle As String, lnMode as Integer
		
		Local lnAlto As Number, lnAncho As String, lnFontHandle As Integer, lcUnderLineText As String, lnRotate As Integer, lnCharWidth As Integer
		lnRotate = 0
		With This
			If !Empty(lcStyle) Then &&Dynamic Properties are stored here as xml
				If .ProcessDynamics(lcStyle, "LABEL") Then
					lnRotate = Iif(PemStatus(.oDynamics, "nRotationDegree", 5),. oDynamics.nRotationDegree, 0)
				EndIf
			EndIf
			If lnPenRed=-1 And lnPenBlue=-1 And lnPenGreen=-1 Then &&Replace the Default forecolor of VFP with Black
				Store 0 To lnPenBlue, lnPenRed, lnPenGreen
			EndIf
			If lnFillRed=-1 And lnFillBlue=-1 And lnFillGreen=-1 Then &&Default Colors of VFP Report Designer
				Store 255 To lnFillRed, lnFillBlue, lnFillGreen
			EndIf
		
		
			* Draw the field background
			IF lnMode = 0 && Mode: 0 = Opaque background; 1 = Transparent
				lnPenSize = 0
				lnPenPat = 0
				lnFillPat = 1
				lcStyle = ""
		
				This.ProcessShapes(lnFillRed, lnFillGreen, lnFillBlue, ;
						lnFillRed, lnFillGreen, lnFillBlue, ;
						nLeft, nTop, nWidth + 5, nHeight, lnOffset, ;
						lnPenSize, lnPenPat, lnFillPat, lcStyle, lnMode)
			ENDIF 
		
		
		
			nTop = .nPageHeight - nTop &&Change the Top Coordinates Because of the PDF Coordinate System
			lnFontHandle = HPDF_GetFont(.pdfHandle, .SearchFont(lcFontFace, liFontStyle), Iif(Empty(.cCodePage), NULL, .cCodePage)) &&Find and select the font
			lnCharWidth = FontMetric(6, lcFontFace, lnFontSize, .cTextStyle)
			HPDF_Page_BeginText(.oPage) &&Start text proccesing mode
			HPDF_Page_SetFontAndSize(.oPage, lnFontHandle, lnFontSize) 
			lnAncho = HPDF_Page_TextWidth(.oPage, lcContents) &&Get the size of the text width
		*	lnAlto = HPDF_Page_GetCurrentFontSize(.oPage)
			lnAlto = FontMetric(1, lcFontFace, lnFontSize, .cTextStyle)
			HPDF_Page_SetRGBStroke(.oPage, lnFillRed / 255, lnFillGreen / 255, lnFillBlue / 255) &&Set Forecolor of the text
			HPDF_Page_SetRGBFill(.oPage, lnPenRed / 255, lnPenGreen / 255, lnPenBlue / 255) &&Set Forecolor of the text
			If Bittest(liFontStyle, 2) Then
				lcUnderLineText=Replicate("_", Round(lnAncho/HPDF_Page_TextWidth(.oPage, "_"), 0))
				.lUnderline= .T.
			Else
				.lUnderline= .F.
			EndIf
			If lnRotate=0 Then
				If Empty(lcPicture) Then &&lnOffset=1
					HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + lnAncho + lnCharWidth, nTop - nHeight - lnAlto, lcContents, HPDF_TALIGN_LEFT,0)
					If .lUnderline Then
						HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + lnAncho + lnCharWidth, nTop - nHeight - lnAlto, lcUnderLineText, HPDF_TALIGN_LEFT,0)
					EndIf
				Else 
					*!* With Multiline Labels there is a problem when using lnAncho, so go back to nWidth
					If Chr(13) $ lcContents Or Chr(10) $ lcContents Then
						lnAncho = nWidth
					EndIf
					If lcPicture='"@I"' Then
						HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + lnAncho + lnCharWidth, nTop - nHeight - lnAlto, lcContents, HPDF_TALIGN_CENTER, 0)
						If .lUnderline Then
							HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + lnAncho + lnCharWidth, nTop - nHeight - lnAlto, lcUnderLineText, HPDF_TALIGN_CENTER, 0)
						EndIf
					Else
						HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + lnAncho + lnCharWidth, nTop - nHeight - lnAlto, lcContents, HPDF_TALIGN_RIGHT, 0)
						If .lUnderline Then
							HPDF_Page_TextRect(.oPage, nLeft, nTop, nLeft + lnAncho + lnCharWidth, nTop - nHeight - lnAlto, lcUnderLineText, HPDF_TALIGN_RIGHT, 0)
						EndIf
					EndIf
				EndIf 
			Else
				*!* Let's Draw the rotated text
				Local lnRad As Number
				lnRad = ((lnRotate * -1) / 180) * Pi()
				HPDF_Page_SetTextMatrix (.oPage, Cos(lnRad), Sin(lnRad), -Sin(lnRad), Cos(lnRad), nLeft, nTop)
		    	HPDF_Page_ShowText (.oPage, lcContents)
			EndIf
			HPDF_Page_EndText(.oPage)
		EndWith
	ENDPROC

	PROCEDURE processlines
		Lparameters lnPenRed As Integer,lnPenGreen As Integer,lnPenBlue As Integer,nTop As Number,nLeft As Number,nWidth As Number,;
		nHeight As Number, lnPenSize As Integer, lnOffSet As Number, lnPenPat As Integer, lcStyle As String
		Local lcDash As String
		With This
			If lnPenRed!=-1 And lnPenGreen!=-1 And lnPenBlue!=-1 Then
				HPDF_Page_SetRGBStroke(.oPage, lnPenRed / 255, lnPenGreen / 255, lnPenBlue / 255)
			Else
				HPDF_Page_SetRGBStroke(.oPage, 0, 0, 0)
			EndIf
			nTop = .nPageHeight - nTop
			Do Case
				Case lnPenPat=8 &&Normal Mode
					HPDF_Page_SetDash(.oPage, Null, 0, 0)
				Case lnPenPat=1 &&Dotted
					lcDash=Chr(3) + Chr(0) + Chr(0)
					HPDF_Page_SetDash(.oPage, lcDash, 1, 1)
				Case lnPenPat=2 &&Dashed
					lcDash = Chr(18)+Chr(0)+Chr(6)+Chr(0)+Chr(0)
					HPDF_Page_SetDash(.oPage, lcDash, 2, 2)
				Case lnPenPat=3 &&Dash-dot
					lcDash = Chr(9)+Chr(0)+Chr(6)+Chr(0)+Chr(3)+Chr(0)+Chr(6)+Chr(0)+Chr(0)
					HPDF_Page_SetDash(.oPage, lcDash, 4, 0)
				Case lnPenPat=4 &&Dash-dot-dot
					lcDash = Chr(9)+Chr(0)+Chr(3)+Chr(0)+Chr(3)+Chr(0)+Chr(3)+Chr(0)+Chr(3)+Chr(0)+Chr(3)+Chr(0)+Chr(0)
					HPDF_Page_SetDash(.oPage, lcDash, 6, 0)		
			EndCase
			If lnOffSet=1 Then &&Horizontal Line
				If lnPenSize>=1 Then
					HPDF_Page_SetLineWidth(.oPage, lnPenSize)
				Else
					HPDF_Page_SetLineWidth(.oPage, 0)
				EndIf
				HPDF_Page_MoveTo(.oPage, nLeft, nTop) &&Move to the screen position
				HPDF_Page_LineTo(.oPage, nLeft + nWidth, nTop)
			Else &&Vertical Line
				If lnPenSize>=1 Then
					HPDF_Page_SetLineWidth(.oPage, lnPenSize)
				Else
					HPDF_Page_SetLineWidth(.oPage, 0)
				EndIf
				HPDF_Page_MoveTo(.oPage, nLeft, nTop - nHeight) 
				HPDF_Page_LineTo(.oPage, nLeft, nTop )
			EndIf
			HPDF_Page_Stroke(.oPage)
		EndWith
	ENDPROC

	PROCEDURE processpictures
		Lparameters nTop As Number,nLeft As Number,nWidth As Number,nHeight As Number,lcContents As String,;
			GDIPlusImage As Number, lnOffset As Integer, liPictureMode As Integer, lcStyle As String
		#Define PICTURE_SOURCE_FILENAME         0  && stored in PICTURE column
		#Define PICTURE_SOURCE_GENERAL          1  && stored in NAME    column
		#Define PICTURE_SOURCE_EXPRESSION       2  && stored in NAME    column
		
		Local lcFile As String, lcFile2 As String, lnHandle As Integer
		nTop = This.nPageHeight - nTop
		lnHandle = 0
		Local lnPicWidth, lnPicHeight
		Store 0 TO lnPicWidth, lnPicHeight
		
		If GDIPlusImage != 0 Then &&General Field or Expresion
		
			* CChalom 2010-01-17
			* Removed the dependance of having "System.App" from GdiPlusX
			* Now using _Gdiplus.vcx that is already embedded in ReportOutput.App
		
			*!* Original code
			*!*		Do System.App &&Initialize GDIPLUSX library
			*!*		Local loImage As xfcBitmap
			*!*		With _Screen.System.Drawing
			*!*			loImage = .Bitmap.New()
			*!*			loImage.Handle = GDIPlusImage
			*!*			lcFile = GetEnv("TEMP") + "\" + Sys(2015) + ".Png"
			*!*			loImage.Save(lcFile, .Imaging.Imageformat.Png)
			*!*		EndWith
		
				lcFile = GetEnv("TEMP") + "\" + Sys(2015) + ".Png"
		
				Local loImage As GpImage Of (HOME() + _ReportOutput)
				*loImage = NewObject("GpImage", "_GdiPlus.vcx", _ReportOutput)
				loImage = NEWOBJECT("GpImage", "_GdiPlus.vcx")
				
				loImage.SetHandle(GDIPlusImage)
		
				lnPicWidth = loImage.ImageWidth
				lnPicHeight = loImage.ImageHeight
		
				loImage.SaveToFile(lcFile,"image/png")
			*---
				lnHandle = HPDF_LoadPngImageFromFile(This.pdfHandle, lcFile)
		Else &&File Name
			*!* 10/03/2010 Change to reuse image handles
		
			If File(lcContents) Then
				lcFile = GetEnv("TEMP") + "\" + Sys(2015) + "." + JustExt(lcContents)
				lnHandle = This.GetPictureHandle(lcContents, lcFile, @lnPicWidth, @lnPicHeight)
			EndIf
		EndIf
		If !IsNull(lnHandle) And lnHandle > 0 Then &&Valid Image Handle
			Do Case
				Case liPictureMode = 0 &&Clip
					lnHandle = This.CropImage(lcFile, nHeight, nWidth)
					HPDF_Page_DrawImage(This.oPage, lnHandle, nLeft, nTop - nHeight, nWidth, nHeight)
				Case liPictureMode = 1 &&Scale Keeping the Shape
					* CChalom
					* Calculating the image size for isometric images
					If lnPicWidth = 0
						Local loVFPImg as Image
						loVFPImg = CreateObject("Image")
						loVFPImg.Picture = lcFile
						lnPicWidth = loVFPImg.Width
						lnPicHeight = loVFPImg.Height
						loVFPImg = NULL
					EndIf
					lnPicWidth = (lnPicWidth / 960) * 72
					lnPicHeight = (lnPicHeight / 960) * 72 
		
					* Isometric Adjustment
					Local lnHorFactor, lnVertFactor, lnResizeFactor, lnIsoWidth, lnIsoHeight
					m.lnHorFactor = m.nWidth / m.lnPicWidth
					m.lnVertFactor = m.nHeight / m.lnPicHeight
					m.lnResizeFactor = MIN(m.lnHorFactor, m.lnVertFactor)
					m.lnIsoWidth = m.lnPicWidth * m.lnResizeFactor
					m.lnIsoHeight = m.lnPicHeight * m.lnResizeFactor
		
					HPDF_Page_DrawImage(This.oPage, lnHandle, nLeft, nTop - lnIsoHeight, lnIsoWidth, lnIsoHeight)
		
					* ---
				Otherwise &&Stretch
					HPDF_Page_DrawImage(This.oPage, lnHandle, nLeft, nTop - nHeight, nWidth, nHeight)
			EndCase
		EndIf
		*!* 10/03/2010 Luis Navas
		*!* Changed the name of this property from oImagesCollection to oTempImagesCollection to avoid confusion of users
		If Vartype(This.oTempImagesCollection) != "O" Then
			This.oTempImagesCollection= CreateObject("Collection")
		EndIf
		This.oTempImagesCollection.Add(lcFile)
	ENDPROC

	PROCEDURE processshapes
		Lparameters lnFillRed As Integer,lnFillGreen As Integer,lnFillBlue As Integer,lnPenRed As Integer,lnPenGreen As Integer,;
			lnPenBlue As Integer,nLeft As Number,nTop As Number,nWidth As Number,nHeight As Number,lnOffset As Integer, ;
			lnPenSize As Integer, lnPenPat As Integer, lnFillPat As Integer, lcStyle As String, lnMode as Integer
		
		Local lcDash As String, nTop2 As Integer
		
		With This
			*!* Code to handle the Dynamic Options added in SP2
			If !Empty(lcStyle) Then &&Dynamic Properties are stored here as xml
				If .ProcessDynamics(lcStyle, "SHAPE") Then
					nHeight = Iif(PemStatus(.oDynamics, "nHeight",5), Iif(.oDynamics.nHeight!=-1, (.oDynamics.nHeight / 960) * 72, nHeight), nHeight)
					nWidth = Iif(PemStatus(.oDynamics, "nWidth",5), Iif(.oDynamics.nWidth!=-1, (.oDynamics.nWidth / 960) * 72, nWidth), nWidth)
				EndIf
			EndIf
			nTop2 = nTop
			nTop = .nPageHeight - nTop
		
		
			If lnFillRed = -1
				lnFillRed 	= 255
				lnFillGreen = 255
				lnFillBlue 	= 255
			ENDIF 
		
			IF lnMode = 0 AND lnFillPat > 0 && Opaque
				HPDF_Page_SetRGBFill(This.oPage, lnFillRed / 255, lnFillGreen / 255, lnFillBlue / 255)
				lnMode = 0
			ELSE
				lnMode = 1
			ENDIF 
			
		*!*			If lnFillRed!=-1 And lnFillGreen!=-1 And lnFillBlue!=-1 Then
		*!*				HPDF_Page_SetRGBFill(This.oPage, lnFillRed / 255, lnFillGreen / 255, lnFillBlue / 255)
		*!*			ELSE
		*!*				IF lnMode = 0 AND .FillPat > 0 && Opaque
		*!*					HPDF_Page_SetRGBFill(This.oPage, 1, 1, 1) && White
		*!*				ENDIF 
		*!*			EndIf
		
		
		
			If lnPenRed = -1
				lnPenRed 	= 0
				lnPenGreen 	= 0
				lnPenBlue 	= 0
			ENDIF 
			HPDF_Page_SetRGBStroke(.oPage, lnPenRed / 255, lnPenGreen / 255, lnPenBlue / 255)
		
		
		*!*		If lnPenRed!=-1 And lnPenGreen!=-1 And lnPenBlue!=-1 Then
		*!*			HPDF_Page_SetRGBStroke(.oPage, lnPenRed / 255, lnPenGreen / 255, lnPenBlue / 255)
		*!*		Else
		*!*			HPDF_Page_SetRGBStroke(.oPage, 0, 0, 0)
		*!*		EndIf
		
		
			If lnPenSize>=1 Then
				HPDF_Page_SetLineWidth(.oPage, lnPenSize)
			Else
				HPDF_Page_SetLineWidth(.oPage, 0)
			EndIf
			Do Case
				Case lnPenPat=8 &&Normal Mode
					HPDF_Page_SetDash(.oPage, Null, 0, 0)
				Case lnPenPat=1 &&Dotted
					lcDash=Chr(3) + Chr(0) + Chr(0)
					HPDF_Page_SetDash(.oPage, lcDash, 1, 1)
				Case lnPenPat=2 &&Dashed
					lcDash = Chr(18)+Chr(0)+Chr(6)+Chr(0)+Chr(0)
					HPDF_Page_SetDash(.oPage, lcDash, 2, 2)
				Case lnPenPat=3 &&Dash-dot
					lcDash = Chr(9)+Chr(0)+Chr(6)+Chr(0)+Chr(3)+Chr(0)+Chr(6)+Chr(0)+Chr(0)
					HPDF_Page_SetDash(.oPage, lcDash, 4, 0)
				Case lnPenPat=4 &&Dash-dot-dot
					lcDash = Chr(9)+Chr(0)+Chr(3)+Chr(0)+Chr(3)+Chr(0)+Chr(3)+Chr(0)+Chr(3)+Chr(0)+Chr(3)+Chr(0)+Chr(0)
					HPDF_Page_SetDash(.oPage, lcDash, 6, 0)		
			EndCase
			Do Case
				Case lnOffSet=0 &&Normal Rectangle
					HPDF_Page_Rectangle(.oPage, nLeft, nTop - nHeight, nWidth, nHeight)
				Case Between(lnOffSet, 1, 98) &&Rounded Rectangle
					*!* Code to Draw Rounded Rectangle Courtesy of Dorin Vasilescu
					Local nRay As Number, nb As Number
					nRay = Round(Iif(nWidth > nHeight, Min(lnOffSet, Int(nHeight / 2)), Min(lnOffSet, Int(nWidth / 2))), 0)
		      		nB = .nPageHeight - (nTop2 + nHeight) 
					HPDF_Page_MoveTo(.oPage, nLeft + nRay, nB)
					HPDF_Page_LineTo(.oPage, (nLeft + nWidth) - nRay, nB)
					HPDF_Page_CurveTo(.oPage, (nLeft + nWidth), nB, (nLeft + nWidth), nB, (nLeft + nWidth), nB + nRay) 
					HPDF_Page_LineTo(.oPage, (nLeft + nWidth), nTop - nRay)
					HPDF_Page_CurveTo(.oPage, (nLeft + nWidth), nTop, (nLeft + nWidth), nTop, (nLeft + nWidth) - nRay, nTop)
					HPDF_Page_LineTo(.oPage, nLeft + nRay, nTop)
					HPDF_Page_CurveTo(.oPage, nLeft, nTop, nLeft, nTop, nLeft, nTop - nRay)
					HPDF_Page_LineTo(.oPage, nLeft , nB + nRay)
					HPDF_Page_CurveTo(.oPage, nLeft, nB , nLeft, nB, nLeft + nRay, nB)
				Case lnOffSet=99 &&Ellipsis
					HPDF_Page_Ellipse(.oPage, nLeft + (nWidth / 2), nTop - (nHeight / 2), nWidth / 2, nHeight / 2)
			EndCase
		
		
			* Mode: 0 = Opaque background; 1 = Transparent
			IF lnMode = 1 && Transparent
				HPDF_Page_Stroke(.oPage)
			ELSE && 0 = Opaque
				HPDF_Page_FillStroke(.oPage)
			ENDIF 
		EndWith
	ENDPROC

	PROCEDURE Render
		Lparameters nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage
		
		* CChalom 2010-01-25
		* If the report page is not between the page ranges asked, just skip
		IF This.PageNo > This.nGlobalPgCounter OR This.nPgCounter = 0
			This.nPgCounter = This.nPgCounter + 1
			This.nGlobalPgCounter = This.nGlobalPgCounter + 1
		ENDIF
		LOCAL lnRangeTo
		lnRangeTo = This.CommandClauses.RangeTo
		IF lnRangeTo <> -1 AND NOT BETWEEN(This.nPgCounter, This.CommandClauses.RangeFrom, lnRangeTo)
			NODEFAULT 
			RETURN 
		ENDIF 
		*---
		
		#Define OBJ_COMMENT                  0
		#Define OBJ_LABEL                    5
		#Define OBJ_LINE                     6
		#Define OBJ_RECTANGLE                7
		#Define OBJ_FIELD                    8
		#Define OBJ_PICTURE                 17
		#Define OBJ_VARIABLE                18
		If This.TwoPassProcess And This.CurrentPass=0 Then &&Code to detect if report will run twice because of use of _PAGETOTAL
			DoDefault(nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage)
			Return
		EndIf
		Local lcContents As String, loError As Exception
		*!* Modify the measures according to the PDF library
		nLeft = (nLeft / 960) * 72
		nTop = (nTop / 960) * 72
		nWidth = (nWidth / 960) * 72
		nHeight = (nHeight / 960) * 72 
		With This
			.SetFRXDataSession()
			If !.lStarted Then &&Start PDF Document
				.StartPdfDocument() &&Method Called to Start the PDF Generation
				.nLastPageProccesed = .PageNo
			EndIf
			If .PageNo!=.nLastPageProccesed Then &&Add a New Page
				.AddBlankPage()
				.nLastPageProccesed = .PageNo
			EndIf
			If Empty(cContentsToBeRendered) Then
				lcContents = ''
			EndIf
		EndWith
		*!* Change to FRX Datasession and take out the important values
		Go nFRXRecno In FRX
		Scatter Memo Name oFrx
		With oFrx
			*!* Restore Report Datasession
			This.ResetDataSession()
			*!* Start Generation Proccess depending of Object Type
			Do Case
				Case .ObjType=OBJ_LABEL &&Label
					If !Empty(.ResoId) And .ResoId!=1 Then
						&&Convert from Unicode
						lcContents = Strconv(cContentsToBeRendered, 6, .ResoId, 2)
						This.Tag = lcContents
					Else
						&&Convert from Unicode
						lcContents = Strconv(cContentsToBeRendered, 6)
						This.Tag = ""
					EndIf
					Try
						This.ProcessLabel(.FontFace, .FontStyle,.FontSize,.PenRed,.PenGreen,.PenBlue,.FillRed,.FillGreen,.FillBlue,nLeft,nTop,lcContents,.FillChar,.Offset,nWidth, ;
							.ResoId,nHeight,.Picture,.Style, .Mode)
					Catch To loError
						*!* Handle Error Here
					EndTry
				Case .ObjType=OBJ_FIELD &&Field
					If !Empty(.ResoId) And .ResoId!=1 Then
						&&Convert from Unicode
						lcContents = Strconv(cContentsToBeRendered, 6, .ResoId, 2)
						This.Tag = lcContents
					Else
						&&Convert from Unicode
						lcContents = Strconv(cContentsToBeRendered, 6)
						This.Tag = ""
					EndIf
					Try
						This.ProcessFields(.FontFace,.FontStyle,.FontSize,.PenRed,.PenGreen,.PenBlue,.FillRed,.FillGreen,.FillBlue,nLeft,nTop,lcContents,.FillChar,.Offset, ;
							.Stretch,.ResoId,nHeight,nWidth,.Style, .Mode, .User)
					Catch To loError
						*!* Handle Error Here
					EndTry
				Case .ObjType=OBJ_LINE  &&Line
					Try
						This.ProcessLines(.PenRed, .PenGreen, .PenBlue, nTop, nLeft, nWidth, nHeight, .PenSize, .Offset, .PenPat, .Style)
					Catch To loError
						*!* Handle Error Here
					EndTry
				Case .ObjType=OBJ_PICTURE &&Picture or General Field
					lcContents =cContentsToBeRendered
					Try
						This.ProcessPictures(nTop, nLeft, nWidth, nHeight, lcContents, GDIPlusImage, .Offset, .General, .Style)
					Catch To loError
						*!* Handle Error Here
					EndTry
				Case .ObjType=OBJ_RECTANGLE &&Rectangle
					Try
						This.ProcessShapes(.FillRed, .FillGreen, .FillBlue, .PenRed, .PenGreen, .PenBlue, nLeft, nTop, nWidth, nHeight, .Offset, .PenSize, .PenPat, .FillPat, .Style, .Mode)
					Catch To loError
						*!* Handle Error Here
					EndTry
			EndCase
		EndWith
	ENDPROC

	PROCEDURE resetdatasession
		Try
			Set DataSession To (This.CurrentDataSession)
		Catch When .T.
			*Can't Return DataSession to do: handle this
		EndTry
	ENDPROC

	PROCEDURE searchfont
		Lparameters lcFontName As String, lnStyle As Integer &&, lnCodePage As Integer
		Local lcRetorno As String
		With This
			If Bittest(lnStyle, 0) Then &&Bold 
				lcFontName = lcFontName + " Bold"
				.cTextStyle="B"
			EndIf
			If Bittest(lnStyle, 1) Then &&Italic
				lcFontName = lcFontName + " Italic"
				.cTextStyle = .cTextStyle + "I"
			EndIf
			Local lbResult As Boolean, lnI As Integer
			*!* Look for the font in the current collection
			For lnI=1 To .oFonts.Count
				If This.oFonts.GetKey(lnI)==lcFontName Then
					lbResult = .T.
					Exit
				EndIf
			EndFor
			If !lbResult Then &&Font Does Not Exists, let's added it to the collection
				Local lcKey As String
				lcKey = .FindFontFileName(lcFontName)
				If !Empty(lcKey) Then
					.oFonts.Add(lcKey, lcFontName)
				Else &&Can't add fonts 
					lcFontName = "Times-Roman" 
				EndIf
			EndIf
			lcRetorno = .oFonts.Item(.oFonts.GetKey(lcFontName))
		EndWith
		Return lcRetorno
	ENDPROC

	PROCEDURE setfrxdatasession
		With This
			If (.FRXDatasession > -1) And (.FRXDatasession # Set("DATASESSION")) Then
				Try
					Set DataSession To (.FRXDatasession)
				Catch When .T.
					.ResetToDefault("FRXDataSession")
					.ResetDataSession()
				EndTry
			EndIf
		EndWith
	ENDPROC

	PROCEDURE shellexec
		Lparameter lcLink As String, lcAction As String, lcParms As String
		lcAction = Iif(Empty(lcAction), "Open", lcAction)
		lcParms = Iif(Empty(lcParms), "", lcParms)
		Declare Integer ShellExecute In SHELL32.Dll Integer nWinHandle, String cOperation, String cFileName, String cParameters, String cDirectory, Integer nShowWindow
		Declare Integer FindWindow In WIN32API String cNull,String cWinName
		Return ShellExecute(FindWindow(0, _Screen.Caption), lcAction, lcLink, lcParms, Sys(2023), 1)
	ENDPROC

	PROCEDURE startpdfdocument
		With This
		
			* CChalom 2010-01-20
			* Added "lStarted" property in order to allow merging reports
			SET TALK OFF 
			SET CONSOLE OFF 
		
			IF .pdfHandle = 0 AND NOT .lStarted
				.pdfHandle=HPDF_New(0, 0) &&Create a New Document
				HPDF_SetCompressionMode(.pdfHandle, HPDF_COMP_ALL) &&Set Document Compression Method
		
				* KHentschel 2010-06-15
				* Added "nPageMode" property: how Document should be displayed HPDF_PAGE_MODE_USE_OUTLINE
				* HPDF_SetPageMode(.pdfHandle, HPDF_PAGE_MODE_USE_OUTLINE) &&Set the how Document should be displayed
				* Available possibilities:
				* #define    HPDF_PAGE_MODE_USE_NONE		0
				* #define    HPDF_PAGE_MODE_USE_OUTLINE		1
				* #define    HPDF_PAGE_MODE_USE_THUMBS		2
				* #define    HPDF_PAGE_MODE_FULL_SCREEN		3
				HPDF_SetPageMode(.pdfHandle, .nPageMode)
		
		
				.WritePdfInformation() &&Stablish PDF File Information
				.EncryptPdf()
				.AddBlankPage()
				.lStarted=.T.
			ENDIF 
		EndWith
	ENDPROC

	PROCEDURE UnloadReport
		DoDefault()
		With This
			* CChalom 2010-01-20
			* Added "WaitForNextReport" property in order to allow merging reports
			* If another report is expected to come, don't close the objects and handles
			If Not .WaitForNextReport 
				If VarType(.oTempImagesCollection) = "O" Then && Cleanup Temporary Images Files
					Local lcItem As String
					For Each lcItem In .oTempImagesCollection FOXOBJECT
						Delete File (lcItem)
					EndFor
					.oTempImagesCollection = Null
				EndIf
				.oDynamics = Null
				If Used("_TempDynamics") Then
					Use In "_TempDynamics"
				EndIf
				.ClearDLLS()
		
				LOCAL llConsole, llTalk
				llConsole = This._lSetConsole
				llTalk = This._lSetTalk
				 
				SET CONSOLE &llConsole.
				SET TALK &llTalk.
		
			ENDIF
		ENDWITH 
	ENDPROC

	PROCEDURE writepdfinformation
		With This
			If !Empty(.cPdfAuthor) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_AUTHOR, .cPdfAuthor)
			EndIf
			If !Empty(.cPdfTitle) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_TITLE, .cPdfTitle)
			EndIf
			If !Empty(.cPdfSubject) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_SUBJECT, .cPdfSubject)
			EndIf
			If !Empty(.cPdfKeyWords) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_KEYWORDS, .cPdfKeywords)
			EndIf
			If !Empty(.cPdfCreator) Then
				HPDF_SetInfoAttr(.pdfHandle, HPDF_INFO_CREATOR, .cPdfCreator)
			EndIf
		EndWith
	ENDPROC

ENDDEFINE

DEFINE CLASS registry AS custom 		&& Provides read and write access to the  System Registry. The Functionality provided is greatly abstracted resulting in using a single method call to set and retrieve values from the registry.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "hpdf_consts.h"
	*<DefinedPropArrayMethod>
		*m: deleteregistrykey		&& Elimina una llave del registro de Windows
		*m: enumregistrykey		&& Retorna un valor del registro basado en un indice. Permite llamadas desde un ciclo FOR
		*m: enumvalue		&& Retorna el nombre de un valor del registro
		*m: examples		&& Ejemplos de Uso de la Clase
		*m: getenumkeys		&& Retorna todas las subclaves de una clave especificada
		*m: getenumvalues		&& Retorna todos los valores de una llave en un array
		*m: readregistryint		&& Lee un valor Integer (DWORD)  o Short en el registro de Windows
		*m: readregistrystring		&& Lee un Valor String del Registro de Windows
		*m: writeregistrybinary		&& Escribe un valor binario en el registro de Windows
		*m: writeregistryint		&& Escribe una valor numérico en el Registro de windows
		*m: writeregistrystring		&& Escribe una valor String en el Registro de Windows
	*</DefinedPropArrayMethod>

	Height = 19
	Name = "registry"
	Width = 35
	
	PROCEDURE deleteregistrykey		&& Elimina una llave del registro de Windows
		************************************************************************
		* Registry :: DeleteRegistryKey
		*********************************
		***  Function: Deletes a registry key. Note this does not delete
		***            an entry but the key (ie. a path node).
		***            Use WriteRegistryString/Int with a .NULL. to
		***            Delete an entry.
		***      Pass: tnHKey    -   Registry Root node key
		***            tcSubkey  -   Path to clip
		***    Return: .T. or .NULL.
		************************************************************************
		Lparameters tnHKEY,tcSubKey
		Local lnResult, lnRegHandle
		tnHKEY=Iif(Type("tnHKey")="N",tnHKEY,HKEY_LOCAL_MACHINE)
		lnRegHandle=0
		lnResult=RegOpenKey(tnHKEY,tcSubKey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Key doesn't exist or can't be opened
			Return .Null.
		EndIf
		lnResult=RegDeleteKey(tnHKEY,tcSubKey)
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		Return .T.
	ENDPROC

	PROTECTED PROCEDURE enumregistrykey		&& Retorna un valor del registro basado en un indice. Permite llamadas desde un ciclo FOR
		************************************************************************
		* wwAPI :: EnumRegistryKey
		*********************************
		***  Function: Returns a registry key name based on an index
		***            Allows enumeration of keys in a FOR loop. If key
		***            is empty end of list is reached or the key doesn't
		***            exist or is empty.
		***      Pass: tnHKey    -   HKEY_ root key
		***            tcSubkey  -   Subkey string
		***            tnIndex   -   Index of key name to get (0 based)
		***    Return: "" on error - Key name otherwise
		************************************************************************
		Lparameters tnHKey, tcSubKey, tnIndex
		Local lcSubKey, lcReturn, lnResult, lcDataBuffer
		lnRegHandle=0
		*** Open the registry key
		lnResult=RegOpenKey(tnHKey,tcSubKey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Not Found
			Return .Null.
		EndIf
		Declare Integer RegEnumKey ;
			IN WIN32API ;
			INTEGER nHKey, ;
			INTEGER nIndex, ;
			STRING @cSubkey, ;
			INTEGER nSize
		lcDataBuffer=Space(MAX_INI_BUFFERSIZE)
		lnSize=MAX_INI_BUFFERSIZE
		lnReturn=RegEnumKey(lnRegHandle, tnIndex, @lcDataBuffer, lnSize)
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Not Found
			Return .Null.
		EndIf
		Return Trim(Chrtran(lcDataBuffer,Chr(0),""))
	ENDPROC

	PROTECTED PROCEDURE enumvalue		&& Retorna el nombre de un valor del registro
		************************************************************************
		* Registry :: EnumValue
		*********************************
		***  Function: Returns the name of a registry Value key. Note the actual
		***            Value is not returned but just the key. This is done
		***            so you can check the type first and use the appropriate
		***            ReadRegistryX method. The type is returned by ref in the
		***            last parameter.
		***    Assume:
		***      Pass: tnHKey   -   HKEY value
		***            tcSubkey -   The key to enumerate valuekeys for
		***            tnIndex  -   Index of key to work on
		***            @tnType  -   Used to pass back the type of the value
		***    Return: String of ValueKey or .NULL.
		************************************************************************
		Lparameters tnHKey, tcSubKey, tnIndex, tnType
		Local lcSubKey, lcReturn, lnResult, lcDataBuffer
		tnType=Iif(Type("tnType")="N",tnType,0)
		lnRegHandle=0
		*** Open the registry key
		lnResult=RegOpenKey(tnHKey,tcSubKey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Not Found
			Return .Null.
		EndIf
		*** Need to define here specifically for Return Type
		*** for lpdData parameter or VFP will choke.
		*** Here it's STRING.
		Declare Integer RegEnumValue ;
			IN Win32API ;
			INTEGER nHKey,;
			INTEGER nIndex,;
			STRING @lpszValueName,;
			INTEGER @lpdwSize,;
			INTEGER dwReserved,;
			INTEGER @lpdwType,;
			STRING @lpbData,;
			INTEGER @lpcbData
		tcSubKey=Space(MAX_INI_BUFFERSIZE)
		tcValue=Space(MAX_INI_BUFFERSIZE)
		lnSize=MAX_INI_BUFFERSIZE
		lnValSize=MAX_INI_BUFFERSIZE
		lnReturn=RegEnumValue(lnRegHandle, tnIndex, @tcSubKey,@lnValSize, 0, @tnType, @tcValue, @lnSize)
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Not Found
			Return .Null.
		EndIf
		Return Trim(Chrtran(tcSubKey,Chr(0),""))
		
	ENDPROC

	PROCEDURE examples		&& Ejemplos de Uso de la Clase
		*** Create a new Tree
		? oRegistry.WriteRegistryString(HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies",;
		                               "","",.T.)
		
		*** Now create a a key off the root and add a value                                
		? oRegistry.WriteRegistryString(HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies\WebConnection",;
		                               "CurrentVersion","1.45",.T.)
		
		*** Add another Value - numeric
		? oRegistry.WriteRegistryInt  (HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies\WebConnection",;
		                               "Timeout",60,.T.)
		
		*** Now Read the values back
		? oRegistry.ReadRegistryString(HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies\WebConnection",;
		                               "CurrentVersion")
		
		? oRegistry.ReadRegistryInt(HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies\WebConnection",;
		                               "Timeout")
		
		*** Uncomment this code to delete the registry entries again
		
		*-**** Now delete the value entries - Write with a NULL
		*-*? oRegistry.WriteRegistryString(HKEY_LOCAL_MACHINE,;
		*-*                               "SOFTWARE\West Wind Technologies\WebConection",;
		*-*                               "CurrentVersion",.NULL.,.T.)
		*-*
		*-**** And the numeric entry - again with a .NULL.
		*-*? oRegistry.WriteRegistryInt  (HKEY_LOCAL_MACHINE,;
		*-*                               "SOFTWARE\West Wind Technologies\WebConection",;
		*-*                               "Timeout",.NULL.,.T.)
		*-*
		*-**** Get rid of the keys - Web Connection
		*-*? oRegistry.DeleteRegistryKey(HKEY_LOCAL_MACHINE,;
		*-*                            "SOFTWARE\West Wind Technologies\WebConection")
		*-*
		*-**** Again the West Wind Technologies Key
		*-*? oRegistry.DeleteRegistryKey(HKEY_LOCAL_MACHINE,;
		*-*                              "SOFTWARE\West Wind Technologies")
		
		*#ENDIF
		
	ENDPROC

	PROCEDURE getenumkeys		&& Retorna todas las subclaves de una clave especificada
		************************************************************************
		* Registry :: GetEnumKeys
		*********************************
		***  Function: Returns an array of all subkeys for a given key
		***            NOTE: This function does not return Value Keys only
		***                  Tree Keys!!!!
		***      Pass: @taKeys  -   An array that gets filled with key names
		***            tnHKEY   -   Root Key
		***            tcSubkey -   Subkey to enumerate for
		***    Return: Number of keys or 0
		************************************************************************
		Lparameters taKeys, tnHKey, tcSubKey
		Local x, lcKey
		lcKey="x"
		x=0
		Do While !Empty(lcKey) Or Isnull(lcKey)
			lnType=0
			lcKey=This.EnumKey(tnHKey,tcSubKey,x)
			If Isnull(lcKey) Or Empty(lcKey)
				Exit
			EndIf
			x=x+1
			Dimension  taKeys[x]
			taKeys[x]=lcKey
		EndDo
		
		Return x
	ENDPROC

	PROCEDURE getenumvalues		&& Retorna todos los valores de una llave en un array
		************************************************************************
		* Registry :: GetEnumValues
		*********************************
		***  Function: Retrieves all Values off a key into an array. The
		***            array is 2D and consists of: Key Name, Value
		***    Assume: Not tested with non-string values
		***      Pass: @taValues     -   Result Array: Pass by Reference
		***            tnHKEY        -   ROOT KEY value
		***            tcSubKey      -   SubKey to work on
		***    Return: Count of Values retrieved
		************************************************************************
		Lparameters taValues, tnHKey, tcSubKey
		Local x, lcKey
		lcKey="x"
		x=0
		Do While !Empty(lcKey) Or Isnull(lcKey)
			lnType=0
			lcKey=This.EnumValue(tnHKey,tcSubKey,x,@lnType)
			If Isnull(lcKey) Or Empty(lcKey)
				Exit
			EndIf
			x=x+1
			Dimension  taValues[x,2]
		
			Do Case
			Case lnType=REG_SZ Or lnType=REG_BINARY Or lnType=REG_NONE
				lcValue=oRegistry.ReadRegistryString(tnHKey,tcSubKey,lcKey)
				taValues[x,1]=lcKey
				taValues[x,2]=lcValue
			Case lnType=REG_DWORD
				lnValue=oRegistry.ReadRegistryInt(tnHKey,tcSubKey,lcKey)
				taValues[x,1]=lcKey
				taValues[x,2]=lnValue
			Otherwise
				taValues[x,1]=lcKey
				taValues[x,2]=""
			EndCase
		EndDo
		Return x
	ENDPROC

	PROCEDURE Init
		************************************************************************
		* Registry :: Init
		*********************************
		***  Function: Loads required DLLs. Note Read and Write DLLs are
		***            not loaded here since they need to be reloaded each
		***            time depending on whether String or Integer values
		***            are required
		************************************************************************
		
		*** Open Registry Key
		Declare Integer RegOpenKey ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING cSubKey,;
			INTEGER @nHandle
		
		*** Create a new Key
		Declare Integer RegCreateKey ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING cSubKey,;
			INTEGER @nHandle
		
		*** Close an open Key
		Declare Integer RegCloseKey ;
			IN Win32API ;
			INTEGER nHKey
		
		*** Delete a key (path)
		Declare Integer RegDeleteKey ;
			IN Win32API ;
			INTEGER nHKEY,;
			STRING cSubkey
		
		*** Delete a value from a key
		Declare Integer RegDeleteValue ;
			IN Win32API ;
			INTEGER nHKEY,;
			STRING cEntry
	ENDPROC

	PROCEDURE readregistryint		&& Lee un valor Integer (DWORD)  o Short en el registro de Windows
		************************************************************************
		* Registry :: ReadRegistryInt
		*********************************
		***  Function: Reads an integer (DWORD) or short (4 byte or less) binary
		***            value from the registry.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to retrieve
		***    Return: Registry String or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		
		lnRegHandle=0
		
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		*** Need to define here specifically for Return Type
		*** for lpdData parameter or VFP will choke.
		*** Here's it's an INTEGER
		Declare Integer RegQueryValueEx ;
			IN Win32API As RegQueryInt;
			INTEGER nHKey,;
			STRING lpszValueName,;
			INTEGER dwReserved,;
			Integer @lpdwType,;
			INTEGER @lpbData,;
			INTEGER @lpcbData
		
		lnDataBuffer=0
		lnSize=4
		lnResult=RegQueryInt(lnRegHandle,tcEntry,0,@tnType,;
			@lnDataBuffer,@lnSize)
		=RegCloseKey(lnRegHandle)
		
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		Return lnDataBuffer
		
	ENDPROC

	PROCEDURE readregistrystring		&& Lee un Valor String del Registro de Windows
		************************************************************************
		* Registry :: ReadRegistryString
		*********************************
		***  Function: Reads a string value from the registry.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to retrieve
		***    Return: Registry String or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		
		lnRegHandle=0
		
		*** Open the registry key
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		*** Need to define here specifically for Return Type
		*** for lpdData parameter or VFP will choke.
		*** Here it's STRING.
		Declare Integer RegQueryValueEx ;
			IN Win32API As RegQueryString;
			INTEGER nHKey,;
			STRING lpszValueName,;
			INTEGER dwReserved,;
			INTEGER @lpdwType,;
			STRING @lpbData,;
			INTEGER @lpcbData
		
		*** Return buffer to receive value
		lcDataBuffer=Space(MAX_INI_BUFFERSIZE)
		lnSize=Len(lcDataBuffer)
		lnType=0
		
		lnResult=RegQueryString(lnRegHandle,tcEntry,0,@lnType,;
			@lcDataBuffer,@lnSize)
		
		=RegCloseKey(lnRegHandle)
		
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		If lnSize<2
			Return ""
		EndIf
		
		*** Return string based on length returned
		Return Substr(lcDataBuffer,1,lnSize-1)
		
		
	ENDPROC

	PROCEDURE writeregistrybinary		&& Escribe un valor binario en el registro de Windows
		************************************************************************
		* Registry :: WriteRegistryBinary
		*********************************
		***  Function: Writes a binary value to the registry.
		***            Binary must be written as character values:
		***            chr(80)+chr(13)  will result in "50 1D"
		***            for example.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to write to
		***            tcValue   -  Value to write or .NULL. to delete key
		***            tnLength  -  you have to supply the length
		***            tlCreate  -  Create if it doesn't exist
		***    Assume: Use with extreme caution!!! Blowing your registry can
		***            hose your system!
		***    Return: .T. or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry, tcValue,tnLength,tlCreate
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		tnLength=Iif(Type("tnLength")="N",tnLength,Len(tcValue))
		lnRegHandle=0
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			If !tlCreate
				Return .Null.
			Else
				lnResult=RegCreateKey(tnHKey,tcSubkey,@lnRegHandle)
				If lnResult#ERROR_SUCCESS
					Return .Null.
				EndIf
			EndIf
		EndIf
		
		*** Need to define here specifically for Return Type!
		*** Here lpbData is STRING.
		Declare Integer RegSetValueEx ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING lpszEntry,;
			INTEGER dwReserved,;
			INTEGER fdwType,;
			STRING @lpbData,;
			INTEGER cbData
		
		*** Check for .NULL. which means delete key
		If !Isnull(tcValue)
		*** Nope - write new value
			lnResult=RegSetValueEx(lnRegHandle,tcEntry,0,REG_BINARY,;
				@tcValue,tnLength)
		Else
		*** DELETE THE KEY
			lnResult=RegDeleteValue(lnRegHandle,tcEntry)
		EndIf
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		Return .T.
	ENDPROC

	PROCEDURE writeregistryint		&& Escribe una valor numérico en el Registro de windows
		************************************************************************
		* Registry :: WriteRegistryInt
		*********************************
		***  Function: Writes a numeric value to the registry.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to write to
		***            tcValue   -  Value to write or .NULL. to delete key
		***            tlCreate  -  Create if it doesn't exist
		***    Assume: Use with extreme caution!!! Blowing your registry can
		***            hose your system!
		***    Return: .T. or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry, tnValue,tlCreate
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		lnRegHandle=0
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			If !tlCreate
				Return .Null.
			Else
				lnResult=RegCreateKey(tnHKey,tcSubkey,@lnRegHandle)
				If lnResult#ERROR_SUCCESS
					Return .Null.
				EndIf
			EndIf
		EndIf
		
		*** Need to define here specifically for Return Type!
		*** Here lpbData is STRING.
		Declare Integer RegSetValueEx ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING lpszEntry,;
			INTEGER dwReserved,;
			INTEGER fdwType,;
			INTEGER @lpbData,;
			INTEGER cbData
		
		*** Check for .NULL. which means delete key
		If !Isnull(tnValue)
		*** Nope - write new value
			lnSize=4
			lnResult=RegSetValueEx(lnRegHandle,tcEntry,0,REG_DWORD,;
				@tnValue,lnSize)
		Else
		*** DELETE THE KEY
			lnResult=RegDeleteValue(lnRegHandle,tcEntry)
		EndIf
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		Return .T.
	ENDPROC

	PROCEDURE writeregistrystring		&& Escribe una valor String en el Registro de Windows
		************************************************************************
		* Registry :: WriteRegistryString
		*********************************
		***  Function: Reads a string value from the registry.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to write to
		***            tcValue   -  Value to write or .NULL. to delete key
		***            tlCreate  -  Create if it doesn't exist
		***    Assume: Use with extreme caution!!! Blowing your registry can
		***            hose your system!
		***    Return: .T. or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry, tcValue,tlCreate
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		
		lnRegHandle=0
		
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			If !tlCreate
				Return .Null.
			Else
				lnResult=RegCreateKey(tnHKey,tcSubkey,@lnRegHandle)
				If lnResult#ERROR_SUCCESS
					Return .Null.
				EndIf
			EndIf
		EndIf
		
		*** Need to define here specifically for Return Type!
		*** Here lpbData is STRING.
		Declare Integer RegSetValueEx ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING lpszEntry,;
			INTEGER dwReserved,;
			INTEGER fdwType,;
			STRING lpbData,;
			INTEGER cbData
		
		*** Check for .NULL. which means delete key
		If !Isnull(tcValue)
		*** Nope - write new value
			lnSize=Len(tcValue)
			lnResult=RegSetValueEx(lnRegHandle,tcEntry,0,REG_SZ,;
				tcValue,lnSize)
		Else
		*** DELETE THE KEY
			lnResult=RegDeleteValue(lnRegHandle,tcEntry)
		EndIf
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		Return .T.
		
	ENDPROC

ENDDEFINE
