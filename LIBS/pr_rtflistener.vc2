*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="pr_rtflistener.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS rtfreportlistener AS reportlistener 
	*<ClassComment>
		** VFP reports to rtf converter
		** Class is based on report listener clas.
		** It permits to see VFP reports in MS Word
		** Authors -Vladimir Zhuravlev, Dmitriy Petrov, Valeriy Lifshits
		** with help of Vadim Pirozhkov and Andrey Petrov
	*</ClassComment>
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: dectoproc
		*m: fontstyleconvert
		*m: frxtotwips
		*m: getfrxrecord
		*m: gettype
		*m: himetrictortf
		*m: mabout
		*m: outtortf
		*m: pagesetup
		*m: rtf_create
		*m: rtf_save
		*m: twips
		*p: borderwidth		&& Øèðèíà ðàìêè
		*p: b_margin
		*p: code_page
		*p: handle
		*p: lofrxrecord
		*p: lstarted
		*p: l_margin
		*p: nglobalpgcounter
		*p: npgcounter
		*p: oldpageno
		*p: orecord
		*p: paper_letter
		*p: pg_height
		*p: pg_width
		*p: rp_alias
		*p: rtf_filename
		*p: r_margin
		*p: targetfilename
		*p: t_margin
		*p: waitfornextreport
		*a: arcolors[1,4]
		*a: arfont[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	borderwidth = 0		&& Øèðèíà ðàìêè
	b_margin = 0
	code_page = 1251
	FRXDataSession = -1
	handle = 
	Height = 23
	lofrxrecord = .NULL.
	lstarted = .F.
	l_margin = 0
	Name = "rtfreportlistener"
	nglobalpgcounter = 0
	npgcounter = 0
	oldpageno = 1
	orecord = .NULL.
	paper_letter = .F.
	pg_height = 0
	pg_width = 0
	rp_alias = 
	rtf_filename = ''
	r_margin = 0
	SendGDIPlusImage = 1
	targetfilename = 
	t_margin = 0
	waitfornextreport = .F.
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="waitfornextreport" display="WaitForNextReport"/>
		<memberdata name="npgcounter" display="nPgCounter"/>
		<memberdata name="nglobalpgcounter" display="nGlobalPgCounter"/>
		<memberdata name="orecord" display="oRecord"/>
		<memberdata name="arcolors" display="arColors"/>
		<memberdata name="targetfilename" display="TargetFileName"/>
		<memberdata name="dectoproc" display="DecToProc"/>
		<memberdata name="fontstyleconvert" display="FontStyleConvert"/>
		<memberdata name="frxtotwips" display="FrxToTwips"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE AfterReport
		** rtf document saving
		IF NOT This.WaitForNextReport 
			This.rtf_save()
		ENDIF 
		
		* CChalom
		* Reset the report page counter
		This.nPgCounter = 0
		
	ENDPROC

	PROCEDURE BeforeReport
		LOCAL lnSession, loFRX
		
		* Regular play with environment and frx data sessions
		LOCAL lnSession
		lnSession = SET("Datasession")
		WITH This
		*-- Switch to the FRX
			SET DATASESSION TO .FRXDataSession
			SET TALK OFF 
			.rp_alias = ALIAS()
		*-- Restore the datasession
			SET DATASESSION TO lnSession
			loFRX = .GetFrxRecord(1)
			.PageSetup(loFRX.Expr)
			.RTF_Create()
		ENDWITH
	ENDPROC

	PROCEDURE dectoproc
		LPARAMETERS lnDec
		RETURN ROUND(lnDec*65536, 0)
	ENDPROC

	PROCEDURE fontstyleconvert
		*-- Convert FontStyle from numeric value
		*-- to character codes
		LPARAMETERS tnFontStyle
		
		LOCAL lcStyle
		lcStyle = ''
		IF BITTEST(tnFontStyle, 0)
		   lcStyle = lcStyle + '\b'
		ENDIF
		IF BITTEST(tnFontStyle, 1)
		   lcStyle = lcStyle + '\i'
		ENDIF
		IF BITTEST(tnFontStyle, 2)
		   lcStyle = lcStyle + '\ulw'
		ENDIF
		IF BITTEST(tnFontStyle, 7)
		   lcStyle = lcStyle + '\strike'
		ENDIF
		IF EMPTY(lcStyle)
		   lcStyle = '\plain'
		ENDIF
		
		RETURN lcStyle
		
	ENDPROC

	PROCEDURE frxtotwips
		LPARAMETERS tnFrx
		*/  inches to  twip
		RETURN  INT(tnFrx / 960 * 1440)
	ENDPROC

	PROCEDURE getfrxrecord
		LPARAMETERS pnFRXRecNo
		* switching before data and report (frx) data sessions
		LOCAL lnSession, loFRX
		
		*-- Switch to the FRX
		lnSession = SET("Datasession")
		SET DATASESSION TO This.FRXDataSession
		SET TALK OFF 
		*-- Goto the record
		GOTO pnFRXRecNo
		
		*-- Get the data
		SCATTER MEMO NAME loFRX 
		
		*-- Restore the datasession
		SET DATASESSION TO lnSession
		
		*-- Return the data
		RETURN loFRX
		
	ENDPROC

	PROCEDURE gettype
		LPARAMETERS lnObjType
		* getting expressions types
		LOCAL lcType
		lcType = ''
		DO CASE
			CASE lnObjType = 5
				lcType = 'Label'
			CASE lnObjType = 6
				lcType = 'Line'
			CASE lnObjType = 7
				lcType = 'Box'
			CASE lnObjType = 8
				lcType = 'Field'
			CASE lnObjType = 17
				lcType = 'Picture'
		ENDCASE
		RETURN lcType
	ENDPROC

	PROCEDURE himetrictortf
		LPARAMETERS HiMetricValue
		* metric transformation 
		RETURN INT(HiMetricValue*240/635)
	ENDPROC

	PROCEDURE Init
		LPARAMETERS tcRTFFileName
		
		IF VARTYPE(tcRTFFileName) = "C" AND FILE(tcRTFFileName)
			DELETE FILE(tcRTFFileName)
		ENDIF
		
		This.TargetFileName = tcRTFFileName
		This.nPgCounter = 0
		
	ENDPROC

	PROCEDURE mabout
		* VFP reports to rtf converter
		* Class is based on report listener class.
		* It permits to see VFP reports in MS Word 
		* Authors: Vladimir Zhuravlev, Dmitriy Petrov, Valeriy Lifshits
		* with help of Vadim Pirozhkov and Andrey Petrov
		
		* Received improvements and fixes from Cesar Chalom
		* - Fixed the calculated fields
		* - Allowed general image fields to be printed
		* - Enabled colors and backcolors in texts, and colors and backcolors in shapes and lines
		* - Allowed generating a determined range of pages
		* - Allowed merging more tan one report together
		
		* Usage:
		
		* SET CLASSLIB TO  frx_rtf
		* LOCAL loRTFListener as ReportListener 
		* loRTFListener = CREATEOBJECT('RtfReportListener')
		* loRTFListener.TargetFileName = "MyRTFReport.RTF"
		* REPORT FORM MyReport OBJECT loRTFListener
		
		
		
		* CChalom comments
		* All changed codes in this class are preceeded with comments
		
		*!*	Removed methods, that are not used any more:
		*!*	1 - PutPageBreak()
		*!*	2 - DoBeforeRender
		*!* 3 - GetBandName
		*!* 4 - GetFormatCode
		*!* 5 - GetNextNumber
		*!* 6 - Pix2FRX
		*!* 7 - StrTransform
		*!*	8 - CalcAgrVal
		*!*	9 - CommaTran
		*!*	10 - CreateAgrProp
		*!*	11 - ExprChange
		*!*	12 - MEval
		*!*	13 - StrTransform
		*!*	14 - Thistran
		
		
		*!*	Removed properties
		*!*	This.cReportName
		
		
		*!*	New properties
		*!*	WaitForNextReport - logical determines if the listener object will keep
		*!*    the file handles opened in order to get the next report pages
		
		
		*!*	Renamed property:
		*!*	"RTF_filename" to "TargetFileName"
		*!*	in order to use the same property name from HTMLListener
		
		*!*	Method Init()
		*!*	Removed the need of all parameters
		*!*	Just one parameter is allowed, the destination RTF file name
		*!* This will fill the "TargetFileName" property
		
		
		
		*!* Original comments from Vladimir Zhuravlev - original usage has changed !
		* Not valid anymore
		
		*	SET CLASSLIB TO  frx_rtf
		*	loObjectList = CREATEOBJECT('rtfreportlistener', 'report1.frx', 'newrep.rtf', '', '')
		*	loObjectList.OutputType = 1
		*	REPORT FORM report1 OBJECT loObjectList PREVIEW noconsole
		* in CREATEOBJECT('rtfreportlistener', 'report1.frx', 'newrep.rtf', '', '')
		* first parameter is class name, second is report name to be converted, third parameters is
		* MS Word document name. To This document VFP report will be converted
		* Two optional parameters can be 'ThisForm','This' 
		* These for reports, where ThisForm or This are used in expresions 
		* Class does not cover General fields, if they were in report expresions
		
		
		
		
		* Comments for future implementation
		*!*	* Get color attributes
		*!*	IF VARTYPE(This.oRecord) = "O"
		*!*		SET STEP ON 
		
		*!*		LOCAL lnRed, lnGreen, lnBlue, lnColorIndex
		*!*		lnRed   = This.oRecord.PenRed
		*!*		lnGreen = This.oRecord.PenGreen
		*!*		lnBlue  = This.oRecord.PenBlue
		*!*		lnColorIndex = This.AddColor(lnRed, lnGreen, lnBlue)	
		*!*	ELSE
		*!*	ENDIF 
		
	ENDPROC

	PROCEDURE outtortf
		Lparameters lofrxrecord, nleft, ntop, nwidth, nheight, nobjectcontinuationtype, ccontentstoberendered, gdiplusimage
		
		Local lcType
		With loFrxRecord
		******** lcType 	- object name
		
			lcType = This.gettype(.objtype)
		
		*******
		* OUTPUT
		*******
		******************************************
			Local fontnum, font_id, _fontstyle, lcRTF, _allg, lcpensize
			lcRTF = ''
			Do Case
		*************************************************************************
		***  Field or label into textbox
		*************************************************************************
			Case lcType=="Field" .Or. lcType=="Label"
		
				LOCAL lcWrapText
				lcWrapText = ""
		
				IF lcType = "Field"
					.Expr = STRCONV(cContentsToBeRendered,6)
				ELSE 
					.Expr = CHRTRAN(loFRXRecord.Expr, ["], [])
		
					* Removing CHR(13) from texts 
					IF CHR(13) $ .Expr
						* .Expr=Strtran(.Expr, Chr(13), ' \par ')
						.Expr=Strtran(.Expr, Chr(13), ' \line ')
						nWidth = nWidth + 150
					ELSE 
						lcWrapText = '{\sp{\sn WrapText}{\sv 2}}'
					ENDIF
				ENDIF 
		
		************* Making allign
		*!*			If lcType == "Label"
		*!*				_allg = '\ql '
		*!*			Else
					If  Left(.Picture, 1) = '@'
						Do Case
						Case 'J'$.Picture
							_allg = '\qr '
						Case 'I'$.Picture
							_allg = '\qc '
						Otherwise
							_allg = '\ql '
						Endcase
					Else
						Do Case
						Case .offset = 0
							_allg = '\ql '
						Case .offset = 2
							_allg = '\qc '
						Case .offset = 1
							_allg = '\qr '
						Otherwise
							_allg = '\ql '
						Endcase
					Endif
		*!*			Endif
		
		* CChalom 2010-01-21
		* Included color tags for "Fields" and "Labels"
		********* Color attributes
				LOCAL lcColorRTF, lnClrIndex, lcColorTag, lcBackColorRTF, lnBackClrIndex
				lcColorTag = ""
		
		*!*			IF .Mode = 0 && Mode: 0 = Opaque background; 1 = Transparent
		*!*				IF .FillRed = -1 
		*!*					lcBackColorRTF = "\red255\green255\blue255"
		*!*				ELSE 
		*!*					lcBackColorRTF = "\red" + ALLTRIM(STR(.FillRed)) + ;
		*!*									"\green" + ALLTRIM(STR(.FillGreen)) + ;
		*!*									"\blue" + ALLTRIM(STR(.FillBlue))
		*!*				ENDIF 
		*!*				lnBackClrIndex = Ascan(This.arColors, lcBackColorRTF)
		*!*				IF lnBackClrIndex = 0
		*!*				ELSE
		*!*					lnBackClrIndex = ((lnBackClrIndex -1) / 4) + 1
		*!*					lcColorTag = lcColorTag + ;
		*!*						"\highlight" + ALLTRIM(STR(lnBackClrIndex))
		*!*				ENDIF 
		*!*			ENDIF 
		
		
			***
			* Draw a box as a background for the texts
		
				* Create a border color with the same color of the backcolor
				lcpensize = Alltrim(Str(9525*.pensize))
				LOCAL lcPenColor, lcFillColor
				IF .FillRed <> -1 && Not default
					lcPenColor = '{\sp{\sn lineColor}{\sv ' + TRANSFORM(RGB(.FillRed, .FillGreen, .FillBlue)) + '}}'
				ELSE 
					lcPenColor = ""
				ENDIF 
		
				IF .Mode = 0 AND .FillRed <> -1 && Mode: 0 = Opaque background; 1 = Transparent
					LOCAL lnRGB
					IF .FillRed = -1 
						lnRGB = RGB(255,255,255)
					ELSE 
						lnRGB = RGB(.FillRed, .FillGreen, .FillBlue)
					ENDIF 
					lcFillColor = '{\sp{\sn fillColor}{\sv ' + TRANSFORM(lnRGB) + '}}' + ;
						'{\sp{\sn fRecolorFillAsPicture}{\sv 0}}{\sp{\sn fFilled}{\sv 1}}'
				ELSE 
					lcFillColor = ""
				ENDIF 
		*---
		
				IF EMPTY(lcFillColor)
					lcRTF = ""
				ELSE 
					lcRTF = '{\shp{\*\shpinst' + ;
						'\shpleft' + Alltrim(Str(This.FrxToTwips(nleft)))+;
						'\shptop' + Alltrim(Str(This.FrxToTwips(ntop)))+;
						'\shpright' + Alltrim(Str(This.FrxToTwips(nleft + nwidth)))+;
						'\shpbottom' + Alltrim(Str(This.FrxToTwips(ntop + nheight)))+;
						'\shpfhdr0' + ;
						'\shpbxmargin' + ;
						'\shpbxignore' + ;
						'\shpbymargin' + ;
						'\shpbyignore' + ;
						'{\sp{\sn fline}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFilled}{\sv 0}}'+;
						'{\sp{\sn lineWidth}{\sv ' + lcpensize + '}}'+;
						lcFillColor + ;
						lcPenColor + ;
						'}}'
		
				ENDIF 
		
				IF .PenRed = -1 && Default Black
					lcColorRTF = "\red0\green0\blue0"
				ELSE 
					lcColorRTF = "\red" + ALLTRIM(STR(.penRed)) + "\green" + ALLTRIM(STR(.penGreen)) + "\blue" + ALLTRIM(STR(.penBlue))
				ENDIF 
		
				lnClrIndex = Ascan(This.arColors, lcColorRTF) &&, 1, 1, 1, 1)
				IF lnClrIndex = 0
					lnClrIndex = 1
				ELSE
					lnClrIndex = ((lnClrIndex -1) / 4) + 1
				ENDIF 
				lcColorTag = lcColorTag + "\cf" + ALLTRIM(STR(lnClrIndex)) + " "
		*---
		
		********* Font number
				fontnum = Ascan(This.arfont,Alltrim(.fontface),1)
				font_id = Iif(fontnum = 0, '0', Alltrim(Str(fontnum)))
		*********** FONT features
				_fontstyle = This.fontstyleconvert(.fontstyle)
					
				LOCAL lnBorder
				lnBorder = 8
					
		*!*			If  lcType == "Label"
		*!*				lcRTF = lcRTF + '{\shp{\*\shpinst'+;
		*!*					'\shpleft'+Alltrim(Str(This.FrxToTwips(nleft)))+;
		*!*					'\shptop'+Alltrim(Str(This.FrxToTwips(ntop)))+;
		*!*					'\shpright'+Alltrim(Str(This.FrxToTwips(nleft+nwidth+lnBorder)))+;
		*!*					'\shpbottom'+Alltrim(Str(This.FrxToTwips(ntop+nheight+lnBorder)))+;
		*!*					'\shpfhdr0'+;
		*!*					'{\sp{\sn fline}{\sv 0}}'+;
		*!*					'{\sp{\sn dxTextLeft}{\sv 0}}'+;
		*!*					'{\sp{\sn dyTextTop}{\sv 0}}'+;
		*!*					'{\sp{\sn dxTextRight}{\sv 0}}'+;
		*!*					'{\sp{\sn dyTextBottom}{\sv 0}}'+;
		*!*					'{\sp{\sn fFilled}{\sv 0}}'+;
		*!*					'{\sp{\sn fFitShapeToText}{\sv 1}}'+;
		*!*					'{\sp{\sn WrapText}{\sv 2}}'+;
		*!*					'{ \shptxt\pard' + _fontstyle + '\f' +m.font_id+ '\fs'+ Alltrim(Str(.FontSize*2)) +;
		*!*					_allg + lcColorTag + .Expr+ ' ' + '}}}'
		*!*			Else
					lcRTF = lcRTF + '{\shp{\*\shpinst'+;
						'\shpleft' + Alltrim(Str(This.FrxToTwips(nleft)))+;
						'\shptop' + Alltrim(Str(This.FrxToTwips(ntop)))+;
						'\shpright' + Alltrim(Str(This.FrxToTwips(nleft+nwidth+lnBorder)))+;
						'\shpbottom' + Alltrim(Str(This.FrxToTwips(ntop+nheight+lnBorder)))+;
						'\shpfhdr0' + ;
						'{\sp{\sn fline}{\sv 0}}'+;
						'{\sp{\sn dxTextLeft}{\sv 0}}'+;
						'{\sp{\sn dyTextTop}{\sv 0}}'+;
						'{\sp{\sn dxTextRight}{\sv 0}}'+;
						'{\sp{\sn dyTextBottom}{\sv 0}}'+;
						'{\sp{\sn fFilled}{\sv 0}}'+;
						'{\sp{\sn fFitShapeToText}{\sv 1}}'+;
						lcWrapText + ;
						'{ \shptxt\pard' + _fontstyle + '\f' + m.font_id + '\fs' + Alltrim(Str(.FontSize*2))+;
						_allg + lcColorTag + .Expr + ' '+'}}}'
		*!*			Endif
		
		***********************************************************
		* Line
		***************************************************************
		
			Case lcType == "Line"
				lcpensize = Alltrim(Str(9525*.pensize))
		
		* CChalom 2010-01-21
		* Included color tags for "Lines"
				LOCAL lcPenColor, lcFillColor
				IF .PenRed <> -1 && Not default
					lcPenColor = '{\sp{\sn lineColor}{\sv ' + TRANSFORM(RGB(.PenRed, .PenGreen, .PenBlue)) + '}}'
				ELSE 
					lcPenColor = ""
				ENDIF 
		*---
				If .offset = 1 && horizontal
					lcRTF = '{\shp{\*\shpinst'+;
						'\shpleft' + Alltrim(Str(This.FrxToTwips(nleft)))+;
						'\shptop' + Alltrim(Str(This.FrxToTwips(ntop)))+;
						'\shpright' + Alltrim(Str(This.FrxToTwips(nleft+nwidth)))+;
						'\shpbottom' + Alltrim(Str(This.FrxToTwips(ntop)))+;
						'\shpfhdr0'+;
						'{\sp{\sn fline}{\sv 1}}' + '{\sp{\sn ShapeType}{\sv 20}}'+;
						'{\sp{\sn lineWidth}{\sv ' + lcpensize + '}}'+;
						lcPenColor + ;
						'}}'
				ELSE && Vertical
					lcRTF = '{\shp{\*\shpinst' + ;
						'\shpleft' + Alltrim(Str(This.FrxToTwips(nleft+nwidth)))+;
						'\shptop' + Alltrim(Str(This.FrxToTwips(ntop)))+;
						'\shpright' + Alltrim(Str(This.FrxToTwips(nleft+nwidth)))+;
						'\shpbottom' + Alltrim(Str(This.FrxToTwips(ntop+nheight)))+;
						'\shpfhdr0' + ;
						'{\sp{\sn fline}{\sv 1}}' + '{\sp{\sn ShapeType}{\sv 20}}'+;
						'{\sp{\sn lineWidth}{\sv ' + lcpensize + '}}'+;
						lcPenColor + ;
						'}}'
				Endif
		
		
		
		
		* Shape
			Case lcType = "Box"
				lcpensize = Alltrim(Str(9525*.pensize))
		
		* CChalom 2010-01-21
		* Included color tags for "Shapes"
				LOCAL lcPenColor, lcFillColor
				IF .PenRed <> -1 && Not default
					lcPenColor = '{\sp{\sn lineColor}{\sv ' + TRANSFORM(RGB(.PenRed, .PenGreen, .PenBlue)) + '}}'
				ELSE 
					lcPenColor = ""
				ENDIF 
		
		
				IF .FillPat = 1 AND .Mode = 0 && AND .FillRed <> -1 && Mode: 0 = Opaque background; 1 = Transparent
					LOCAL lnRGB
					IF .FillRed = -1 
						lnRGB = RGB(255,255,255)
					ELSE 
						lnRGB = RGB(.FillRed, .FillGreen, .FillBlue)
					ENDIF 
					lcFillColor = '{\sp{\sn fillColor}{\sv ' + TRANSFORM(lnRGB) + '}}' + ;
						'{\sp{\sn fRecolorFillAsPicture}{\sv 0}}{\sp{\sn fFilled}{\sv 1}}'
				ELSE 
					lcFillColor = ""
				ENDIF 
		*---
		
				lcRTF = '{\shp{\*\shpinst' + ;
					'\shpleft' + Alltrim(Str(This.FrxToTwips(nleft)))+;
					'\shptop' + Alltrim(Str(This.FrxToTwips(ntop)))+;
					'\shpright' + Alltrim(Str(This.FrxToTwips(nleft + nwidth)))+;
					'\shpbottom' + Alltrim(Str(This.FrxToTwips(ntop + nheight)))+;
					'\shpfhdr0' + ;
					'\shpbxmargin' + ;
					'\shpbxignore' + ;
					'\shpbymargin' + ;
					'\shpbyignore' + ;
					'{\sp{\sn fline}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFilled}{\sv 0}}'+;
					'{\sp{\sn lineWidth}{\sv ' + lcpensize + '}}'+;
					lcFillColor + ;
					lcPenColor + ;
					'}}'
		
			Case lcType = "Picture"
		
				LOCAL hdPict, strFile, lnFileSize, lhFile, objPict,;
					lnPictWidth, lnPictHeight, lnWidth, lnHeight, llLock, lncropr, lncropb
		
		
				* CChalom 2010-01-17
				* Dealing with images in General fields
				* Saving the image to the disk in a Temp file
				* Using _Gdiplus.vcx that is already embedded in ReportOutput.App
				LOCAL lcTempImgFile
		
				IF GDIPlusImage!=0 && General field
					lcTempImgFile = GetEnv("TEMP") + "\" + Sys(2015) + ".Png"
					LOCAL loImage AS GpImage OF (HOME() + _ReportOutput)
		*			loImage = NEWOBJECT("GpImage", "_GdiPlus.vcx", _ReportOutput) && "ReportOutput.App")
					loImage = NEWOBJECT("GpImage", "_GdiPlus.vcx")
		
					loImage.SetHandle(GDIPlusImage)
					loImage.SaveToFile(lcTempImgFile,"image/jpeg")
					loImage = NULL
					* Replace the original empty file
					cContentsTobeRendered = lcTempImgFile
				ENDIF 
				*---
					
		*****************Picture size
					lcExt = JUSTEXT(cContentsTobeRendered)
		
		* CChalom 2010-02-19
		* Changed the way to get the image dimensions and load its binaries
		
		*!*			objPict = LoadPicture(cContentsTobeRendered)
		*!*		   	lnPictWidth =  This.HiMetricToRTF(objpict.width)
		*!*		   	lnPictHeight = This.HiMetricToRTF(objpict.height)
		*!*		   	release objpict
		
		*!*		  	hdPict = FOPEN(cContentsTobeRendered)
		*!*		  	IF hdPict > -1
		*!*				lnFileSize = FSEEK(hdPict,0,2)
		*!*				IF lnFileSize > 0
		*!*					= FSEEK(hdPict, 0,0)
		*!*					strFile = FREAD(hdPict, lnFileSize)
		*!*					= FCLOSE(hdPict)
		
				LOCAL lnWidth, lnHeight
				LOCAL loVFPImg as Image
				loVFPImg = CREATEOBJECT("Image")
				loVFPImg.Picture = cContentsTobeRendered
				lnWidth = loVFPImg.Width * 7276 / 275
				lnHeight = loVFPImg.Height * 7276 / 275
				loVFPImg = NULL
				lnPictWidth = This.HiMetricToRTF(lnWidth)
				lnPictHeight = This.HiMetricToRTF(lnHeight)
		
					IF FILE(cContentsTobeRendered)
						strFile = FILETOSTR(cContentsTobeRendered)
		
						lhFile = STRCONV(strFile, 15)
						DO CASE
						CASE .General = 0		&& Clip
							llLock = 1
							lnWidth = MIN(nWidth, lnPictWidth)
							lnHeight = MIN(nHeight, lnPictHeight)
							lncropr = This.DecToProc(MAX(lnPictWidth - nWidth, 0)/lnPictWidth)
							lncropb = This.DecToProc(MAX(lnPictHeight - nHeight, 0)/lnPictHeight)
						CASE .General = 1	&& Isometric
							llLock = 1
		
							* Isometric Adjustment
							LOCAL lnHorFactor, lnVertFactor, lnResizeFactor
							m.lnHorFactor = m.nWidth / m.lnPictWidth
							m.lnVertFactor = m.nHeight / m.lnPictHeight
							m.lnResizeFactor = MIN(m.lnHorFactor, m.lnVertFactor)
							m.lnWidth = m.lnPictWidth * m.lnResizeFactor
							m.lnHeight = m.lnPictHeight * m.lnResizeFactor
		
		*!*						lnWidth = MIN(nWidth, lnPictWidth)
		*!*						lnHeight = MIN(nHeight, lnPictHeight)
							lncropb = 0
							lncropr = 0
						CASE .General = 2	&& Stretch
							llLock = 0
							lnWidth = nWidth
							lnHeight = nHeight
							lncropb = 0
							lncropr = 0
						ENDCASE
							
						lcRTF = '{\shp{\*\shpinst' + ;
							'\shpleft'+Alltrim(Str(This.FrxToTwips(nleft)))+;
							'\shptop'+Alltrim(Str(This.FrxToTwips(ntop)))+;
							'\shpright'+Alltrim(Str(This.FrxToTwips(nleft+lnWidth)))+;
							'\shpbottom'+Alltrim(Str(This.FrxToTwips(ntop+lnHeight)))+;
							'{\sp{\sn ShapeType}{\sv 75}}'+;
							'{\sp{\sn fline}{\sv 0}}'+;
							'{\sp{\sn fLockAspectRatio}{\sv '+STR(llLock,1)+'}}'+;
							'{\sp{\sn cropFromBottom}{\sv '+ALLTRIM(STR(lncropb))+'}}'+;
							'{\sp{\sn cropFromRight} {\sv '+ALLTRIM(STR(lncropr))+'}}'+;
							'{\sp{\sn pib}' + ;
							'{\sv ' + ;
							'{\pict' + ;
							'\wmetafile8\pic' + lcExt + '\picbpp4' + CHR(13)+;
							lhFile +'}'+;
							'}' + ;
							'}' +  ;
							'{\sp{\sn pibFlags}{\sv 2}}' + ;
							'{\sp{\sn fUseShapeAnchor}{\sv 0}}' + ;
							'}}'
		*!*				ENDIF
				ENDIF
		
				IF NOT EMPTY(lcTempImgFile)
					DELETE FILE(lcTempImgFile)
				ENDIF 
		
			OTHERWISE 
				SET STEP ON 
		
			Endcase
		***************
		ENDWITH
		IF !EMPTY(lcRTF)
			= Fputs(This.handle, lcRTF)
		ENDIF
		
	ENDPROC

	PROCEDURE pagesetup
		LPARAMETERS tcExpr
		* tcExpr - EXPR first record in FRX
		Local lnOrientation, lnPapersize
		*Take page orientation and size EXPR
		lnOrientation = Val(Right((Subst(tcExpr, At("ORIENTATION", tcExpr, 1), 13)), 1))
		lnPapersize=Val(Right((Subst(tcExpr,At("PAPERSIZE", tcExpr,1), 11)), 1))
		* book
		
		WITH This
			.paper_letter = lnOrientation != 0
			Do Case
			Case lnPapersize = 9 OR lnPapersize = 1 && A4
				If .paper_letter
					.pg_width = .twips(29.7)
					.pg_height = .twips(21)
				Else
					.pg_width = .twips(21)
					.pg_height = .twips(29.7)
				Endif
			Otherwise
			Endcase
			.t_margin = 0
			.b_margin = 0
			.l_margin = 0
			.r_margin = 0
		ENDWITH
	ENDPROC

	PROCEDURE Render
		LPARAMETERS nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage
		
		* CChalom 2010-01-25
		* If the report page is not between the page ranges asked, just skip
		LOCAL lnRangeTo, tlNewPage
		tlNewPage = .F.
		IF This.PageNo > This.nGlobalPgCounter OR This.nPgCounter = 0
			This.nPgCounter = This.nPgCounter + 1
			This.nGlobalPgCounter = This.nGlobalPgCounter + 1
			tlNewPage = .T.
		ENDIF
		lnRangeTo = This.CommandClauses.RangeTo
		IF lnRangeTo <> -1 AND NOT BETWEEN(This.nPgCounter, This.CommandClauses.RangeFrom, lnRangeTo)
			IF tlNewPage
				This.OldPageNo = This.PageNo &&_PageNo 
			ENDIF 
			NODEFAULT 
			RETURN 
		ENDIF 
		
		* Moved the page change to the render method
		If This.OldPageNo != This.PageNo &&_PageNo 
			This.OldPageNo = This.PageNo &&_PageNo 
			IF This.lStarted && add a new page only if the report has already started
				= Fputs(This.handle,'\page')
			ENDIF 
		Endif
		
		
		* From PDFx by Luis Navas
		* Code to detect if report will run twice because of use of _PAGETOTAL
		If This.TwoPassProcess And This.CurrentPass=0 Then
		*	DoDefault(nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage)
			NODEFAULT 
			RETURN 
		EndIf
		
		This.lStarted = .T.
		
		
		
		*---
		
		
		This.loFRXRecord = This.Getfrxrecord(nFRXRecno)
		
		* Here is calling to rtf output
		This.OutToRTF(This.loFRXRecord, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage)
		
		* CChalom 2010-01-17
		* No need to call the default render event, because we'll passing everything to RTF
			NODEFAULT 
		*	DODEFAULT(nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage)
		*---
	ENDPROC

	PROCEDURE rtf_create
		WITH This
		
		* Creating rtf file 
		IF NOT EMPTY(.handle)
			RETURN
		ENDIF 
		
		LOCAL lnSession, i
		lnSession = SET("Datasession")
		SET DATASESSION TO .FRXDataSession
		SET TALK OFF
		
		* Getting all fonts sizes
		SELECT ALLTRIM(Padr(Mline(fontface,1),30));
			FROM (.rp_alias);
			INTO ARRAY .arFont;
			WHERE NOT EMPTY(fontface);
			GROUP By 1 
		
		* CChalom 2010-01-23
		* Creating the Color table
		LOCAL lnSelect
		lnSelect = SELECT()
		
		SELECT ;
			distinct ("\red" + ALLTRIM(STR(penRed)) + "\green" + ALLTRIM(STR(penGreen)) + "\blue" + ALLTRIM(STR(penBlue))) as RTF, ;
				PenRed, PenGreen, PenBlue ;
			FROM (.rp_alias);
			WHERE INLIST(ObjType, 5, 8) ;
				AND NOT INLIST(-1, PenRed, PenGreen, PenBlue) ;
		UNION ;
		SELECT;
			DISTINCT ("\red" + ALLTRIM(STR(FillRed)) + "\green" + ALLTRIM(STR(FillGreen)) + "\blue" + ALLTRIM(STR(FillBlue))) as RTF, ;
				FillRed AS PenRed, FillGreen AS PenGreen, FillBlue AS PenBlue ;
			FROM (.rp_alias);
			WHERE INLIST(ObjType, 5, 8) ;
				AND NOT INLIST(-1, FillRed, FillGreen, FillBlue) ;
			INTO CURSOR TempColors ;
			READWRITE 
		
		* Check if we have the two basic colors, white and black
		INSERT INTO TempColors VALUES ("\red0\green0\blue0", 0, 0, 0)
		INSERT INTO TempColors VALUES ("\red255\green255\blue255", 255, 255, 255)
		
		
		* Urrutia 2010-02-05
		* initialize the array property in case all colors are Default
		If _Tally > 0
			SELECT Distinct RTF, penRed, penGreen, penBlue ;
				FROM TempColors Into Array .ArColors
		ELSE 
			.ArColors(1,1)="\red0\green0\blue0"
			.ArColors(1,2)=0
			.ArColors(1,3)=0
			.ArColors(1,4)=0
		Endif
		*---
		
		USE IN TempColors
		SELECT (lnSelect)
		
		
		*-- Restore the datasession
		SET DATASESSION TO lnSession
		
		
		********** Making Color table
		* {\colortbl;\red0\green0\blue0;\red255\green0\blue0;}
		LOCAL lcColorTable
		lcColorTable = '{\colortbl;'
		FOR i = 1 TO (ALEN(.arColors) / 4)
			lcColorTable = lcColorTable + ALLTRIM(.arColors(i, 1)) + ";"
		NEXT i
		lcColorTable = lcColorTable + "}"
		*---
		
		********** Making font RTF features
		LOCAL lcFontTable, lnFcs
		lcFontTable = ""
		lcFontTable = '{\fonttbl{'
		FOR i = 1 TO ALEN(.arFont)
			lnFcs = FONTMETRIC(17, .arfont[i], 10)
			lcFontTable = lcFontTable+'\f' + Alltrim(Str(i,2,0)) + '\fnil\fcharset' + Alltrim(Str(lnFcs)) + ' ' + Alltrim(.arfont[i])+';'
		NEXT i
		lcFontTable = SUBSTR(lcFontTable, 1, LEN(lcFontTable)-1) + '}}'
		
		
		.handle = FCREATE(.TargetFileName)
		IF .handle <= 0
			= MESSAGEBOX('Error creates' + .TargetFileName, "Error")
			RETURN
		ENDIF
		
		LOCAL lcPaper, lcOutStr
		* Storing paper information
		lcPaper = '\paperw' + Alltrim(Str(.pg_width))+;
				'\paperh' + Alltrim(Str(.pg_height))+;
				'\margl' + Alltrim(Str(.l_margin))+;
				'\margr' + Alltrim(Str(.r_margin))+;
				'\margt' + Alltrim(Str(.t_margin))+;
				'\margb' + Alltrim(Str(.b_margin))+;
				IIF(.paper_letter, '\landscape', '')
		
		lcOutStr = "{\rtf1\ansi\ansicpg" + Alltrim(Str(.code_page)) + ;
			'\uc1 \deff0\deflang1049\deflangfe1049' +;
			lcFontTable + lcPaper + lcColorTable
		= FPUTS(.handle, lcOutStr)
		
		ENDWITH
	ENDPROC

	PROCEDURE rtf_save
		= FPUTS(This.handle, '}')
		= FCLOSE(This.handle)
	ENDPROC

	PROCEDURE twips
		 LParameters nCm_
		* making Twip
		  Return Int(nCm_ * 1440 / 2.54)
		
	ENDPROC

ENDDEFINE
