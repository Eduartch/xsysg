*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="pr_excellistener.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS excellistener AS updatelistener OF "_reportlistener.vcx" 
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "frxpreview.h"
	*<DefinedPropArrayMethod>
		*m: applyexcelstyle
		*m: calcbandnumbers
		*m: calcbasefilename
		*m: calcnextfilename
		*m: islonghorizontalline
		*m: isnumber
		*m: isshorthorizontalline
		*m: xextractexcelcol
		*m: xml_cell
		*m: xml_encode
		*m: xml_file_header
		*m: xml_name
		*m: xml_names_footer
		*m: xml_names_header
		*m: xml_numberformat
		*m: xml_row_footer
		*m: xml_row_header
		*m: xml_style
		*m: xml_stylenumber
		*m: xml_styles_footer
		*m: xml_styles_header
		*m: xml_table_footer
		*m: xml_table_header
		*m: xml_type
		*m: xml_workbook_footer
		*m: xml_workbook_header
		*m: xml_worksheet_footer
		*m: xml_worksheet_header
		*p: applyexcelstyleprogram
		*p: cexcelstyle
		*p: closeondeactivate
		*p: coutputalias
		*p: coutputdbf
		*p: cworkbookfile
		*p: cworksheetname
		*p: loutputtocursor
		*p: nlastpercent
		*p: waitfornextreport
	*</DefinedPropArrayMethod>

	applyexcelstyleprogram = 
	cexcelstyle = 
	closeondeactivate = .T.
	coutputalias = 
	coutputdbf = 
	cworkbookfile = 
	cworksheetname = 
	FRXDataSession = -1
	loutputtocursor = .T.
	Name = "excellistener"
	nlastpercent = 0
	waitfornextreport = .F.
	_memberdata = <VFPData>
		<memberdata name="waitfornextreport" display="WaitForNextReport"/>
		</VFPData>
	
	PROCEDURE AfterReport
		* Setup
			This.setFRXDataSession()
			SET SAFETY OFF	&& FrxDataSession has safety on
			SET DELETED ON
		
		* Add field to Frx with RECNO()
			SELECT Frx
			ALTER TABLE Frx ADD COLUMN nRecno N(5)
			REPLACE ALL nRecno WITH RECNO()
			INDEX ON nRecno TAG nRECNO
		
		* Add fields from Frx and other fields to (this.cOutputAlias)
		* 21/06/08 Add <ExcelInsertFormula>, <ExcelNamedCell> and <ExcelNamedRange> options
		*	SELECT 00000 AS ExcelRow,000 AS ExcelCol, ;
				   UPPER(PADR(Expr,100)) AS cExpr,PADR(User,3) AS cUser,PADR(UPPER(Contents),100) AS cContents, ;
				   OA.*, ;
				   00000 AS nExcelColRequest,00000 AS nExcelSpecialColRequest,00000 AS nExcelMergeAcross, ;
				   00000.00 AS nExcelColWidth,SPACE(50) AS cExcelAlignment, ;
				   SPACE(100) AS cExcelBorder,SPACE(100) AS cExcelInterior, ;
				   0 AS nUnderlinedColCount, ;
				   .F. AS lDelete, ;
				   Frx.* ;
			  FROM (this.cOutputAlias) OA ;
			  JOIN Frx ON OA.nFrxRecno = Frx.nRecno ;
			  INTO CURSOR (this.cOutputAlias) READWRITE
		
			SELECT 00000 AS ExcelRow,000 AS ExcelCol, ;
				   UPPER(PADR(Expr,100)) AS cExpr,PADR(User,3) AS cUser,PADR(UPPER(Contents),100) AS cContents, ;
				   OA.*, ;
				   00000 AS nExcelColRequest,00000 AS nExcelSpecialColRequest,00000 AS nExcelMergeAcross, ;
				   00000.00 AS nExcelColWidth,SPACE(50) AS cExcelAlignment, ;
				   SPACE(100) AS cExcelBorder,SPACE(100) AS cExcelInterior, ;
				   SPACE(100) AS cExcelInsertFormula,SPACE(100) AS cExcelNamedRange,SPACE(100) AS cExcelNamedCell, ;
				   0 AS nUnderlinedColCount, ;
				   .F. AS lDelete, ;
				   Frx.* ;
			  FROM (this.cOutputAlias) OA ;
			  JOIN Frx ON OA.nFrxRecno = Frx.nRecno ;
			  INTO CURSOR (this.cOutputAlias) READWRITE
			INDEX ON nFrxRecno TAG nFrxRecno
			INDEX ON ObjType TAG ObjType ADDITIVE
			INDEX ON ExcelRow TAG ExcelRow ADDITIVE
			INDEX ON ExcelCol TAG ExcelCol ADDITIVE
			INDEX ON nPageNo TAG nPageNo ADDITIVE
		
			INDEX ON cExpr TAG cExpr ADDITIVE
			INDEX ON cUser TAG cUser ADDITIVE
		
			INDEX ON TRANSFORM(ExcelRow,'@L 999999') + TRANSFORM(ExcelCol,'@L 999999') TAG RowCol ADDITIVE
			INDEX ON TRANSFORM(nPageNo,'@L 999999') + TRANSFORM(ExcelRow,'@L 999999') + TRANSFORM(ExcelCol,'@L 999999') ;
				 TAG PagRowCol ADDITIVE
		
		* Eliminate items in bands 0,1,2 if nPage > 1
			DELETE ALL FOR cUser < '  3' AND nPageNo > 1
		
		* Determine row height and col width in report (not Excel)
			PRIVATE pnRowHeight,pnColWidth
			pnRowHeight  = 120		&& Should be calculated
			SELECT nWidth,COUNT(nWidth) ;
			  FROM (This.cOutputAlias) ;
			 WHERE ObjType = 8 ;
			 GROUP BY 1 ;
			 ORDER BY 2 DESC ;
			  INTO CURSOR Widths
			pnColWidth = IIF(_TALLY > 0,nWidth,400)
			USE
			SELECT (this.cOutputAlias)
		
		* Codify report colors as <ExcelInterior>Solid,xxxxxx</ExcelInterior> and store in cExcelInterior
		* 01/01/07 Correction by Andrus Moor, since color columns in frx file can have value -1
		*	REPLACE ALL cExcelInterior WITH 'Solid,';
											+ RIGHT(TRANSFORM(RGB(FillRed,FillGreen,FillBlue),'@0'),6) + ',' ;
											+ RIGHT(TRANSFORM(RGB(PenRed,PenGreen,PenBlue),'@0'),6) ;
					FOR FillRed # 255 OR FillGreen # 255 OR FillBlue # 255 ;
						OR PenRed # 0 OR PenGreen # 0 OR PenBlue # 0
			REPLACE ALL cExcelInterior WITH 'Solid,';
									    	+ RIGHT(TRANSFORM(RGB(FillRed,FillGreen,FillBlue),'@0'),6) + ',' ;
											+ RIGHT(TRANSFORM(RGB(PenRed,PenGreen,PenBlue),'@0'),6) ;
					FOR ( FillRed # 255 OR FillGreen # 255 OR FillBlue # 255 ;
						 OR PenRed # 0 OR PenGreen # 0 OR PenBlue # 0 ) ;
						AND FillRed # -1 AND FillGreen # -1 AND FillBlue #-1 ;
					    AND PenRed # -1 AND PenGreen # -1 AND PenBlue # -1
											
		* Codify Offset as Horizontal Alignment for fields
			REPLACE ALL cExcelAlignment WITH IIF(Offset=0,'Horizontal,Left',IIF(Offset=1,'Horizontal,Right','Horizontal,Center')) ;
					FOR ObjType = 8
			REPLACE ALL cExcelAlignment WITH IIF(EMPTY(Picture),'Horizontal,Left',IIF(Picture=["@J"],'Horizontal,Right', ;
												 IIF(Picture=["@I"],'Horizontal,Center','Horizontal,Left'))) ;
					FOR ObjType = 5
		
		* Run ExcelStyle routine (1 - Before extracting comments)
			This.ApplyExcelStyle(This.cExcelStyle,1)
		
		* Developer can indicate properties by placing values in Comment field in this format: <ExcelCol>18</ExcelCol>
		* To get numeric 1 or 0 must write it as 1. or 0., otherwise Fox interprets as .T. / .F.
			* <ExcelCol>18</ExcelCol>				- Indicates ExcelCol for this and other items with same Left
			* <ExcelSpecialCol>18</ExcelSpecialCol> - Indicates ExcelCol for one item only
			* <ExcelNamedRange>Cajas_Per1;=Sheet1!R10C7</ExcelNamedRange> - Indicates NameOfRange,Range, as defined by Excel
			* <ExcelInsertFormula>=+(RC[-4]+RC[-3]) / Cajas_Per2</ExcelInsertFormula> - Indicates formula to insert
			LOCAL lcComment
			SCAN FOR !EMPTY(Comment)
				lcComment = ''
				TRY
					lcComment  = '<data> <datos>' + Comment + '</datos> </data>'
					lcComment  = XMLTOCURSOR(lcComment)
				CATCH
				ENDTRY
				SELECT (this.cOutputAlias)
				TRY
					REPLACE nExcelColRequest WITH XMLResult.ExcelCol
				CATCH
				ENDTRY
				TRY
					REPLACE nExcelSpecialColRequest WITH XMLResult.ExcelSpecialCol
				CATCH
				ENDTRY
				TRY
					IF (VARTYPE(XMLResult.ExcelDelete) = 'C' AND UPPER(XMLResult.ExcelDelete) = '.T.') ;
					   OR XMLResult.ExcelDelete
		
						DELETE
					ENDIF
				CATCH
				ENDTRY
		
				TRY
					REPLACE nExcelColWidth WITH XMLResult.ExcelColWidth
				CATCH
				ENDTRY
				TRY
					REPLACE cExcelAlignment WITH XMLResult.ExcelAlignment
				CATCH
				ENDTRY
				TRY
					REPLACE cExcelAlignment WITH XMLResult.ExcelAlign
				CATCH
				ENDTRY
				TRY
					REPLACE nExcelMergeAcross WITH XMLResult.ExcelMergeAcross
				CATCH
				ENDTRY
				TRY
					REPLACE cExcelBorder WITH XMLResult.ExcelBorder
				CATCH
				ENDTRY
				TRY
					REPLACE cExcelInterior WITH XMLResult.ExcelInterior
				CATCH
				ENDTRY
				TRY
					REPLACE nExcelUnderlinedColCount WITH XMLResult.ExcelUnderlinedColCount
				CATCH
				ENDTRY
		* 21/06/08 Add ExcelInsertFormula, ExcelNamedCell and ExcelNamedRange options
		* cExcelInsertFormula
				TRY
					REPLACE cExcelInsertFormula WITH XMLResult.ExcelInsertFormula
				CATCH
				ENDTRY
				TRY
					REPLACE cExcelNamedRange WITH XMLResult.ExcelNamedRange
				CATCH
				ENDTRY
				TRY
					REPLACE cExcelNamedCell WITH XMLResult.ExcelNamedCell
				CATCH
				ENDTRY
				TRY
					USE IN XMLResult
				CATCH
				ENDTRY
			ENDSCAN
		
		* Run ExcelStyle routine (2 - Before assigning row)
			This.ApplyExcelStyle(This.cExcelStyle,2)
		
		* Calc rows ExcelRow
			* User contains band number
			SELECT DISTINCT nPageNo,nTop,LEFT(User,3) AS User,0000000 AS ExcelRow ;
			  FROM (this.cOutputAlias) ;
			  INTO CURSOR PageTop READWRITE
			INDEX ON TRANSFORM(nPageNo,'@L 999999') + TRANSFORM(nTop,'@L 999999') TAG PagTop
			LOCAL lnLastTop,lnLastRow,lnLastPageNo
			lnLastTop	 = 0
			lnLastRow    = 1
			lnLastPageNo = 1
			SCAN
				* Page header is ignored after page 1
				IF nPageNo > 1 && # lnLastPageNo
					IF VAL(User) < 3
						LOOP
					ELSE
						* If new page adjust last top
						lnLastPageNo = nPageNo
						lnLastTop    = nTop - pnRowHeight
					ENDIF
				ENDIF
				* There may be empty rows above this one
				DO WHILE nTop > lnLastTop + pnRowHeight
					lnLastTop = lnLastTop + pnRowHeight
					lnLastRow = lnLastRow + 1
				ENDDO
				* nTop may be so close that is is considered same row
				IF nTop < lnLastTop + .5 * pnRowHeight
					* No change in lnLastTop
				ELSE
					lnLastRow = lnLastRow + 1
				ENDIF
				lnLastTop = nTop
				REPLACE ExcelRow WITH lnLastRow
				* WAIT WINDOW NOWAIT 'Calculando renglones...'
			ENDSCAN
			SELECT (This.cOutputAlias)
			SET RELATION TO TRANSFORM(nPageNo,'@L 999999') + TRANSFORM(nTop,'@L 999999') INTO PageTop
			REPLACE ALL ExcelRow WITH PageTop.ExcelRow
		
		* Run ExcelStyle routine (3 - Before assigning col)
			This.ApplyExcelStyle(This.cExcelStyle,3)
		
		* Calc cols
			LOCAL lnLastLeft,lnLastCol,llAssignedCol,lnExcelCol
		
			* cParseOrder indicates parsing order for two cells with same nLeft
			* Parse from report top
		*					TRANSFORM(100-nExcelColRequest-nExcelSpecialColRequest,'@L 999') AS cParseOrder ;
		
			SELECT DISTINCT nLeft,0000000 AS ExcelCol,nExcelColRequest,nExcelSpecialColRequest, ;
							'9' AS cParseOrder ;
			  FROM (This.cOutputAlias) ;
			  INTO CURSOR Lefts READWRITE
			REPLACE ALL cParseOrder WITH '2' ;
					FOR nExcelColRequest > 0
			REPLACE ALL cParseOrder WITH '1' ;
					FOR nExcelSpecialColRequest > 0
		
			INDEX ON TRANSFORM(nLeft,'@L 999999') + cParseOrder TAG LefOrd
			lnLastLeft = 0
			lnLastCol  = 0
			LOCAL laCount[1]
			SCAN
				IF nLeft = lnLastLeft
		*			DELETE
		*			LOOP
				ENDIF
				* WAIT WINDOW NOWAIT 'Calculando columnas...'
				lnThisLeft	  = nLeft
				llAssignedCol = .F.
				lnExcelCol	  = 0
				* Lefts.nExcelSpecialColRequest is col request for this item only
				IF Lefts.nExcelSpecialColRequest > 0
					* Make sure that requested cell is not occupied
					lnExcelCol = Lefts.nExcelSpecialColRequest
					SELECT COUNT(*) ;
					  FROM (this.cOutputAlias) A ;
					  JOIN (this.cOutputAlias) B  ON A.ExcelRow = B.ExcelRow ;
					 WHERE A.ExcelCol = lnExcelCol ;
					 	   AND B.ExcelCol = 0 ;
					 	   AND B.nLeft = lnThisLeft ;
					 	   AND B.nExcelSpecialColRequest = lnExcelCol ;
					  INTO ARRAY laCount
					IF laCount > 0
						* There was a clash.  Don't assign.
					ELSE
						* Accept request
						REPLACE ExcelCol WITH lnExcelCol
						REPLACE ALL ExcelCol WITH lnExcelCol ;
								FOR nLeft = lnThisLeft ;
									AND nExcelSpecialColRequest = lnExcelCol ;
								 IN (this.cOutputAlias)
						LOOP
					ENDIF
				ENDIF
		
				IF Lefts.nExcelColRequest > 0
					* Make sure that cell is not occupied
					lnExcelCol = Lefts.nExcelColRequest
					SELECT COUNT(*) ;
					  FROM (this.cOutputAlias) A ;
					  JOIN (this.cOutputAlias) B  ON A.ExcelRow = B.ExcelRow ;
					 WHERE A.ExcelCol = lnExcelCol ;
					 	   AND B.nLeft = lnThisLeft ;
					  INTO ARRAY laCount
					IF laCount > 0
						* There was a clash.  Don't assign.
					ELSE
						* Accept request
						lnLastCol  = MAX(lnExcelCol,lnLastCol)
						lnLastLeft = nLeft
						REPLACE ExcelCol WITH lnExcelCol
						REPLACE ALL ExcelCol WITH lnExcelCol ;
								FOR nLeft = lnThisLeft ;
									AND EMPTY(ExcelCol) ;
								 IN (this.cOutputAlias)
						LOOP
					ENDIF
				ENDIF
		
				* Haven't assigned Excel column yet, so do it here
				* If Left is very close it may be considered same col, except if it causes overlap
				IF nLeft < lnLastLeft + .75 * pnColWidth AND lnLastCol # 0
					* Make sure it doesn't cause two fields in same cell
					SELECT COUNT(*) ;
					  FROM (this.cOutputAlias) A ;
					  JOIN (this.cOutputAlias) B  ON A.ExcelRow = B.ExcelRow ;
					 WHERE A.ExcelCol = lnLastCol ;
					 	   AND B.nLeft = lnThisLeft ;
					 	   AND EMPTY(B.ExcelCol) ;
					  INTO ARRAY laCount
					IF laCount > 0
						lnLastCol  = lnLastCol + 1
						lnLastLeft = nLeft
					ELSE
						* No change either in lnLastCol or lnLastLeft
					ENDIF
				ELSE
					lnLastCol  = lnLastCol + 1
					lnLastLeft = nLeft
				ENDIF
				REPLACE ExcelCol WITH lnLastCol
				REPLACE ALL ExcelCol WITH lnLastCol ;
						FOR nLeft	= lnThisLeft ;
							AND EMPTY(ExcelCol) ;
						 IN (this.cOutputAlias)
			ENDSCAN
		
		* Calc how many columns exist
			LOCAL ja[1]
			SELECT MAX(ExcelCol) ;
			  FROM (this.cOutputAlias) ;
			  INTO ARRAY ja
			PRIVATE pnMaxCol
			pnMaxCol = ja
		
		* Extract ExcelColWidths requested
			PRIVATE paColData
			DIMENSION paColData[1,2]
			lnColData = 0
			SELECT (this.cOutputAlias)
			SCAN FOR !EMPTY(nExcelColWidth)
				IF ASCAN(paColData,ExcelCol,1,ALEN(paColData,1),1,8) > 0
					LOOP
				ENDIF
				lnColData = lnColData + 1
				DIMENSION paColData[lnColData,3]
				paColData[lnColData,1] = ExcelCol
				paColData[lnColData,2] = .F.			&& AutoFitWidth
				paColData[lnColData,3] = nExcelColWidth
			ENDSCAN
		
		* Run ExcelStyle routine (4 - After assigning row and column)
			* WAIT WINDOW NOWAIT 'Revisando formato...'
			This.ApplyExcelStyle(This.cExcelStyle,4)
		
		* Open Excel
			* WAIT WINDOW NOWAIT 'Abriendo Excel...'
			LOCAL loExcel AS Excel.Application
			loExcel = Createobject('Excel.Application')
			loExcel.WindowState = -4137  && xlMaximized
			This.cWorkbookFile = ALLTRIM(This.cWorkbookFile)
		*	luWorkbook		= FORCEPATH(This.CalcBaseFileName(This.cWorkbookFile),FULLPATH(CURDIR()))
			luWorkbook		= FORCEPATH(This.CalcBaseFileName(This.cWorkbookFile), ;
										IIF(EMPTY(JUSTPATH(This.cWorkbookFile)),FULLPATH(CURDIR()),FULLPATH(JUSTPATH(This.cWorkbookFile))))
			lcWorkSheetName = IIF(EMPTY(This.cWorksheetName),'Sheet1',This.cWorksheetName)
			lcOpciones = ''
		
			* Erase previous file if not ADDITIVE
			llEraseOK = .T.
			IF NOT EMPTY(luWorkbook) AND NOT 'ADDITIVE' $ lcOpciones AND FILE(luWorkbook)
				* Erase inside TRY/CATCH because it may be in use
				TRY
					ERASE (luWorkbook)
				CATCH
					* Couldn't erase file, so leave a workbook open without saving
					* WAIT WINDOW NOWAIT 'No pude borrar copia anterior de ' + luWorkbook
					llEraseOK = .F.
				ENDTRY
			ENDIF
			IF !llEraseOK
		*		luWorkbook = FULLPATH(CURDIR()) + 'REP_' + RIGHT(SYS(3),4) + '.xls'
				luWorkbook = FORCEPATH(This.CalcNextFileName(luWorkbook),FULLPATH(CURDIR()))
				IF NOT EMPTY(luWorkbook) AND NOT 'ADDITIVE' $ lcOpciones AND FILE(luWorkbook)
					* Erase inside TRY/CATCH because it may be in use
					TRY
						ERASE (luWorkbook)
					CATCH
						* Couldn't erase file, so leave a workbook open without saving
						* WAIT WINDOW NOWAIT 'No pude borrar copia anterior de ' + luWorkbook
						llEraseOK = .F.
					ENDTRY
				ENDIF
			ENDIF
		
		* Place data in Excel by writing file in XML format
			DIMENSION paStyles[1,10]		&& Array to save styles
			* Column1  = Key
			* Column2  = FontFace
			* Column3  = FontSize
			* Column4  = FontStyle
			* Column5  = DataType
			* Column6  = NumberFormat
			* Column7  = HorizontalAlignment
			* Column8  = Borders
			* Column9  = Colors
			* Key = PADR(FontFace,20)+TRAN(FontSize,'99') + PADR(DataType,10) + PADR(NumberFormat,20)
			SELECT FontFace,FontSize,FontStyle ;
			  FROM Frx ;	&& (this.cOutputAlias) does not contain ObjType = 1 AND ObjCode = 53
			 WHERE Platform = 'WINDOWS ' ;
				   AND ObjType = 1 AND ObjCode = 53 ;
			  INTO ARRAY ja
			paStyles[1,2]  = IIF(EMPTY(ja[1]),'Lucida Console',ja[1])
			paStyles[1,3]  = IIF(EMPTY(ja[2]),10,MIN(ja[2] + 3,10))	&& 3 points larger that in report up to 10
			paStyles[1,4]  = ja[3]
			paStyles[1,5]  = ''
			paStyles[1,6]  = ''
			paStyles[1,7]  = '' && Alignment
			paStyles[1,8]  = ''	&& Border
			paStyles[1,9]  = ''	&& Colors
			paStyles[1,1]  = UPPER(PADR(paStyles[1,2],20)+TRAN(paStyles[1,3],'99')+TRAN(paStyles[1,4],'99') ;
							+ PADR(paStyles[1,5],10) + PADR(paStyles[1,6],20)) + PADR(paStyles[1,7],30) ;
							+ PADR(paStyles[1,8],50) + PADR(paStyles[1,9],50)
		
			* Create styles array and XML for table items
			LOCAL lcXmlTable,lcCRLF,lnLastRow
			lcXmlTable = This.xml_Table_Header()
			lcCRLF	   = CHR(13)+CHR(10)
			lnLastRow  = 0
			SELECT (This.cOutputAlias)
			SET ORDER TO RowCol
			SCAN
				* WAIT WINDOW NOWAIT 'Preparando para guardar... (' + TRANSFORM(ExcelRow) + ',' + TRANSFORM(ExcelCol) + ')'
				* If ExcelRow = 0 element belongs to page header of later page
				IF ExcelRow = 0
					LOOP
				ENDIF
				* If new row, close last row (if open) and open new.
				IF lnLastRow # ExcelRow
					IF lnLastRow # 0
						lcXmlTable = lcXmlTable + This.Xml_Row_Footer()
					ENDIF
					lnLastRow = ExcelRow
					lcXmlTable = lcXmlTable + This.Xml_Row_Header()
				ENDIF
				lnStyleNumber = This.Xml_StyleNumber(Contents)
				lcXmlTable	  = lcXmlTable + This.Xml_Cell(Contents,lnStyleNumber)
			ENDSCAN
			lcXmlTable = lcXmlTable + This.Xml_Row_Footer()
			lcXmlTable = lcXmlTable + This.xml_Table_Footer()
		
			LOCAL lcXML
			lcXML = This.Xml_File_Header()
			lcXML = lcXML + This.Xml_Workbook_Header()
		
			lcXML = lcXML + This.Xml_Styles_Header()
			FOR i = 21 TO 20 + ALEN(paStyles,1)
				lcXML = lcXML + This.Xml_Style(i)
			ENDFOR
			lcXML = lcXML + This.Xml_Styles_Footer()
		
		* 21/06/08 Adding NamedRange(s)
		*<ExcelNamedRange>Cajas_Per2,=Sheet1!R10C13</ExcelNamedRange>
			DIMENSION paNames[1]		&& Array to save NamedRanges
			paNames = ''
			SELECT DISTINCT cExcelNamedRange ;
			  FROM (this.cOutputAlias) ;
			 WHERE !EMPTY(cExcelNamedRange) ;
			  INTO ARRAY paNames
			IF !EMPTY(paNames)
				lcXML = lcXML + This.Xml_Names_Header()
				FOR i = 1 TO ALEN(paNames,1)
					lcXML = lcXML + This.Xml_Name(i)
				ENDFOR
				lcXML = lcXML + This.Xml_Names_Footer()
			ENDIF
		
		
			lcXML = lcXML + This.Xml_Worksheet_Header(lcWorkSheetName)
			lcXML = lcXML + lcXmlTable
			lcXML = lcXML + This.Xml_Worksheet_Footer()
		
			lcXML = lcXML + This.Xml_Workbook_Footer()
		
			* Save sheet and open in Excel
			lcXMLWorkbook = GETENV("TEMP") + '\Temp_' + SYS(2015) + '.XML'
		*	STRTOFILE(lcXml,luWorkbook)
		*	STRTOFILE(lcXml,lcXMLWorkbook)
		
			STRTOFILE(lcXml, This.cWorkbookFile)
		
		
		*!*	* With this call VFP remains as active window. Thanks to Borislav Borissov.
		*!*	*DECLARE INTEGER SetForegroundWindow IN WIN32API INTEGER
		*!*	*SetForegroundWindow(_screen.HWnd)
		*!*		TRY
		*!*			loXMLWorkbook = loExcel.Workbooks.Open(lcXMLWorkbook )
		*!*			* Save in Excel format (not XML)
		*!*	#DEFINE xlWorkbookNormal  -4143
		*!*			loXMLWorkbook.SaveAs(luWorkbook,xlWorkbookNormal)
		*!*			ERASE (lcXMLWorkbook)
		*!*		CATCH
		*!*		ENDTRY
		*!*		loExcel.Visible = .T.
		
		THIS.setCurrentDataSession()
		
		DODEFAULT()
	ENDPROC

	PROCEDURE applyexcelstyle
		LPARAMETERS tcExcelStyle,tnOption
		SELECT (this.cOutputAlias)
		IF !EMPTY(tcExcelStyle)
			&tcExcelStyle.(tnOption,This)
		ENDIF
		RETURN
		
		*!*	**** Moved to an outside procedure ****
		
		*!*	* My Default ExcelStyle
		*!*	*  0 = Title 
		*!*	*  1 = Page header
		*!*	*  2 = Column header
		*!*	*  3 = Group header
		*!*	*  4 = Detail
		*!*	*  5 = Group footer
		*!*	*  6 = Column footer
		*!*	*  7 = Page footer
		*!*	*  8 = Summary
		
		*!*	tcOutputAlias = This.cOutputAlias
		*!*	DO CASE
		*!*		CASE tnOption = 1	&& Before extracting comments
		
		*!*		CASE tnOption = 2	&& Before assigning row
		*!*			DELETE ALL FOR (cUser = '  0' OR cUser = '  1') ;
		*!*							AND ('FECHA DE IMPRESION:' $ cExpr OR 'FECHA DE IMPRESIÓN:' $ cExpr ;
		*!*								 OR 'PAGINA:' $ cExpr OR 'PÁGINA:' $ cExpr ;
		*!*								 OR cExpr = 'DATE()' OR cExpr = 'DATETIME()' OR cExpr = 'TIME()' OR cExpr = '_PAGENO')
		*!*	*		DELETE ALL FOR (cUser = '  0' OR cUser = '  1') ;
		*!*							AND ('PAGINA:' $ cExpr OR 'PÁGINA:' $ cExpr OR cExpr = '_PAGENO')
		*!*	*		DELETE ALL FOR (cUser = '  0' OR cUser = '  1') ;
		*!*							AND ('FECHA DE IMPRESION:' $ cExpr OR 'FECHA DE IMPRESIÓN:' $ cExpr ;
		*!*								 OR cExpr = 'DATE()' OR cExpr = 'TIME()') ;
		*!*							AND nPageNo > 1
		
		*!*		CASE tnOption = 3	&& Before assigning col
		
		*!*		CASE tnOption = 4	&& After assigning row and column
		*!*			* Cursores con las filas y columnas
		*!*			SELECT DISTINCT ExcelRow,LEFT(User,3) AS User ;
		*!*			  FROM (tcOutputAlias) ;
		*!*			  INTO ARRAY laRowUser
		*!*			CREATE CURSOR ExcelCols (ExcelCol N(3))
		*!*			FOR i = 1 TO pnMaxCol
		*!*				INSERT INTO ExcelCols (ExcelCol) VALUES(i)
		*!*			ENDFOR
		
		*!*			* Lista de celdas con ----- or =====
		*!*			SELECT ExcelRow,ExcelCol,Contents,User,nExcelUnderlinedColCount ;
		*!*			  FROM (tcOutputAlias) ;
		*!*			 WHERE LEFT(cContents,5) = '=====' OR LEFT(cContents,5) = '-----' ;
		*!*			  INTO CURSOR DashedCells READWRITE
		
		*!*			* Borramos celdas con ----- or =====
		*!*			DELETE &tcOutputAlias ;
		*!*			  FROM DashedCells ;
		*!*			 WHERE &tcOutputAlias..ExcelRow = DashedCells.ExcelRow AND &tcOutputAlias..ExcelCol = DashedCells.ExcelCol
		
		*!*			* Cells to underline (one line above ----- or =====)
		*!*			SELECT ExcelRow - 1 AS ExcelRow,ExcelCol,Contents,User,nExcelUnderlinedColCount,.F. AS lNueva ;
		*!*			  FROM DashedCells ;
		*!*			  INTO CURSOR UnderlinedCells READWRITE
		*!*			* Add line extensions
		*!*			SCAN FOR INT(LEN(ALLTRIM(Contents)) / 8) > 1 AND !lNueva
		*!*				lnRecno	   = RECNO()
		*!*				lnExcelRow = ExcelRow
		*!*				lcContents = LEFT(Contents,5)
		*!*				FOR i = 1 TO MIN(INT(LEN(ALLTRIM(Contents)) / 8),MAX(1,nExcelUnderlinedColCount))
		*!*					lnExcelCol = UnderlinedCells.ExcelCol + i
		*!*					IF lnExcelCol > pnMaxCol
		*!*						EXIT
		*!*					ENDIF
		*!*	*!*					SELECT (tcOutputAlias)
		*!*	*!*					LOCATE FOR ExcelRow = lnExcelRow AND ExcelCol = lnExcelCol
		*!*	*!*					IF EOF()
		*!*	*!*						SELECT UnderlinedCells
		*!*	*!*						LOCATE FOR ExcelRow = lnExcelRow AND ExcelCol = lnExcelCol
		*!*	*!*						IF EOF()
		*!*	*!*							j = ASCAN(laRowUser,lnExcelRow,1,ALEN(laRowUser,1),1,8)
		*!*	*!*							lcUser = IIF(j > 0,laRowUser[j,2],User)
		*!*	*!*							INSERT INTO UnderlinedCells (ExcelRow,ExcelCol,Contents,User) VALUES (lnExcelRow,lnExcelCol,lcContents,lcUser)
		*!*	*!*							GOTO (lnRecno) IN UnderlinedCells
		*!*	*!*						ENDIF
		*!*	*!*					ENDIF
		*!*					LOCATE FOR ExcelRow = lnExcelRow AND ExcelCol = lnExcelCol
		*!*					IF EOF()
		*!*						j = ASCAN(laRowUser,lnExcelRow,1,ALEN(laRowUser,1),1,8)
		*!*						lcUser = IIF(j > 0,laRowUser[j,2],User)
		*!*						INSERT INTO UnderlinedCells (ExcelRow,ExcelCol,Contents,User,lNueva) VALUES (lnExcelRow,lnExcelCol,lcContents,lcUser,.T.)
		*!*					ENDIF
		*!*					GOTO (lnRecno) IN UnderlinedCells
		*!*				ENDFOR
		*!*			ENDSCAN
		*!*			
		*!*			* Add missing cells that need to be underlined
		*!*			SELECT U.* ;
		*!*			  FROM UnderlinedCells U ;
		*!*			 WHERE NOT EXISTS (SELECT OA.ExcelRow,OA.ExcelCol ;
		*!*			 					 FROM (tcOutputAlias) OA ;
		*!*			 					WHERE OA.ExcelRow = U.ExcelRow ;
		*!*			 						  AND OA.ExcelCol = U.ExcelCol) ;
		*!*			  INTO CURSOR MissingCells
		*!*			SELECT (tcOutputAlias)
		*!*			APPEND FROM DBF('MissingCells') FIELDS ExcelRow,ExcelCol,User
		*!*			SET ORDER TO RowCol
		
		*!*			* Perform underline
		*!*			SELECT UnderlinedCells
		*!*			SET RELATION TO TRANSFORM(ExcelRow,'@L 999999') + TRANSFORM(ExcelCol,'@L 999999') INTO (tcOutputAlias)
		*!*			REPLACE ALL &tcOutputAlias..cExcelBorder WITH 'Bottom,' ;
		*!*						+ IIF(LEFT(ALLTRIM(Contents),5)='=====','Double,3','')
		*!*			SET RELATION TO
		
		*!*			* Eliminate dashed Excel rows that became empty (move up following cells)
		*!*			SELECT (tcOutputAlias)
		*!*			SET ORDER TO
		*!*			SELECT DISTINCT ExcelRow + 0000000 AS ExcelRow ;
		*!*			  FROM DashedCells ;
		*!*			 WHERE ExcelRow NOT IN (SELECT ExcelRow ;
		*!*			 						  FROM (tcOutputAlias)) ;
		*!*			 GROUP BY 1 ;
		*!*			 ORDER BY 1 ;
		*!*			  INTO CURSOR RenglonesParaEliminar READWRITE
		*!*			APPEND BLANK
		*!*			REPLACE ExcelRow WITH 9999999
		*!*			GO TOP
		*!*			lnFirstRow = 0
		*!*			SCAN
		*!*				SELECT (tcOutputAlias)
		*!*				REPLACE ALL ExcelRow WITH ExcelRow - RECNO('RenglonesParaEliminar') + 1 ;
		*!*						FOR BETWEEN(ExcelRow,lnFirstRow,RenglonesParaEliminar.ExcelRow)
		*!*				lnFirstRow = RenglonesParaEliminar.ExcelRow
		*!*			ENDSCAN
		
		*!*			* If nExcelMergeAcross >=99 merges to rightmost column
		*!*			SELECT (tcOutputAlias)
		*!*			REPLACE ALL nExcelMergeAcross WITH pnMaxCol - ExcelCol ;
		*!*					FOR nExcelMergeAcross >=99
		
		*!*			* Font
		*!*			REPLACE ALL FontFace WITH 'Arial', ;
		*!*						FontSize WITH MAX(FontSize,10)		&& Minimum font is 10
		*!*			REPLACE ALL FontSize WITH 16 ;
		*!*					FOR (cUser = '  0' OR cUser = '  1') ;
		*!*						AND ObjType = 8 ;
		*!*						AND 'SIS.CNOMBRE' $ cExpr
		*!*			REPLACE ALL FontStyle WITH 1 ;
		*!*					FOR cUser <= '  2' ;
		*!*						AND (ObjType = 5 OR ObjType = 8)
		*!*			REPLACE ALL FontStyle WITH 1 + 2 ;
		*!*					FOR cUser = '  3' ;
		*!*						AND (ObjType = 5 OR ObjType = 8)
		
		*!*			* Group Footer
		*!*			* Creamos celdas vacias que faltan
		*!*			LOCAL laRowsGroupFooter[1]
		*!*			laRowsGroupFooter = 0
		*!*			lcCols = 0
		*!*			SELECT DISTINCT ExcelRow ;
		*!*			  FROM (tcOutputAlias) ;
		*!*			 WHERE cUser = '  5' ;
		*!*			  INTO ARRAY laRowsGroupFooter
		*!*			FOR i = 1 TO ALEN(laRowsGroupFooter,1)
		*!*				IF EMPTY(laRowsGroupFooter[i])
		*!*					LOOP
		*!*				ENDIF
		*!*				lnRow = laRowsGroupFooter[i]
		*!*				FOR lnCol = 1 TO pnMaxCol
		*!*					LOCATE FOR ExcelRow = lnRow AND ExcelCol = lnCol
		*!*					IF EOF()
		*!*						APPEND BLANK
		*!*						REPLACE ExcelRow WITH lnRow, ;
		*!*								ExcelCol WITH lnCol, ;
		*!*								User	 WITH '  5', ;
		*!*								cUser	 WITH '  5'
		*!*					ENDIF
		*!*				ENDFOR
		*!*			ENDFOR
		*!*	 		
		*!*			* Decoramos GroupFooter ( User = '  5')
		*!*			* Font y background
		*!*			REPLACE ALL FontStyle WITH 1 ;
		*!*					FOR cUser = '  5' ;
		*!*						AND (ObjType = 5 OR ObjType = 8)
		*!*			REPLACE ALL cExcelInterior WITH 'Solid,';
		*!*											+ RIGHT(TRANSFORM(RGB(192,192,192),'@0'),6) + ',' ;
		*!*											+ RIGHT(TRANSFORM(RGB(0,0,0),'@0'),6) ;
		*!*					FOR cUser = '  5'
		
		*!*			* Bordes arriba y abajo
		*!*			LOCAL laGroupFooters[1,2]
		*!*			laGroupFooters[1,1] = 0
		*!*			laGroupFooters[1,2] = ''
		*!*			SELECT DISTINCT ExcelRow,SPACE(8) AS cExcelBorder ;
		*!*			  FROM (tcOutputAlias) ;
		*!*			 WHERE cUser = '  5' ;
		*!*			  INTO ARRAY laGroupFooters
		*!*			lnLastRow	  = 0
		*!*			FOR i = 1 TO ALEN(laGroupFooters,1)
		*!*				IF EMPTY(laGroupFooters[i,1])
		*!*					LOOP
		*!*				ENDIF
		*!*				DO CASE
		*!*					CASE lnLastRow = 0
		*!*						laGroupFooters[i,2] = 'Top,Single,1'
		*!*					CASE laGroupFooters[i,1] = lnLastRow + 1
		*!*						laGroupFooters[i,2] = 'Top,Single,1'
		*!*					OTHERWISE	&& laGroupFooters[i,1] > lnLastRow + 1
		*!*						laGroupFooters[i-1,2] = laGroupFooters[i-1,2] ;
		*!*											   + IIF(EMPTY(laGroupFooters[i-1,2]),'',';') ;
		*!*											   + 'Bottom,Double,3'
		*!*						laGroupFooters[i,2]   = 'Top,Single,1'
		*!*				ENDCASE			
		*!*				lnLastRow = laGroupFooters[i,1]
		*!*			ENDFOR
		*!*			laGroupFooters[ALEN(laGroupFooters,1),2] = laGroupFooters[ALEN(laGroupFooters,1),2] ;
		*!*								   + IIF(EMPTY(laGroupFooters[ALEN(laGroupFooters,1),2]),'',';') ;
		*!*								   + 'Bottom,Double,3'
		*!*			
		*!*			lnRecno		  = 0
		*!*			SCAN FOR User = '  5'
		*!*				i = ASCAN(laGroupFooters,ExcelRow,1,ALEN(laGroupFooters,1),1,8)
		*!*				IF i = 0
		*!*					LOOP
		*!*				ENDIF
		*!*				REPLACE cExcelBorder WITH laGroupFooters[i,2]
		*!*				lnRecno = RECNO()
		*!*			ENDSCAN
		*!*	ENDCASE
	ENDPROC

	PROCEDURE BeforeReport
		* Code is inspired by Dorin Valiseacu's CursorListener
		DODEFAULT()
		
		IF this.lOutputToCursor
			IF  EMPTY(this.cOutputDBF)
				this.cOutputDBF = ADDBS(SYS(2023)) + SYS(2015) + '.dbf'
			ENDIF  
		
			IF EMPTY(this.cOutputAlias)
				this.cOutputAlias = STRTRAN(JUSTSTEM(this.cOutputDBF), ' ', '_')
			ENDIF
		
			This.setFRXDataSession()
		
			* Store in Frx.User the number of the band to which each field belongs
			This.CalcBandNumbers()
		
			* Don't reprint group header on each page (not working yet)
			REPLACE ALL NoRepeat WITH .F. ;
					FOR objType = 9 AND (ObjCode = 3 OR ObjCode = 5)
			GO TOP
		
			CREATE CURSOR (this.cOutputAlias) (nFrxRecno N(4,0),nLeft I, nTop I, nWidth I, nHeight I, ;
											   Contents M NOCPTRANS,nPageNo I)
											   
			INDEX ON nFrxRecno TAG nFrxRecno
		
		ENDIF 
		THIS.setCurrentDataSession()
		
		
	ENDPROC

	PROCEDURE calcbandnumbers
		* This routine places in frx.User the number of the report band to which each element belongs
		*  When OBJTYPE = 9 (a band), the following values are used:
		*  0 = Title 
		*  1 = Page header
		*  2 = Column header
		*  3 = Group header
		*  4 = Detail
		*  5 = Group footer
		*  6 = Column footer
		*  7 = Page footer
		*  8 = Summary
		
		* NOTES:
		* Frx.VPos contains the vertical position of the report elements AS THEY APPEAR IN REPORT DESIGNER
		* In order to determine the band to which report elements belong we need to know the top of each band IN REPORT DESIGNER
		* Frx.Height contains the height of report bands, but we must calculate VPos for each band.
		* "Report Bands" refer to report designer areas that contain fields and labels.  They are numbered as above.
		* "Title Bands" refer to report designer areas that contain titles such as Detail, Page Header
		
		* Procedure:
		* Store VPos of "title bands" in array.
		* Store in User field the number of the report band to which each report element belongs
		
		
			LOCAL laBands[1],lnVpos,i,lnSelect
			* These constants come from VFP program convert.prg
			m.g_pixelsize  = 96       && logical pixels per inch
			m.g_bandheight = ((19/m.g_pixelsize) * 10000)
			m.g_bandfudge  =  4350
			* Metrics for various objects, report bands, etc.
			#DEFINE c_radhght      1.308
			#DEFINE c_chkhght      1.308
			#DEFINE c_listht       1.000
			#DEFINE c_adjfld       0.125
			#DEFINE c_adjlist      0.125
			#DEFINE c_adjtbtn      0.769
			#DEFINE c_adjrbtn      0.308
			#DEFINE c_vchkbox      0.154
			#DEFINE c_vradbtn      0.154
			#DEFINE c_vlist        0.500
			#DEFINE c_hpopup       1.000
			#DEFINE c_adjbox       0.500
			#DEFINE c_chkpixel        12
		
			laBands = 0
			SELECT RECNO(),ObjCode,000000.000,Height ;
			  FROM Frx ;
			 WHERE Platform = 'WINDOWS' ;
			 	   AND ObjType = 9 ;
			  INTO ARRAY laBands
			lnVPosBottom = - m.g_bandheight && - (m.g_bandfudge/m.g_pixelsize)
		 	FOR i = 1 TO ALEN(laBands,1)
				lnVPosBottom = lnVPosBottom + laBands[i,4] + m.g_bandheight + (m.g_bandfudge/m.g_pixelsize)
				laBands[i,3] = lnVPosBottom
			ENDFOR
		
			* Make cursor readwrite
			SELECT * ;
			  FROM Frx ;
			  INTO CURSOR Frx1 READWRITE
			USE IN Frx
			SELECT * ;
			  FROM Frx1 ;
			  INTO CURSOR Frx READWRITE
			USE IN Frx1
			
			SCAN FOR Platform = 'WINDOWS' AND (ObjType = 5 OR ObjType = 8)
			 	FOR i = 1 TO ALEN(laBands,1)
			 		IF VPos < laBands[i,3]
			 			* Store in User the number of the band to which report element belongs
			 			REPLACE User WITH TRANSFORM(laBands[i,2],'999')
			 			EXIT
			 		ENDIF
				ENDFOR
			ENDSCAN
		
	ENDPROC

	PROCEDURE calcbasefilename
		LPARAMETERS tcWorkbook
		LOCAL i,lcFileName
		IF EMPTY(tcWorkbook)
			* Calc default name
			FOR i = 1 TO 9
				IF !FILE(FORCEEXT('REP_'+TRANSFORM(i,'@L 99'),'xls'))
					lcFileName = FORCEEXT('REP_'+TRANSFORM(i,'@L 99'),'xls')
					EXIT
				ENDIF
			ENDFOR
			IF EMPTY(lcFileName)
				LOCAL laDir[1,3]
				ADIR(laDir,'REP_??.'+tcExtension)
				FOR i = 1 TO ALEN(laDir,1)
					laDir[i,3] = DTOS(laDir[i,3])
				ENDFOR
				ASORT(laDir,3)
				lcFileName = FORCEEXT(PADR(laDir[1,1],50),'xls')
			ENDIF
		ELSE
			lcFileName = FORCEEXT(JUSTFNAME(tcWorkbook),'xls')
		ENDIF
		RETURN lcFileName
		
	ENDPROC

	PROCEDURE calcnextfilename
		LPARAMETERS tcWorkbook
		LOCAL lcBaseName,lcFileName,i
		lcBaseName = JUSTSTEM(tcWorkbook)
		IF AT(lcBaseName,'_',2) > 0
			lcBaseName = LEFT(lcBaseName,AT(lcBaseName,'_',2) - 1)
		ENDIF
		lcFileName = ''
		FOR i = 1 TO 9
			IF !FILE(lcBaseName + '_' + TRANSFORM(i,'@L 99') + '.xls')
				lcFileName = lcBaseName + '_' + TRANSFORM(i,'@L 99') + '.xls'
				EXIT
			ENDIF
		ENDFOR
		IF EMPTY(lcFileName)
			LOCAL laDir[1,3]
			ADIR(laDir,lcBaseName + '_??' + '.XLS')
			FOR i = 1 TO ALEN(laDir,1)
				laDir[i,3] = DTOS(laDir[i,3])
			ENDFOR
			ASORT(laDir,3)
			lcFileName = FORCEEXT(laDir[1,1],'xls')
		ENDIF
		RETURN lcFileName
		
	ENDPROC

	PROCEDURE createtherm
		*modified to use Carlos Alloatti progress bar (Dorin's code)
		*
		IF ISNULL(THIS.ThermForm)
		
		  DECLARE INTEGER GetSysColor IN Win32API INTEGER  
		
		  LOCAL liThermTop, liThermLeft, liThermWidth, liThermHeight, liSession
		  IF TYPE("THIS.CommandClauses.StartDataSession") = "N"
		     liSession = SET("DATASESSION")
		     TRY
		        SET DATASESSION TO (THIS.CommandClauses.StartDataSession)
		     CATCH WHEN .T.
		        THIS.resetDataSession()
		     ENDTRY
		  ENDIF
		
		  THIS.ThermForm = CREATEOBJECT("FORM")
		  
		  
		  WITH THIS.ThermForm
		     .ScaleMode = SCALEMODE_PIXELS   
		     .Height = THIS.ThermFormHeight
		     .HalfHeightCaption = .T.
		     .Width = THIS.ThermFormWidth
		     .AutoCenter = .T.
		     .BorderStyle = BORDER_DOUBLE  && fixed dialog
		     .ControlBox = .F.
		     .Closable = (NOT THIS.IsRunning)
		     .MaxButton = .F.
		     .MinButton = .F.
		     .Movable = (NOT THIS.IsRunning)
		     .AlwaysOnTop = .T.
		     .AllowOutput = .F.
		     .AddObject("Therm","ctl32_progressbar")
		     .AddObject("ThermLabel","ctl32_progressbarlabel")
		     .ThermLabel.Visible = .T.
		     .ThermLabel.FontBold = .T.
		     .ThermLabel.Top = 4
		     .ThermLabel.Width = .Width - (THIS.ThermMargin*2)
		     .ThermLabel.Alignment = 2
		     liThermHeight = .Height - (THIS.ThermMargin* 2) - .ThermLabel.Height
		     liThermWidth =  .Width - (THIS.ThermMargin*2)
		  ENDWITH
		  
		  THIS.SetThermFormCaption()    
		  
		  liThermTop = THIS.ThermMargin + 20
		  liThermLeft = THIS.ThermMargin  
		
		  WITH THIS.ThermForm.Therm
		     .Top = liThermTop     
		     .Left = liThermLeft
		     .Height = liThermHeight
		     .Width = liThermWidth
		     .Visible = .T.
		     .Caption = OUTPUTCLASS_RUNSTATUS_LOC 
		  ENDWITH
		  
		  IF NOT EMPTY(liSession)
		     SET DATASESSION TO (liSession)
		  ENDIF
		  
		 
		ENDIF
		
		RETURN NOT ISNULL(THIS.ThermForm)
	ENDPROC

	PROCEDURE Destroy
		* 02/10/06 Alex. This code was in Dorin's cursorListener.
		* It is not necessary because we keep directory table in FrxDatasession which doesn't exist.
		*this.resetDataSession()
		*IF USED(this.cOutputAlias)
		*	USE IN (this.cOutputAlias)
		*ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE DoStatus
		LPARAMETERS cMessage
		
		RETURN
		
		
		* This code comes from, Dorin's to use Carlos Alloati's therm
		LOCAL loParentForm, lcCaption, lcParentFormName
		NODEFAULT
		IF (NOT (THIS.QuietMode or ;
			(THIS.IsRunning AND THIS.CommandClauses.NoDialog)))
		
			IF this.nlastpercent <> CEILING(this.percentDone*100)
				this.nlastpercent = CEILING(this.percentDone*100)
			ELSE
				RETURN 
			ENDIF
			
			IF EMPTY(cMessage) OR ISNULL(cMessage)
				cMessage = ""
			ENDIF
		
			lcCaption = EVALUATE(THIS.ThermCaption)
			IF ((NOT ISNULL(THIS.ThermForm)) OR (THIS.CreateTherm()) )
		
				WITH THIS.ThermForm
		
					IF THIS.IsRunning
						.Closable = .F.
						.Movable = .F.
					ENDIF
		
					.Therm.Value = CEILING(THIS.PercentDone * 100)
					.ThermLabel.Caption = lcCaption
		
					IF NOT .Visible
		
						loParentForm = THIS.GetParentWindowRef()
		
						DO CASE
							CASE VARTYPE(loParentForm) # "O" AND (NOT _SCREEN.Visible)
								lcParentFormName = "MACDESKTOP"
							CASE VARTYPE(loParentForm) # "O"
								lcParentFormName = "SCREEN"
							CASE (NOT loParentForm.Visible) AND ;
								(loParentForm.DeskTop OR NOT EMPTY(loParentForm.MacDesktop) OR ;
								loParentForm.ShowWindow = 2 OR (NOT _SCREEN.Visible))
								* in many cases,
								* they've probably made a programming error,
								* the parent should be visible according to
								* the requirements of REPORT FORM ... IN WINDOW
								* if it's a WINDOW clause they
								* have no need to show it, might not be an error
								* Either way, they should see the therm
								* to know that the report is progressing
								lcParentFormName = "MACDESKTOP"
							CASE (NOT loParentForm.Visible)
								* same comment as above
								lcParentFormName = "SCREEN"
							OTHERWISE
								lcParentFormName = loParentForm.Name
						ENDCASE
		
						SHOW WINDOW (.Name) IN WINDOW (lcParentFormName)
						.AlwaysOnTop = .T.
						.AutoCenter = .T.
						.Visible = .T.
		
					ENDIF
		
				ENDWITH
		
			ENDIF
		
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE Init
		declare integer GetDeviceCaps in WIN32API integer HDC, integer item
		declare integer GetDC         in WIN32API integer hWnd
		declare integer ReleaseDC     in WIN32API integer hWnd, integer HDC
		DECLARE INTEGER GetWindowDC	  IN WIN32API INTEGER hwnd
		
		DODEFAULT()
		
		* Developer can indicate properties by placing values in Comment field in this format: <ExcelCol>18</ExcelCol>
		* To get numeric 1 or 0 must write it as 1. or 0., otherwise Fox interprets as .T. / .F.
			* <ExcelCol>18</ExcelCol>				- Indicates ExcelCol for this and other items with same Left
			* <ExcelSpecialCol>18</ExcelSpecialCol> - Indicates ExcelCol for one item only
			* <ExcelNamedRange>Cajas_Per1;=Sheet1!R10C7</ExcelNamedRange> - Indicates NameOfRange,Range, as defined by Excel
			* <ExcelInsertFormula>=+(RC[-4]+RC[-3]) / Cajas_Per2</ExcelInsertFormula> - Indicates formula to insert
		
		*!* ExcelBorders format: <ExcelBorders>Top,Single,1;Bottom,Double,3</ExcelBorders>
		*!*	   <Borders>
		*!*	    <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>
		*!*	    <Border ss:Position="Bottom" ss:LineStyle="Double" ss:Weight="3"/>
		*!*	   </Borders>
		
		* Codify report colors as <ExcelInterior>Solid,xxxxxx</ExcelInterior> and store in cExcelInterior
		*!* Interior properties.
		*!*		Color		 = Background Color
		*!*		Pattern		 = "Solid" --> no pattern, "Gray125", "ThinVert ss:Pattern="Solid"Stripe"
		*!*		PatternColor
		*!* Samples:
		*!*	<ExcelInterior>Solid,FFFF00</ExcelInterior>
		*!*		<Interior ss:Color="#FFFF00" ss:Pattern="Gray125"/>
		*!*	<ExcelInterior>Gray125,FFFFFF,000000</ExcelInterior>
		*!*		<Interior ss:Color="#FFFFFF" ss:Pattern="Gray125" ss:PatternColor="#000000"/>
		*!*	<ExcelInterior>ThinVertStripe,FFFF00,00FF00</ExcelInterior>
		*!*		<Interior ss:Color="#FFFF00" ss:Pattern="ThinVertStripe" ss:PatternColor="#00FF00"/>
		
		*<ExcelNamedRange>Cajas_Per2,=Sheet1!R10C13</ExcelNamedRange>
		
	ENDPROC

	PROCEDURE islonghorizontalline
		LPARAMETERS tcExpr
		RETURN !EMPTY(tcExpr) AND EMPTY(CHRTRAN(ALLTRIM(tcExpr),[=-"],[])) AND LEN(ALLTRIM(tcExpr)) > 15
		
	ENDPROC

	PROCEDURE isnumber
		LPARAMETERS tcContents
		LOCAL llIsNumber,lcAlias
		tcContents = ALLTRIM(tcContents)
		
		* 06/09/09 Generic method using value of FillChar in report file!
		*!*		lcAlias = ALIAS()
		*!*		llIsNumber = &lcAlias..FillChar = 'N'
			DO CASE
		*!*			CASE &lcAlias..FillChar = 'N'
		*!*				llIsNumber = .T.
		*!*			CASE &lcAlias..FillChar = 'C'
		*!*				llIsNumber = .F.
			* 02/01/07 Case added by Andrus Moor to handle dd.mm.yyyy date format.
			* Not very satisfying...  need to devise something more explicit and general.
				CASE OCCURS('.', tcContents)>1
					llIsNumber = .F.
				CASE LEN(tcContents) = 0
					llIsNumber = .F.
				CASE LEN(CHRTRAN(tcContents,'0123456789.,$','')) = 0
					llIsNumber = .T.
				OTHERWISE
					llIsNumber = (LEFT(tcContents,1) = '-' AND LEN(CHRTRAN(SUBSTR(tcContents,2),'0123456789.,$','')) = 0)
			ENDCASE
		RETURN llIsNumber
		
		
		*LPARAMETERS tcContents
		LOCAL llIsNumber
		tcContents = ALLTRIM(tcContents)
		DO CASE 
			CASE LEN(tcContents) = 0
				llIsNumber = .F.
			CASE LEN(CHRTRAN(tcContents,'0123456789.,$','')) = 0
				llIsNumber = .T.
			OTHERWISE
				llIsNumber = (LEFT(tcContents,1) = '-' AND LEN(CHRTRAN(SUBSTR(tcContents,2),'0123456789.,$','')) = 0)
		ENDCASE
		RETURN llIsNumber
	ENDPROC

	PROCEDURE isshorthorizontalline
		LPARAMETERS tcExpr
		RETURN !EMPTY(tcExpr) AND EMPTY(CHRTRAN(ALLTRIM(tcExpr),[=-"],[])) AND LEN(tcExpr) < 15
		
	ENDPROC

	PROCEDURE Render
		LPARAMETERS nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage
		IF this.lOutputToCursor  
			LOCAL cContents
			WITH this
				IF EMPTY(cContentsToBeRendered)
					cContents = ''
				ELSE 
		* 01/01/07 Correction by Andus Moor: Created XML file caused encoding error for some data
		*			cContents = STRCONV(cContentsToBeRendered, 6)
		* 02/01/07 Second conversion by Andrus Moor
		*			cContents = STRCONV(strt(strt(strt(cContentsToBeRendered,'&','&amp;'),'>','&gt;' ),'<','&lt;'),9)
		*			cContents = STRCONV(strt(strt(strt(cContentsToBeRendered,'&','&amp;'),'>','&gt;' ),'<','&lt;'),6)
		* 14/06/10 Fix by CChalom
		* Need first to convert the contents before converting to HTML tags
					LOCAL lcTmpContent
					lcTmpContent = STRCONV(cContentsToBeRendered, 6)
					cContents = strt(strt(strt(lcTmpContent,'&','&amp;'),'>','&gt;' ),'<','&lt;')
				ENDIF 
		
		
				This.setFRXDataSession()
				IF NOT EMPTY(cContents)
					INSERT INTO (.cOutputAlias) (nFrxRecno,nLeft, nTop, nWidth, nHeight,Contents,nPageNo) ;
										 VALUES (m.nFrxRecno,m.nLeft,m.nTop,m.nWidth,m.nHeight,m.cContents,.PageNo)
				ENDIF 
				this.setCurrentDataSession() 
				SELECT (this.drivingAlias)
			ENDWITH 
		ENDIF 
		DODEFAULT(nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage)
	ENDPROC

	PROCEDURE xextractexcelcol
		LPARAMETERS tcComment
		
		RETURN '0000000'
	ENDPROC

	PROCEDURE xml_cell
		LPARAMETERS tcContents,tnStyleNumber
		tcContents = ALLTRIM(tcContents)
		
		LOCAL lcRetVal
		IF UPPER(paStyles[tnStyleNumber-20,5]) = 'DATETIME'
			lcSetDate = SET("Date")
			SET DATE TO BRITISH
			tcContents = CTOD(tcContents)
			*1899-12-31T14:49:56.000
			tcContents = TRANSFORM(YEAR(tcContents),'@L 9999') ;
						 + '-' + TRANSFORM(MONTH(tcContents),'@L 99') ;
						 + '-' + TRANSFORM(DAY(tcContents),'@L 99') ;
						 + 'T00:00:00.000'
			SET DATE TO &lcSetDate
		ENDIF
		IF UPPER(paStyles[tnStyleNumber-20,5]) = 'NUMBER'
			tcContents = CHRTRAN(tcContents,',','')
			tcContents = CHRTRAN(tcContents,'$','')
		ENDIF
		IF UPPER(paStyles[tnStyleNumber-20,5]) = 'STRING'
			tcContents = This.Xml_Encode(tcContents,'Ñ')
			tcContents = This.Xml_Encode(tcContents,'ñ')
			tcContents = This.Xml_Encode(tcContents,'á')
			tcContents = This.Xml_Encode(tcContents,'é')
			tcContents = This.Xml_Encode(tcContents,'í')
			tcContents = This.Xml_Encode(tcContents,'ó')
			tcContents = This.Xml_Encode(tcContents,'ú')
		ENDIF
		
		LOCAL lcMergeAcross
		lcMergeAcross = IIF(EMPTY(nExcelMergeAcross),'',[ ss:MergeAcross="] + ALLTRIM(TRANSFORM(nExcelMergeAcross),'99999') + ["])
		
		
		lcData = IIF(UPPER(paStyles[tnStyleNumber-20,5]) = 'STRING' AND EMPTY(tcContents),'', ;
					 '<Data ss:Type="' + paStyles[tnStyleNumber-20,5] + '">' + tcContents + '</Data>')
		
		* 21/06/08 ExcelInsertFormula	<Cell ss:Index="7" ss:StyleID="s68" ss:Formula="=+R[-4]C-R[-3]C">
		
		*TEXT TO lcRetVal TEXTMERGE NOSHOW PRETEXT 2
		*<Cell  ss:Index="<<ALLTRIM(TRANSFORM(ExcelCol))>>" <<lcMergeAcross>> ss:StyleID="<<'s'+TRANSFORM(tnStyleNumber,'@L 99')>>"><<lcData>></Cell>
		*ENDTEXT
		LOCAL lcInsertFormula,lcNamedCell
		lcInsertFormula = IIF(EMPTY(cExcelInsertFormula),'',[ ss:Formula="] + ALLTRIM(cExcelInsertFormula) + ["])
		* 21/06/08 ExcelNamedCell	<Cell ss:Index="13" ss:StyleID="s67"><Data ss:Type="Number">17832.98</Data><NamedCell ss:Name="Cajas_Per2"/></Cell>
		lcNamedCell = ''
		IF !EMPTY(cExcelNamedCell)
			lcNamedCell = [<NamedCell ss:Name="] + ALLTRIM(cExcelNamedCell) + ["/>]
		*  <NamedRange ss:Name="Cajas_Per1" ss:RefersTo="=Sheet1!R10C7"/>
			REPLACE cExcelNamedRange WITH ALLTRIM(cExcelNamedCell) + [;] ;
										  + [=Sheet1!R] + ALLTRIM(TRANSFORM(ExcelRow)) ;
										  + [C] + ALLTRIM(TRANSFORM(ExcelCol))
		ENDIF
		
		*TEXT TO lcRetVal TEXTMERGE NOSHOW PRETEXT 2
		*<Cell  ss:Index="<<ALLTRIM(TRANSFORM(ExcelCol))>>" <<lcMergeAcross>> ss:StyleID="<<'s'+TRANSFORM(tnStyleNumber,'@L 99')>>" <<lcInsertFormula>> ><<lcData>></Cell>
		*ENDTEXT
		lcRetVal = [<Cell  ss:Index="] + ALLTRIM(TRANSFORM(ExcelCol)) + ["] ;
				   + lcMergeAcross + [ ss:StyleID="s] + TRANSFORM(tnStyleNumber,'@L 99') + ["] ;
				   + lcInsertFormula + [>] + lcData ;
				   + lcNamedCell + [</Cell>]
		RETURN lcRetVal + CHR(13) + CHR(10)
		
		*!*	   <Row ss:AutoFitHeight="0">
		*!*	    <Cell ss:StyleID="s27"><Data ss:Type="DateTime">2006-10-05T00:00:00.000</Data></Cell>
		*!*	   </Row>
		
		*!*	   <Row ss:AutoFitHeight="0">
		*!*	    <Cell ss:StyleID="s22"><Data ss:Type="String">Puro texto Bold</Data></Cell>
		*!*	   </Row>
		
	ENDPROC

	PROCEDURE xml_encode
		LPARAMETERS tcContents,tcChar
		tcContents = STRTRAN(tcContents,tcChar,'&#' + ALLTRIM(TRANSFORM(ASC(tcChar))) + ';')
		RETURN tcContents
	ENDPROC

	PROCEDURE xml_file_header
		LOCAL lcRetVal
		* 02/01/07 Change by andrus Moor
		*!*	TEXT TO lcRetVal NOSHOW PRETEXT 2
		*!*	<?xml version="1.0"?>
		*!*	<?mso-application progid="Excel.Sheet"?>
		*!*	ENDTEXT
		TEXT TO lcRetVal TEXTMERGE NOSHOW PRETEXT 2
		<?xml version="1.0" encoding="Windows-<<TRANSFORM(CPCURRENT())>>"?>
		<?mso-application progid="Excel.Sheet"?>
		ENDTEXT
		
		RETURN lcRetVal + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_name
		LPARAMETERS tnID
		* 21/06/08 Added
		*  <NamedRange ss:Name="Cajas_Per1" ss:RefersTo="=Sheet1!R10C7"/>
		*  <NamedRange ss:Name="Cajas_Per2" ss:RefersTo="=Sheet1!R10C13"/>
		
		LOCAL lcRetVal,laItems[1]
		lcRetVal = ''
		*SET STEP ON 
		ALINES(laItems,paNames[tnID],1 + 2,';')
		IF !EMPTY(laItems[1]) AND !EMPTY(laItems[2])
			lcRetVal = lcRetVal + [  <NamedRange ss:Name="] + ALLTRIM(laItems[1]) ;
								+ [" ss:RefersTo="] + ALLTRIM(laItems[2]) + ["/>] + CHR(13) + CHR(10)
		ENDIF
		RETURN lcRetVal
		
	ENDPROC

	PROCEDURE xml_names_footer
		* 21/06/08 Added
		RETURN '</Names>' + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_names_header
		* 21/06/08 Added
		RETURN '<Names>' + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_numberformat
		LPARAMETERS tcContents
		LOCAL lcType
		lcType = UPPER(This.Xml_Type(tcContents))
		DO CASE
			CASE lcType = 'NUMBER'
				IF AT(',',tcContents) > 0
					lcFormat = '###,###,##0'
				ELSE
					lcFormat = '########0'
				ENDIF
				IF AT('.',tcContents) > 0
					lcFormat = lcFormat + '.' + REPLICATE('0',LEN(tcContents) - AT('.',tcContents))
				ENDIF
			CASE lcType = 'DATETIME'
				lcFormat = 'Short Date'
			OTHERWISE
				lcFormat = 'String'
		ENDCASE
		RETURN lcFormat
	ENDPROC

	PROCEDURE xml_row_footer
		RETURN '</Row>' + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_row_header
		LOCAL lcRetVal
		
		TEXT TO lcRetVal TEXTMERGE NOSHOW PRETEXT 2
		<Row ss:Index="<<ALLTRIM(TRANSFORM(ExcelRow))>>" ss:AutoFitHeight="0">
		ENDTEXT
		RETURN lcRetVal + CHR(13) + CHR(10)
		
		
	ENDPROC

	PROCEDURE xml_style
		LPARAMETERS tnID
		lcFont	 = IIF(EMPTY(paStyles[tnId-20,2]),'',[ ss:FontName="] + ALLTRIM(paStyles[tnId-20,2]) + ["])
		lcFont	 = lcFont + IIF(EMPTY(paStyles[tnId-20,3]),'',[ ss:FontSize="] + ALLTRIM(TRANSFORM(paStyles[tnId-20,3])) + ["])
		lcBold	 = IIF(BITTEST(paStyles[tnId-20,4],0), [ ss:Bold="1"],'')
		lcItalic = IIF(BITTEST(paStyles[tnId-20,4],1), [ ss:Italic="1"],'')
		lcFamily = ''  && IIF(EMPTY(lcBold) AND EMPTY(lcItalic),'',[ x:Family="Modern"])
		lcFont   = lcFont + lcFamily + lcBold + lcItalic
		lcNumberFormat = IIF(EMPTY(paStyles[tnId-20,6]),'',[ ss:Format="] + paStyles[tnId-20,6] + ["])
		*lcHorizontalAlignment = IIF(paStyles[tnId-20,7] = 2,[ ss:Horizontal="Center"],'')
		DO CASE
			CASE 'LEFT' $ UPPER(paStyles[tnId-20,7])
				lcHorizontalAlignment = [ ss:Horizontal="Left"]
			CASE 'CENTER' $ UPPER(paStyles[tnId-20,7])
				lcHorizontalAlignment = [ ss:Horizontal="Center"]
			CASE 'RIGHT' $ UPPER(paStyles[tnId-20,7])
				lcHorizontalAlignment = [ ss:Horizontal="Right"]
			OTHERWISE
				lcHorizontalAlignment = ''
		ENDCASE
		
		*!* ExcelBorders format: <ExcelBorders>Top,Single,1;Bottom,Double,3</ExcelBorders>
		*!*	   <Borders>
		*!*	    <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>
		*!*	    <Border ss:Position="Bottom" ss:LineStyle="Double" ss:Weight="3"/>
		*!*	   </Borders>
		LOCAL laBorders[1],laBorder[1],i,j,lcPosition,lcLineStyle,lcWeight,lcBorder,lcBorders
		ALINES(laBorders,paStyles[tnId-20,8],1,';')
		IF EMPTY(laBorders[1])
			lcBorders = '<Borders/>'
		ELSE
			lcBorders = '<Borders>'
			FOR i = 1 TO ALEN(laBorders,1)
				ALINES(laBorder,laBorders[i],1,',')
				DIMENSION laBorder[3]
				IF EMPTY(laBorder[1])
					LOOP
				ENDIF
				lcPosition  = IIF(EMPTY(laBorder[1]),["Bottom"],["]+laBorder[1]+["])
				lcLineStyle = IIF(EMPTY(laBorder[2]) OR UPPER(laBorder[2]) = 'SINGLE',["Continuous"],["]+laBorder[2]+["])
				lcWeight    = IIF(EMPTY(laBorder[3]),["1"],["]+laBorder[3]+["])
				lcBorder	= [<Border ss:Position=]+lcPosition+[ ss:LineStyle=]+lcLineStyle + [ ss:Weight=] + lcWeight + [/>]
				lcBorders = lcBorders + lcBorder
			ENDFOR
			lcBorders = lcBorders + '</Borders>'
		ENDIF
		
		*!* Interior properties.
		*!*		Color		 = Background Color
		*!*		Pattern		 = "Solid" --> no pattern, "Gray125", "ThinVert ss:Pattern="Solid"Stripe"
		*!*		PatternColor
		*!* Samples:
		*!*	<ExcelInterior>Solid,FFFF00</ExcelInterior>
		*!*		<Interior ss:Color="#FFFF00" ss:Pattern="Gray125"/>
		*!*	<ExcelInterior>Gray125,FFFFFF,000000</ExcelInterior>
		*!*		<Interior ss:Color="#FFFFFF" ss:Pattern="Gray125" ss:PatternColor="#000000"/>
		*!*	<ExcelInterior>ThinVertStripe,FFFF00,00FF00</ExcelInterior>
		*!*		<Interior ss:Color="#FFFF00" ss:Pattern="ThinVertStripe" ss:PatternColor="#00FF00"/>
		LOCAL laInterior[1],lcPosition,lcLineStyle,lcWeight,lcInterior
		ALINES(laInterior,paStyles[tnId-20,9],1,',')
		DIMENSION laInterior[3]
		IF EMPTY(laInterior[1])
			lcInterior = '<Interior/>'
		ELSE
			lcPattern	   = [ ss:Pattern=] + IIF(EMPTY(laInterior[1]),["Solid"],["]+laInterior[1]+["])
			lcColor		   = [ ss:Color=] + IIF(EMPTY(laInterior[2]),["#FFFFFF"],["#]+laInterior[2]+["])
			lcPatternColor = IIF(EMPTY(laInterior[3]),[],[ ss:PatternColor=] + ["#]+laInterior[3]+["])
			lcInterior = '<Interior ' + lcColor + lcPattern + lcPatternColor + '/>'
		ENDIF
		
		TEXT TO lcRetVal NOSHOW TEXTMERGE PRETEXT 2
		  <Style ss:ID="<<'s' + TRANSFORM(tnID,'@L 99')>>">
		   <Alignment ss:Vertical="Bottom" <<lcHorizontalAlignment>>/>
		   <<lcBorders>>
		   <Font<<lcFont>>/>
		   <<lcInterior>>
		   <NumberFormat<<lcNumberFormat>>/>
		   <Protection/>
		  </Style>
		ENDTEXT
		RETURN lcRetVal + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_stylenumber
		LPARAMETERS tcContents
		
		LOCAL lcType,lcNumberFormat,lcKey,i
		lcType		   = This.Xml_Type(tcContents)
		lcNumberFormat = IIF(lcType = 'Number',This.Xml_NumberFormat(tcContents),'')
		lcNumberFormat = IIF(lcType = 'DateTime','Short Date',lcNumberFormat)
		lcKey		   = UPPER(PADR(FontFace,20)+TRAN(FontSize,'99')+TRAN(FontStyle,'99') ;
						+ PADR(lcType,10) + PADR(lcNumberFormat,20)) + PADR(cExcelAlignment,30) ;
						+ PADR(cExcelBorder,50) + PADR(cExcelInterior,50)
		i = ASCAN(paStyles,lcKey,1,ALEN(paStyles,1),1,1 + 2 + 4 + 8)
		IF i = 0
			i = ALEN(paStyles,1)+1
			DIMENSION paStyles[i,ALEN(paStyles,2)]
			paStyles[i,2] = FontFace
			paStyles[i,3] = FontSize
			paStyles[i,4] = FontStyle
			paStyles[i,5] = lcType
			paStyles[i,6] = lcNumberFormat
			paStyles[i,7] = cExcelAlignment	&& Alignment
			paStyles[i,8] = cExcelBorder	&& Border
			paStyles[i,9] = cExcelInterior	&& Interior color and pattern
			paStyles[i,1] = lcKey
		ENDIF
		RETURN 20 + i
	ENDPROC

	PROCEDURE xml_styles_footer
		RETURN '</Styles>' + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_styles_header
		RETURN '<Styles>' + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_table_footer
		RETURN '</Table>' + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_table_header
		LPARAMETERS tnRows,tnCols
		LOCAL lcRetVal,ja[1],i,lcColumns
		*   <Column ss:StyleID="s21" ss:AutoFitWidth="0" ss:Width="91.5"/>
		*   <Column ss:Index="4" ss:StyleID="s21" ss:AutoFitWidth="0" ss:Width="71.25"/>
		SELECT MAX(ExcelCol),MAX(ExcelRow) ;
		  FROM (This.cOutputAlias) ;
		  INTO ARRAY ja
		lcColumns = ''
		ASORT(paColData,1,ALEN(paColData),0)
		FOR i = 1 TO ALEN(paColData,1)
			IF EMPTY(paColData[i,1])
				LOOP
			ENDIF
			* Column1 = Column number
			* Column2 = AutoFitWidth (.T. / .F.)
			* Column3 = Column width
			lcColumns = lcColumns + CHR(13) + CHR(10) + [<Column ss:Index="] + TRANSFORM(paColData[i,1]) + ["]
			lcColumns = lcColumns + [ ss:AutoFitWidth="] + IIF(paColData[i,2],'1','0') + ["]
			* The stored width is screen width / 1.33333.  Screen pixels are screen width * 7 + 5.
			lcColumns = lcColumns + [ ss:Width="] + TRANSFORM(((paColData[i,3]*7+5)/1.333333)) + ["/>]
		ENDFOR
		TEXT TO lcRetVal TEXTMERGE NOSHOW PRETEXT 2
		<Table ss:ExpandedColumnCount="<<ja[1]>>" ss:ExpandedRowCount="<<ja[2]>>" x:FullColumns="1"
		 x:FullRows="1" ss:StyleID="s21" ss:DefaultRowHeight="14.25"><<lcColumns>> 
		ENDTEXT
		RETURN lcRetVal + CHR(13) + CHR(10)
		
		
	ENDPROC

	PROCEDURE xml_type
		LPARAMETERS tcContents
		tcContents = ALLTRIM(tcContents)
		
		LOCAL lcType,lcSetDate
		lcSetDate = SET("Date")
		SET DATE TO BRITISH
		DO CASE
			CASE This.IsNumber(tcContents)
				lcType = 'Number'
			CASE AT('/',tcContents,2) > 0 AND AT('/',tcContents,3) = 0
				* Make sure a string with two slashes is not interpreted as a date unless it is a date
				tcContents = CTOD(tcContents)
				IF VARTYPE(tcContents) = 'D' AND !EMPTY(tcContents)
					lcType = 'DateTime'
				ELSE
					lcType = 'String'
				endif
			OTHERWISE
				lcType = 'String'
		ENDCASE
		
		SET DATE TO &lcSetDate
		RETURN lcType
		
	ENDPROC

	PROCEDURE xml_workbook_footer
		RETURN '</Workbook>' + CHR(13) + CHR(10)
	ENDPROC

	PROCEDURE xml_workbook_header
		LOCAL lcRetVal
		TEXT TO lcRetVal NOSHOW PRETEXT 2
		<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
		 xmlns:o="urn:schemas-microsoft-com:office:office"
		 xmlns:x="urn:schemas-microsoft-com:office:excel"
		 xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
		 xmlns:html="http://www.w3.org/TR/REC-html40">
		ENDTEXT
		RETURN lcRetVal + CHR(13) + CHR(10)
		
	ENDPROC

	PROCEDURE xml_worksheet_footer
		LOCAL lcRetVal
		TEXT TO lcRetVal NOSHOW PRETEXT 2
		 </Worksheet>
		ENDTEXT
		RETURN lcRetVal + CHR(13) + CHR(10)
		
	ENDPROC

	PROCEDURE xml_worksheet_header
		LPARAMETERS tcWorksheetName
		LOCAL lcRetVal
		
		TEXT TO lcRetVal NOSHOW TEXTMERGE PRETEXT 2
		<Worksheet ss:Name="<<tcWorksheetName>>">
		ENDTEXT
		
		RETURN lcRetVal + CHR(13) + CHR(10)
	ENDPROC

ENDDEFINE
