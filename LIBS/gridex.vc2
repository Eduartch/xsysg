*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - 　ATENCIN!! - 　NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="gridex.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _do_controls AS container 		&& 表头额外的控制，锁列、等
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ImgLock" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ImgLockDrag" UniqueID="" Timestamp="" />

	#INCLUDE "manyheader.h"
	*<DefinedPropArrayMethod>
		*m: lock_mousedown		&& 锁定列的鼠标事件
		*m: lock_mousemove		&& 锁定列的鼠标事件
		*m: lock_mouseup		&& 锁定列的鼠标事件
		*m: setwidth		&& 设置宽度
		*p: ldrag		&& 是否开始拖动
		*p: mousedownx
		*p: mousedowny
		*p: nlock		&& 鼠标移动过的列数
		*p: nlockwidth		&& 锁定列总的宽度
		*p: npanel		&& 记录表格原 Panel
		*p: nrangemaxx		&& 可以移动的最大范围，屏幕单位
		*p: nrangeminx		&& 移动的最小范围，屏幕单位
		*p: nwidthset		&& 宽度偏移加量
	*</DefinedPropArrayMethod>

	BackColor = 255,255,230
	BorderWidth = 0
	Height = 7
	ldrag = .F.		&& 是否开始拖动
	mousedownx = 0
	mousedowny = 0
	Name = "_do_controls"
	nlock = 0		&& 鼠标移动过的列数
	nlockwidth = 0		&& 锁定列总的宽度
	npanel = 1		&& 记录表格原 Panel
	nrangemaxx = 0		&& 可以移动的最大范围，屏幕单位
	nrangeminx = 0		&& 移动的最小范围，屏幕单位
	nwidthset = 4		&& 宽度偏移加量
	Width = 200

	ADD OBJECT 'ImgLock' AS image WITH ;
		Height = 8, ;
		Left = 0, ;
		Name = "ImgLock", ;
		Picture = columnlock.bmp, ;
		ToolTipText = "锁列标记，在此处按下鼠标左键不放并移动鼠标", ;
		Top = -1, ;
		Width = 9
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'ImgLockDrag' AS image WITH ;
		Height = 8, ;
		Left = 9, ;
		Name = "ImgLockDrag", ;
		Picture = columnlockdrag.bmp, ;
		Top = -1, ;
		Visible = .F., ;
		Width = 9
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		BorderStyle = 0, ;
		BorderWidth = 0, ;
		DrawMode = 6, ;
		Height = 13, ;
		Left = 60, ;
		Name = "Shape1", ;
		Top = 0, ;
		Visible = .F., ;
		Width = 37
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE Init
		This.Width = This.ImgLock.Width
		This.BackStyle = 0
		
		This.imgLock.ToolTipText = ManyHeader_Controls_imgLock
	ENDPROC

	PROCEDURE lock_mousedown		&& 锁定列的鼠标事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.BackStyle = 1
		This.Shape1.Visible = .T.
		This.ImgLock.Zorder(0)
		This.Width = This.Parent.Width - 1
		This.nPanel = This.Parent.nPanel
		This.Parent.oRefGrid.Panel = This.Parent.nPanel
		
		This.lDrag = .F.
		This.MouseDownX = m.nXCoord
		This.MouseDownY = m.nYCoord
		This.nRangeMinX = ObjToClient(This, 2)
		This.nRangeMaxX = This.nRangeMinX + This.Width
		
		
	ENDPROC

	PROCEDURE lock_mousemove		&& 锁定列的鼠标事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		Private loGrid, lnWidth, loColumn, lnLock, lnMinLock
		Local loGrid, lnWidth, loColumn, lnLock, lnMinLock
		
		This.imgLockDrag.Left = Min(Max(m.nXCoord - This.nRangeMinX - This.imgLockDrag.Width/2, 0), This.Width - This.imgLockDrag.Width)
		*-- 防止鼠标跳动，至少要按住鼠标并移动 5 象素以上才认为是拖动
		If Not This.lDrag And Abs(This.MouseDownX - m.nXCoord) > 5
			This.lDrag = .T.
			This.imgLockDrag.Visible = .T.
			This.imgLockDrag.Zorder(0)
		EndIf
		
		If (Not This.lDrag) Or (Not BetWeen(m.nXCoord, This.nRangeMinX, This.nRangeMaxX))
			Return 
		EndIf
		lnMinLock = This.Parent.nMinLock
		loGrid = This.Parent.oRefGrid
		lnLock = 0
		lnWidth = 0
		For lnIndex = loGrid.LeftColumn To loGrid.ColumnCount
			loColumn = This.Parent.GetColumn(m.lnIndex)
			*-- 不可视列或者锁定后被隐藏的列
			If Not This.Parent.GetColumnVisible(m.loColumn)
				Loop
			EndIf
			If This.nRangeMinX + m.lnWidth + loColumn.Width + 1 >= m.nXCoord
				Exit For
			EndIf
			lnLock = m.lnLock + 1
			lnWidth = lnWidth + loColumn.Width + 1
		EndFor
		
		If m.lnLock < m.lnMinLock
			This.nLock = m.lnMinLock
			Return
		EndIf
		
		If This.nLock <> m.lnLock ;
		Or This.nLockWidth <> m.lnWidth
			This.nLock = m.lnLock
			This.nLockWidth = m.lnWidth
			This.SetWidth(m.lnWidth)
		EndIf
	ENDPROC

	PROCEDURE lock_mouseup		&& 锁定列的鼠标事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.BackStyle = 0
		This.Shape1.Visible = .F.
		This.imgLockDrag.Visible = .F.
		This.Parent.oRefGrid.Panel = This.nPanel
		
		If This.lDrag
			This.lDrag = .F.
			This.SetWidth(This.nLockWidth)
			This.Parent.HeaderLock(This.nLock)
		EndIf
		
	ENDPROC

	PROCEDURE Resize
		This.Shape1.Move(0, 0, This.nLockWidth, This.Height)
		If This.nLockWidth > This.Parent.Width
			This.ImgLock.Move(This.Parent.Width-This.ImgLock.Width - 1)
		Else
			This.ImgLock.Move(Iif(This.nLockWidth = 0, 0, This.nLockWidth-This.ImgLock.Width/2))
		EndIf
	ENDPROC

	PROCEDURE setwidth		&& 设置宽度
		LPARAMETERS tnWidth
		
		This.nLockWidth = m.tnWidth
		If Not This.lDrag
			This.Width = Max(This.ImgLock.Width, This.nLockWidth + This.ImgLock.Width/2)
		EndIf
		
		This.Resize()
	ENDPROC

	PROCEDURE ImgLock.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		If m.nButton = 1
			This.Tag = "Y"
			This.Parent.Lock_MouseDown(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE ImgLock.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		If m.nButton = 1 And This.Tag = "Y"
			This.Parent.Lock_MouseMove(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE ImgLock.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		If m.nButton = 1
			This.Tag = ""
			This.Parent.Lock_MouseUp(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE ImgLockDrag.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.Lock_MouseDown(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
	ENDPROC

	PROCEDURE ImgLockDrag.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.Lock_MouseMove(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		
	ENDPROC

	PROCEDURE ImgLockDrag.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.Lock_MouseUp(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _do_headerbase AS container 		&& 不可用 多表头基本组件
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="MoveBar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LineLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LineTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LineBottom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LineRight" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: bar_mousedown		&& 宽度调整条的 MouseDown 事件
		*m: bar_mousemove		&& 宽度调整条的 MouseMove 事件
		*m: bar_mouseup		&& 宽度调整条的 MouseUp 事件
		*m: caption_access
		*m: caption_assign
		*m: columnresizable		&& 调整列宽
		*m: drag_mousedown		&& 拖动列时的 MouseDown 事件
		*m: drag_mousemove		&& 拖动列时的 MouseMove 事件
		*m: drag_mouseup		&& 拖放列的 MouseUp 事件
		*m: drag_shadowcreate		&& 在表单对象上创建一个反转色的形状对象，并保存在 oRefShadow 上。
		*m: drag_shadowdestory		&& 销毁临时创建的反转色对象
		*m: headersort		&& 排序组员的列成员
		*m: lresizable_assign
		*p: caption		&& 指定对象标题文本。
		*p: ldrag		&& 是否己进入拖放模式
		*p: linit		&& 是否创建完成
		*p: lmovable		&& 是否可移动列
		*p: lresizable		&& 是否可调整列大小
		*p: mousedownx		&& 鼠标按下的  nXCoord 值
		*p: mousedowny
		*p: nalignment		&& 标头对齐方式
		*p: ndragmax
		*p: ndragmin
		*p: nmergecount		&& 本单元合并的列数
		*p: ntype		&& 标头类型 0 普通 1 组内标头 2 组标头
		*p: orefline		&& 指向移动条
		*p: orefshadow		&& 指向临时创建的反转色形状对象
		*p: orefup		&& 如果此列被合并，引用上层表头对象，对于合并列此值为 NULL。
		*a: arefcolumns[1,0]		&& 指向标头引用的表格列 Column 对象，对于普通标头，成员数 1，对于组标头，数组将有 nMergeCount 个成员。
	*</DefinedPropArrayMethod>

	HIDDEN ldrag,mousedownx,mousedowny,ndragmax,ndragmin,orefline,orefshadow
	BackStyle = 0
	BorderWidth = 0
	Height = 35
	ldrag = .F.		&& 是否己进入拖放模式
	linit = .F.		&& 是否创建完成
	lmovable = .F.		&& 是否可移动列
	lresizable = .F.		&& 是否可调整列大小
	mousedownx = 0		&& 鼠标按下的  nXCoord 值
	mousedowny = 0
	nalignment = 3		&& 标头对齐方式
	Name = "_do_headerbase"
	ndragmax = 0
	ndragmin = 0
	nmergecount = 0		&& 本单元合并的列数
	ntype = 0		&& 标头类型 0 普通 1 组内标头 2 组标头
	orefline = .NULL.		&& 指向移动条
	orefshadow = .NULL.		&& 指向临时创建的反转色形状对象
	orefup = .NULL.		&& 如果此列被合并，引用上层表头对象，对于合并列此值为 NULL。
	Width = 200

	ADD OBJECT 'Header1' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Header1", ;
		Height = 16, ;
		Left = 75, ;
		Name = "Header1", ;
		Top = 9, ;
		Width = 42, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'LineBottom' AS line WITH ;
		BorderWidth = 0, ;
		Height = 0, ;
		Left = 11, ;
		Name = "LineBottom", ;
		Top = 31, ;
		Width = 48
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'LineLeft' AS line WITH ;
		BorderColor = 255,255,255, ;
		Height = 28, ;
		Left = 12, ;
		Name = "LineLeft", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'LineRight' AS line WITH ;
		Height = 28, ;
		Left = 58, ;
		Name = "LineRight", ;
		Top = 6, ;
		Width = 0
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'LineTop' AS line WITH ;
		BorderColor = 255,255,255, ;
		Height = 0, ;
		Left = 12, ;
		Name = "LineTop", ;
		Top = 5, ;
		Width = 48
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'MoveBar' AS _do_movebar WITH ;
		BackColor = 255,128,0, ;
		BorderWidth = 0, ;
		Height = 34, ;
		Left = 188, ;
		MouseIcon = resize_v.cur, ;
		MousePointer = 99, ;
		Name = "MoveBar", ;
		Top = 0, ;
		Visible = .F., ;
		Width = 4
		*< END OBJECT: ClassLib="gridex.vcx" BaseClass="container" />

	ADD OBJECT 'Shape1' AS _do_shape WITH ;
		BorderStyle = 0, ;
		BorderWidth = 0, ;
		DrawMode = 6, ;
		Height = 13, ;
		Left = 21, ;
		MouseIcon = header_down.cur, ;
		MousePointer = 99, ;
		Name = "Shape1", ;
		Top = 12, ;
		Width = 23
		*< END OBJECT: ClassLib="gridex.vcx" BaseClass="shape" />
	
	PROCEDURE bar_mousedown		&& 宽度调整条的 MouseDown 事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- 标头宽度调整条的 MooseDown 事件
		*-- 参数
			* toHeader 		类实例的标头对象，指出是哪一个列标头发生了此事件
			* 其余参数同 MouseDown 事件
		*-- 返回值
			* 无
		
		Private loGrid, lnIndex, loColumn, loColTmp, lnLock
		Local loGrid, lnIndex, loColumn, loColTmp, lnLock
		
		loGrid = This.Parent.oRefGrid
		This.MouseDownX	= m.nXCoord
		This.MouseDownY	= m.nYCoord
		
		Do Case 
		Case m.nButton = 1 
		*-- 调整大小
			ThisForm.NewObject("_" + Sys(2015), "Line")
			This.oRefLine = ThisForm.Controls(ThisForm.ControlCount)
			With This.oRefLine
				.Visible = .T.
				.DrawMode = This.Shape1.DrawMode
				.AddProperty("nRangeMinX", ObjToClient(This, 2))
				.AddProperty("nRangeMaxX", This.Parent.Left + This.Parent.Width)
		
				.Move(ObjToClient(This, 2) + This.Width - 1, ;
					ObjToClient(This.Parent, 1), ;
					0, ;
					Max(m.loGrid.Height - Iif(InList(m.loGrid.ScrollBars, 1, 3), SysMetric(8), 0) - 2, 0))
			EndWith
		
		Case m.nButton = 2
		*-- 原 vfp9 的鼠标右键锁列
			lnLock = 0
			loColumn = This.Parent.GetColumn(This.Parent.GetGroupMax(This))
			For lnIndex = loGrid.LeftColumn To loColumn.ColumnOrder
				loColTmp = This.Parent.GetColumn(m.lnIndex)
				If loColTmp.Visible And ObjToClient(loColtmp, 2) > 0
					lnLock = lnLock + 1
				EndIf
			EndFor
			If This.Parent.nLock <> m.lnLock
			*-- 第一次单击加锁
				This.Parent.HeaderLock(Max(m.lnLock, This.Parent.nMinLock))
			Else
			*-- 第二次单击解锁
				This.Parent.HeaderLock(This.Parent.nMinLock)
			EndIf
		
		EndCase
	ENDPROC

	PROCEDURE bar_mousemove		&& 宽度调整条的 MouseMove 事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- 标头宽度调整条的 MooseMove 事件
		
		Private lnLeft
		Local lnleft
		
		With This.oRefLine
			lnLeft = ObjToClient(This.MoveBar, 2) - This.MouseDownX + m.nXCoord
			.Left = Min(.nRangeMaxX, Max(m.lnLeft, .nRangeMinX))
		*!*		Do Case
		*!*		Case m.lnLeft < .Min
		*!*			m.lnLeft = .Min
		*!*		Case m.lnLeft > .Max
		*!*			* m.lnLeft = .Max
		*!*		EndCase
		
		*!*		.Left = m.lnLeft
		EndWith
		
	ENDPROC

	PROCEDURE bar_mouseup		&& 宽度调整条的 MouseUp 事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- 标头宽度移动条的 MooseUp 事件
		
		If Not IsNull(This.oRefLine)
			ThisForm.RemoveObject(This.oRefLine.Name)
			This.oRefLine = NULL
		EndIf
		If m.nXCoord <> This.MouseDownX
			This.ColumnResizable(m.nXCoord - This.MouseDownX)
		EndIf
	ENDPROC

	PROCEDURE caption_access
		*To do: 为 Access 方法程序修改此例程
		Return This.Header1.Caption
		
	ENDPROC

	PROCEDURE caption_assign
		LPARAMETERS vNewVal
		*To do: 为 Assign 方法程序修改此例程
		This.Header1.Caption 	= m.vNewVal
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE Click
		This.Parent.OnClick(This)
	ENDPROC

	PROCEDURE columnresizable		&& 调整列宽
		LPARAMETERS tnValue
		
		*-- 调整标头对象列宽度
		*-- 参数
			* tnValue 	增加的宽度，负数为减
		*-- 返回值
			* 元
		
		Private lnCell, loColumn, lnCellWidth, lnMod
		Local lnCell, loColumn, lnCellWidth, lnMod
		
		lnCell = 0
		*-- 检索可以 Resizable 的列
		For Each loColumn In This.aRefColumns
			lnCell = m.lnCell + Iif(loColumn.Resizable, 1, 0)
		EndFor
		
		*-- 均分宽度到每一个可 Resizable 的列
		lnCellWidth = Int(m.tnValue/m.lnCell)
		lnMod = Mod(m.tnValue, m.lnCell)
		For Each loColumn In This.aRefColumns
			If loColumn.Resizable
				lnCell = m.lnCell - 1
				If lnCell <> 0
					loColumn.Width = Max(loColumn.Width + m.lnCellWidth, 0)
				Else
					*-- 最后一列时，将等比剩作的余数累加到其中
					loColumn.Width = Max(loColumn.Width + m.lnCellWidth + m.lnMod, 0)
				EndIf
			EndIf
		EndFor
		
		This.Parent.HeaderRedraw()
		If Not IsNull(This.Parent.oRefPanel)
			This.Parent.oRefPanel.HeaderRedraw()
		EndIf
	ENDPROC

	PROCEDURE DblClick
		This.Parent.OnDblClick(This)
	ENDPROC

	PROCEDURE drag_mousedown		&& 拖动列时的 MouseDown 事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- 标头拖动条的 MooseDown 事件
		
		This.MouseDownX	= m.nXCoord
		This.MouseDownY	= m.nYCoord
		
		*-- 可以拖动的范围
		If IsNull(This.oRefup)
		*-- 无合并标头, 整个列头范围
			This.nDragMin = ObjToClient(This.Parent, 2)
			This.nDragMax = This.nDragMin + This.Parent.Width
		Else
		*-- 有合并标头, 合并标头范围
			This.nDragMin = ObjToClient(This.oRefup, 2)
			This.nDragMax = This.nDragMin + This.oRefup.Width
		EndIf
		
		If m.nButton = 1
			This.Shape1.BackStyle = 1
		EndIf
	ENDPROC

	PROCEDURE drag_mousemove		&& 拖动列时的 MouseMove 事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- 标头拖动条的 MooseMove 事件
		
		Private lnLeft, loBorderHeader, lnMinLock
		Local lnLeft, loBorderHeader, lnMinLock
		
		*-- 防止鼠标跳动，至少要按住鼠标并移动 5 象素以上才认为是拖动
		If Not This.lDrag And Abs(This.MouseDownX - m.nXCoord) > 5
			This.Drag_ShadowCreate()
			This.lDrag = .T.
		EndIf
		
		If This.lDrag And BetWeen(m.nXCoord, This.nDragMin, This.nDragMax)
			m.lnLeft = ObjToClient(This, 2)
			*-- 左移
			Do Case
			Case (m.nXCoord < This.MouseDownX) And (m.nXCoord < m.lnLeft)
				*-- 如果存在左邻标头，并且足以放入标头
				loBorderHeader = This.Parent.GetHeaderLeft(This)
				If Not IsNull(m.loBorderHeader) ;
				And loBorderHeader.Visible ;
				And m.nXCoord < ObjToClient(m.loBorderHeader, 2) + This.Width
					*-- 检查是否尝试移入至 nMinLock 范围
					#If Version(5) > 600
						lnMinLock = This.Parent.nMinLock
						Do Case
						Case loBorderHeader.nType = 0 And loBorderHeader.aRefColumns[1].ColumnOrder <= m.lnMinLock
							Return
						Case loBorderHeader.nType = 1 And loBorderHeader.aRefColumns[1].ColumnOrder <= m.lnMinLock
							Return
						Case loBorderHeader.nType = 2 And This.Parent.GetGroupMin(m.loBorderHeader) <= m.lnMinLock
							Return
						EndCase
					#EndIf
					
					This.MouseDownX = m.nXCoord
					This.Parent.HeaderSwap(This, m.loBorderHeader)
					This.Drag_ShadowCreate()
					This.Parent.OnDrag(This, 0)
				EndIf
		
			*-- 右移
			Case (m.nXCoord > This.MouseDownX) And (m.nXCoord > m.lnLeft + This.Width)
				*-- 如果存在右邻标头，并且足以放入标头
				loBorderHeader = This.Parent.GetHeaderRight(This)
				If Not IsNull(m.loBorderHeader) ;
				And loBorderHeader.Visible ;
				And  m.nXCoord > ObjToClient(m.loBorderHeader, 2) + loBorderHeader.Width - This.Width
					
					This.MouseDownX = m.nXCoord
					This.Parent.HeaderSwap(m.loBorderHeader, This)
					This.Drag_ShadowCreate()
					This.Parent.OnDrag(This, 1)
				EndIf
			EndCase
		EndIf
	ENDPROC

	PROCEDURE drag_mouseup		&& 拖放列的 MouseUp 事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- 标头拖动条的 MooseUp 事件
		*-- 参数
			* toHeader 		类实例的标头对象，指出是哪一个列标头发生了此事件
			* 其余参数同 MouseDown 事件
		*-- 返回值
			* 无
		
		This.lDrag = .F.
		This.Shape1.BackStyle = 0
		This.drag_ShadowDestory()
		
	ENDPROC

	PROCEDURE drag_shadowcreate		&& 在表单对象上创建一个反转色的形状对象，并保存在 oRefShadow 上。
		*-- 开始拖动列时，画出一个反转色的形状以更醒目
		
		Privat lnScroll, loGrid
		Local lnScroll, loGrid
		
		loGrid = This.Parent.oRefGrid
		
		If IsNull(This.oRefShadow)
			ThisForm.NewObject("_" + Sys(2015), "Shape")
			This.oRefShadow = ThisForm.Controls(ThisForm.ControlCount)
			With This.oRefShadow
				lnScroll = Iif(InList(loGrid.ScrollBars, 1, 3), SysMetric(8), 0) + 1
				If This.nType  = 2
					.Top = ObjToClient(This, 1) + This.Height
					.Height = Max(loGrid.Height - This.Height - m.lnScroll, 0)
				Else
					.Top = ObjToClient(This, 1) + This.Height - 2
					.Height = Max(loGrid.Height - This.Parent.Height - m.lnScroll, 0)
				EndIf
				.BorderStyle = 0
				.BorderWidth = 0
				.DrawMode = 6
				.Zorder(0)
			EndWith
		EndIf
		
		With This.oRefShadow
			.Move(ObjToClient(m.This, 2), .Top, m.This.Width)
			.Visible = This.Visible
		EndWith
	ENDPROC

	PROCEDURE drag_shadowdestory		&& 销毁临时创建的反转色对象
		
		*-- 清除拖动列的反转色显示对象
		
		If Not IsNull(This.oRefShadow)
			ThisForm.RemoveObject(This.oRefShadow.Name)
		EndIf
		
		This.oRefShadow = NULL
	ENDPROC

	PROCEDURE headersort		&& 排序组员的列成员
		LPARAMETERS tnSortOrder
		
		Private loColumn, lnIndex, laColumn[1, 2]
		Local loColumn, lnIndex, laColumn[1, 2]
		
		If This.nType = 2
			Dimension laColumn[This.nMergeCount, 2]
		
			*-- 先将组标头的成员信息保存到临时数组中
			For lnIndex = 1 To This.nMergeCount
				loColumn = This.aRefColumns[m.lnIndex]
				laColumn[m.lnIndex, 1] = loColumn
				laColumn[m.lnIndex, 2] = loColumn.ColumnOrder
			EndFor
			ASort(laColumn, 2, -1, Iif(VarType(m.tnSortOrder) = "N" And m.tnSortOrder <> 0, 1, 0))
			For lnIndex = 1 To This.nMergeCount
				This.aRefColumns[m.lnIndex] = laColumn[m.lnIndex, 1]
			EndFor
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE lresizable_assign
		LPARAMETERS vNewVal
		*To do: 为 Assign 方法程序修改此例程
		This.lResizable = m.vNewVal
		This.MoveBar.Visible = m.vNewVal
		
	ENDPROC

	PROCEDURE MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.OnMouseEnter(This, m.nButton, m.nShift, m.nXCoord, m.nYCoord)
	ENDPROC

	PROCEDURE MouseLeave
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.OnMouseLeave(This, m.nButton, m.nShift, m.nXCoord, m.nYCoord)
	ENDPROC

	PROCEDURE Refresh
		If Not This.Visible
			Return
		EndIf
		
		With This.Header1
			.Width = This.Width
			.Move(Max((This.Width - .Width) / 2, 0), ;
						Max((This.Height - .Height ) / 2 + 1, 0))
		EndWith
		
		*!*	With This.Header1
		*!*		.Move(0, 0, This.Width, This.Height)
		*!*		.Move(Max((This.Width - .Width) / 2, 0), ;
		*!*					Max((This.Height - .Height ) / 2 + 1, 0))
		
		If This.nType >= 2
			Return
		EndIf
		
		With This.Header1
		Do Case 
		Case This.nAlignMent = 0		&& 垂直居中, 水平居左
			.Left = 0
			.Alignment = 0
		Case This.nAlignMent = 1		&& 垂直居中, 水平居右
			.Left = Max(This.Width - .Width, 0)
			.Alignment = 1
		Case This.nAlignMent = 2		&& 垂直居中, 水平居中
			.Alignment = 2
		Case This.nAlignMent = 3		&& 自动
		
		Case This.nAlignMent = 4		&& 垂直居上, 水平居左
			.Top = 1
			.Alignment = 0
		Case This.nAlignMent = 5 		&& 垂直居上, 水平居右
			.Top = 1
			.Alignment = 1
		Case This.nAlignMent = 6		&& 垂直居上, 水平居中
			.Alignment = 2
		Case This.nAlignMent = 7 		&& 垂直居下, 水平居左
			.Top = Max(This.Height - .Height, 0)
			.Alignment = 0
		Case This.nAlignMent = 8 		&& 垂直居下, 水平居右
			.Top = Max(This.Height - .Height, 0)
			.Alignment = 1
		Case This.nAlignMent = 9 		&& 垂直居下, 水平居中
			.Top = This.Height - .Height
			.Alignment = 2
		EndCase
		EndWith
	ENDPROC

	PROCEDURE Resize
		With This
			.MoveBar.Move(.Width - .MoveBar.Width, 0, .MoveBar.Width, .Height)
		
			.LineTop.Move(0, 0, Max(.Width - 1, 0), 0)
			.LineBottom.Move(0, .Height-1, .Width, 0)
			.LineLeft.Move(0, 0, 0, .Height)
			.LineRight.Move(.Width - 1, 0, 0, .Height)
		
			.Shape1.Move(0, 0, This.Width, This.Height)
			.Shape1.Zorder(0)
		
			.MoveBar.Zorder(0)
		EndWith
		
		If This.lInit
			This.Parent.OnResize(This)
		EndIf
	ENDPROC

	PROCEDURE RightClick
		This.Parent.OnRightClick(This)
	ENDPROC

	PROCEDURE MoveBar.DblClick
		*-- AutoFit
		Private loColumn, llLockScreen
		Local loColumn, llLockScreen
		
		If This.Parent.Parent.oRefGrid.AllowAutoColumnFit < 2
			llLockScreen = ThisForm.LockScreen
			ThisForm.LockScreen = .T.
			For Each loColumn In This.Parent.aRefColumns
				loColumn.AutoFit()
			EndFor
			This.Parent.Parent.HeaderRedraw()
			ThisForm.LockScreen = m.llLockScreen
		EndIf
		
		
	ENDPROC

	PROCEDURE MoveBar.Init
		*-- vfp 可以去掉
		DoDefault()
		
		This.BackStyle = 0
	ENDPROC

	PROCEDURE MoveBar.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Tag = "Y"
		This.Parent.Bar_MouseDown(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		
	ENDPROC

	PROCEDURE MoveBar.MouseEnter
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		This.Parent.MouseEnter(m.nButton, m.nShift, m.nXcoord, m.nYcoord)
	ENDPROC

	PROCEDURE MoveBar.MouseLeave
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		This.Parent.MouseLeave(m.nButton, m.nShift, m.nXcoord, m.nYcoord)
	ENDPROC

	PROCEDURE MoveBar.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- vfp 可以去掉
		DoDefault(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		
		If m.nButton = 1 And This.Tag = "Y"
			This.Parent.Bar_MouseMove(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE MoveBar.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Tag = ""
		If m.nButton = 1
			This.Parent.Bar_MouseUp(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE Shape1.Click
		This.Parent.Click()
	ENDPROC

	PROCEDURE Shape1.DblClick
		This.Parent.DblClick()
	ENDPROC

	PROCEDURE Shape1.Init
		*-- vfp 可以去掉
		DoDefault()
		
		This.BackStyle = 0
		
		*** vfp6
		*** This.Parent.OnMouseEnter(This, m.nButton, m.nShift, m.nXCoord, m.nYCoord)
	ENDPROC

	PROCEDURE Shape1.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		If This.Parent.lMovable
			This.Tag = "Y"
			This.Parent.Drag_MouseDown(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE Shape1.MouseEnter
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		This.Parent.MouseEnter(m.nButton, m.nShift, m.nXcoord, m.nYcoord)
		
	ENDPROC

	PROCEDURE Shape1.MouseLeave
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		This.Parent.MouseLeave(m.nButton, m.nShift, m.nXcoord, m.nYcoord)
	ENDPROC

	PROCEDURE Shape1.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- vfp 可以去掉
		DoDefault(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		
		If m.nButton = 1 And This.Tag = "Y" And This.Parent.lMovable
			This.Parent.Drag_MouseMove(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE Shape1.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		This.Tag = ""
		If This.Parent.lMovable
			This.Parent.Drag_MouseUp(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE Shape1.RightClick
		This.Parent.RightClick()
	ENDPROC

ENDDEFINE

DEFINE CLASS _do_movebar AS container 		&& 兼容 vfp6 所使用。vfp9 可以去掉。
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: mouseenter		&& 鼠标进入事件
		*m: mouseleave		&& 鼠标移出事件
	*</DefinedPropArrayMethod>

	Height = 50
	Name = "_do_movebar"
	Width = 50
	
	PROCEDURE Destroy
		#If Not Version(5) > 600
			If Type("_Screen._vfp6MouseEvent.Name") = "C"
				_Screen._vfp6MouseEvent.UnRegister()
			EndIf
		#EndIf
	ENDPROC

	PROCEDURE Init
		#If Not Version(5) > 600
			If Type("_Screen._vfp6MouseEvent.Name") <> "C"
				_Screen.NewObject("_vfp6MouseEvent", "_vfp6MouseEvent")
			EndIf
		
			_Screen._vfp6MouseEvent.Register()
		#EndIf
	ENDPROC

	PROCEDURE mouseenter		&& 鼠标进入事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
	ENDPROC

	PROCEDURE mouseleave		&& 鼠标移出事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
	ENDPROC

	PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		#If Not Version(5) > 600
		If m.nButton = 0 And This.Enabled
			If Type("_Screen._vfp6MouseEvent.Name") = "C"
				_Screen._vfp6MouseEvent.MouseMove(This, m.nButton, m.nShift, m.nXCoord, m.nYCoord)
			EndIf
		EndIf
		#EndIf
	ENDPROC

ENDDEFINE

DEFINE CLASS _do_shape AS shape 		&& 兼容 vfp6 所使用。vfp9 可以去掉。
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: mouseenter
		*m: mouseleave
	*</DefinedPropArrayMethod>

	Height = 17
	Name = "_do_shape"
	Width = 100
	
	PROCEDURE Destroy
		#If Not Version(5) > 600
			If Type("_Screen._vfp6MouseEvent.Name") = "C"
				_Screen._vfp6MouseEvent.UnRegister()
			EndIf
		#EndIf
	ENDPROC

	PROCEDURE Init
		#If Not Version(5) > 600
			If Type("_Screen._vfp6MouseEvent.Name") <> "C"
				_Screen.NewObject("_vfp6MouseEvent", "_vfp6MouseEvent")
			EndIf
		
			_Screen._vfp6MouseEvent.Register()
		#EndIf
	ENDPROC

	PROCEDURE mouseenter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
	ENDPROC

	PROCEDURE mouseleave
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
	ENDPROC

	PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		#If Not Version(5) > 600
		If m.nButton = 0 And This.Enabled
			If Type("_Screen._vfp6MouseEvent.Name") = "C"
				_Screen._vfp6MouseEvent.MouseMove(This, m.nButton, m.nShift, m.nXCoord, m.nYCoord)
			EndIf
		EndIf
		#EndIf
	ENDPROC

ENDDEFINE

DEFINE CLASS _unlockscreen AS timer 		&& 解除 LockScreen
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	Enabled = .F.
	Height = 23
	Interval = 50
	Name = "_unlockscreen"
	Width = 23
	
	PROCEDURE Timer
		This.Enabled = .F.
		This.Parent.LockScreen = .F.
	ENDPROC

ENDDEFINE

DEFINE CLASS _vfp6mouseevent AS timer 
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: mousemove		&& 当用户移动鼠标指针到一个对象上时发生。
		*m: register
		*m: unregister
		*p: counts
		*p: orefobject
	*</DefinedPropArrayMethod>

	counts = 0
	Enabled = .F.
	Height = 23
	Interval = 40
	Name = "_vfp6mouseevent"
	orefobject = .NULL.
	Width = 23
	
	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		This.Enabled = .F.
	ENDPROC

	PROCEDURE mousemove		&& 当用户移动鼠标指针到一个对象上时发生。
		LPARAMETERS toObject, nButton, nShift, nXCoord, nYCoord
		
		This.Enabled = .F.
		
		If IsNull(This.oRefObject)
			This.oRefObject	= m.toObject
			This.oRefObject.MouseEnter()
		Else
			If m.toObject <> This.oRefObject
				This.oRefObject.MouseLeave()
				This.oRefObject	= NULL
				This.oRefObject	= m.toObject
				This.oRefObject.MouseEnter()
			EndIf
		EndIf
		
		This.Enabled = .T.
	ENDPROC

	PROCEDURE register
		This.Counts = This.Counts + 1
	ENDPROC

	PROCEDURE Timer
		This.Enabled	= .F.
		
		Private loMObject, loObject
		Local loMObject, loObject
		
		If Not MDow()
			loMObject = NULL
			loObject = NULL
		
			If Not IsNull(This.oRefObject)
				*-- 如果鼠标下没有对象，则当前控制己经离开了焦点
				loMObject	= Sys(1270)
				If VarType(loMObject) <> "O"
					This.oRefObject.MouseLeave()
					This.oRefObject	= NULL
				Else
				*-- 如果鼠标下有对象，检查是否当前对象或否于容器内对象
					If m.loMObject # This.oRefObject
						For Each loObject In This.oRefObject.Controls
							If m.loMObject = m.loObject
								*-- 鼠标仍停留在当前对象内，继续检查
								This.Enabled	= .T.
								Return
							EndIf
						EndFor
		
						This.oRefObject.MouseLeave()
						This.oRefObject	= NULL
					EndIf
				EndIf
			Else
				This.oRefObject	= NULL
			EndIf
		EndIf
		
		* Debug
		* ? Chr(7)
		This.Enabled = Not IsNull(This.oRefObject)
		
	ENDPROC

	PROCEDURE unregister
		This.Counts = This.Counts - 1
		
		If This.Counts <= 0
			This.oRefObject	= NULL
			_Screen.RemoveObject( This.Name )
		EndIf
	ENDPROC

ENDDEFINE

DEFINE CLASS manyheader AS container 		&& 双层表头类，需在 _do_* 组件
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "manyheader.h"
	*<DefinedPropArrayMethod>
		*m: about
		*m: bindevents		&& 绑定表格对象的属性
		*m: controlcreate		&& 创建表头额外的控制
		*m: controldestory		&& 锁毁额外的表头控制
		*m: ev_afterrowcolchange		&& 表格的 AfterRowColChange  事件
		*m: ev_formlostfocus		&& 当离开表单时发生此事件
		*m: ev_keypress
		*m: ev_mousedown		&& 表格的 MouseDown 事件
		*m: ev_mouseup		&& 绑定表格的 MouseUp 事件
		*m: ev_scrolled		&& 表格滚动事件
		*m: ev_valid		&& 表格的 GridValid 事件
		*m: getcolumn		&& 返回指定索引号的表格列对象。
		*m: getcolumnheader		&& 获取指定表格列对象的 Header 对象
		*m: getcolumnvisible		&& 修正 ObjToClient 在 Vfp9 sp2 下的问题。
		*m: getgridcolumn		&& 获取表格列信息。数组行对应 Order，值对应 Column(lnIndex) 值。
		*m: getgroupmax		&& 获取组中最大 ColumnOrder
		*m: getgroupmin		&& 获取组中最小 ColumnOrder
		*m: getheaderleft		&& 获取指定标头的左邻 Header
		*m: getheaderright		&& 获取指定标头对象的右邻 Header
		*m: getleftcolumn		&& 未锁列时，返回 Grid.LeftColumn，锁列时，返回锁列后面的第一个可见列。
		*m: getrefheader		&& 获取表格 Column 指向的标头对象
		*m: headerclear		&& 清除标头
		*m: headerdel		&& 内用。删除一个组内标头或者组标头，如果组内组中间，则该列变成组的右邻对象。
		*m: headerdelete		&& 删除一个组内标头或者组标头，如果组内组中间，则该列变成组的右邻对象。
		*m: headerlock		&& 从表格 LeftColumn 起，锁定表头指定列数
		*m: headerlockcheck		&& 检查锁环境
		*m: headerlockex		&& Vfp6 列锁定的修复操作
		*m: headerredraw		&& 按照表格信息，重画表格
		*m: headerresize		&& 根据表格信息，重新设置标头大小、座标等信息
		*m: headerswap		&& 交换两个标头位置
		*m: initheader		&& 初始表类对象，与表格相绑定
		*m: llock_assign
		*m: mergecleartry		&& 在不改变 ColumnOrder 的前提下，尝试合并后废弃的组。
		*m: mergeheader		&& 合并表格列
		*m: onclick		&& 标头单击事件，默认执行表格列标头 Click 事件
		*m: ondblclick		&& 标头双击事件，默认执行表格列标头 Click 事件
		*m: ondrag		&& 当某列被拖动移动位置后，触发本事件。0 左移，1 右移。
		*m: onlock		&& 当锁定列或解除锁定后，发生此事件
		*m: onmouseenter		&& 当鼠标移入标头对象内发生此事件
		*m: onmouseleave		&& 当鼠标移出标头后发生此事件
		*m: onresize		&& 当标头宽茺发生变化，发生此事件
		*m: onrightclick		&& 标头单击事件，默认执行表格列标头 RightClick 事件
		*m: onstyle		&& 当创建一个表头后，都会触发此事件，可在此设置标头样式。
		*m: panelcreate		&& 创建链接表格对象
		*m: paneldestroy		&& 销毁拆分后的面板控件
		*m: unlockscreen
		*m: visible_assign
		*p: lalignment		&& 是否取 Column.Header.Alignment 信息。
		*p: llock		&& 是否允许锁定列。可设置。
		*p: lmaster		&& 内用，指出拆分时哪一个是主要表。设计时不可修改。只读。
		*p: lsplitbar		&& 指明是否添加拆加表头，还是人为放置两个标头来拆分表格。可设置。
		*p: nclicksecond		&& 上次单击表格的时间。只读。
		*p: ndeletemark		&& 表格删除列宽度的常量。可设置。
		*p: nleftcolumn		&& 记录上次表格 LeftColumn。可设置。
		*p: nleftoffset		&& 可能表格存在特殊外观效果，此值可以用于修正新标头的 Left 值。可设置。
		*p: nlock		&& 记录待锁定列数。只读。
		*p: nminlock		&& 最小锁定列数，不允许解除指定列的锁定状态。可设置。
		*p: npanel		&& 当表格拆分时，指定标头绑定的表格的左表格还是右表格。0=左，1=右（默认）
		*p: nrecordmark		&& 表格记录选择列宽度的常量。
		*p: nref		&& 表格列指向标头的索引
		*p: ntopoffset		&& 可能表格存在特殊外观效果，此值可以用于修正新标头的 top 值。
		*p: nwhere_out		&& 上次鼠标点击的位置
		*p: orefcontrol		&& 指向额外控制
		*p: orefgrid		&& 引用的表格对象
		*p: orefpanel		&& 拆分表格时，指向另一个拆分表格
		*p: oreftimer
		*a: acolumn[1,0]		&& 数组行对应 Order，值对应 Column(lnIndex)
		*a: areflocks[1,0]		&& 指向被锁定的表格列
	*</DefinedPropArrayMethod>

	HIDDEN nclicksecond,orefcontrol,oreftimer
	BorderWidth = 0
	Height = 28
	lalignment = .F.		&& 是否取 Column.Header.Alignment 信息。
	llock = .T.		&& 是否允许锁定列。可设置。
	lmaster = .T.		&& 内用，指出拆分时哪一个是主要表。设计时不可修改。只读。
	lsplitbar = .T.		&& 指明是否添加拆加表头，还是人为放置两个标头来拆分表格。可设置。
	Name = "manyheader"
	nclicksecond = 0		&& 上次单击表格的时间。只读。
	ndeletemark = 8		&& 表格删除列宽度的常量。可设置。
	nleftcolumn = 0		&& 记录上次表格 LeftColumn。可设置。
	nleftoffset = 0		&& 可能表格存在特殊外观效果，此值可以用于修正新标头的 Left 值。可设置。
	nlock = 0		&& 记录待锁定列数。只读。
	nminlock = 0		&& 最小锁定列数，不允许解除指定列的锁定状态。可设置。
	npanel = 1		&& 当表格拆分时，指定标头绑定的表格的左表格还是右表格。0=左，1=右（默认）
	nrecordmark = 10		&& 表格记录选择列宽度的常量。
	nref = -1		&& 表格列指向标头的索引
	ntopoffset = 0		&& 可能表格存在特殊外观效果，此值可以用于修正新标头的 top 值。
	nwhere_out = 0		&& 上次鼠标点击的位置
	orefcontrol = .NULL.		&& 指向额外控制
	orefgrid = .NULL.		&& 引用的表格对象
	orefpanel = .NULL.		&& 拆分表格时，指向另一个拆分表格
	oreftimer = .NULL.
	Visible = .F.
	Width = 200
	
	PROCEDURE about
		Text
		如果你使用的是 Vfp6 版本，在运行示例前，请先进行如下步骤：
		项目 -> 连编 -> 重新连编项目 -> 连编所有文件 -> 确定。
		
		如果你使用的是 Vfp9 版本，在运行示例前，请先进行如下步骤：
		项目 -> 连编 -> 重新连编项目 -> 连编所有文件 -> 确定。
		
		如果你使用的不是 vfp6 或 vfp9 的 vfp 版本，我不确定，不过你可试一下。
		项目 -> 连编 -> 重新连编项目 -> 连编所有文件 -> 确定。
		
		*-- vfp6 须知：
		因本人能力范围内，vfp6 无法象 vfp9 那样放置到表单上即可使用，需要做以下步骤。
		1. 需要在表格的 AfterRowColChange 中执行本实例的 ev_AfterRowColChange
		2. 需要在表格的 Scrolled 中执行本实例的 ev_Scroled
		3. 需要在表格的 MouseDown 中执行本实例的 ev_MouseDown
		4. 需要在表格的 MouseUp 中执行本实例的 ev_MouseUp
		5. 需要在表格的 Valid 中执行本实例的 ev_Valid
		6. 需要在表单的 LostFocus 中执行本实例的 ev_FormLostFocus
		
		Ver 2.0 新增功能
		
		1. 支持拆分表格
		2. 支持锁定列(暂限 vfp9)
		3. 增加支持 VFP9 的示例
		4. 支持自定义拆并组
		--- 2008-04-28
		Fix3-1: 修复当指定 nMinLock 时，可以将列拖入 nMinLock 范围内，并且置换出期望不被改变位置的列。但由程序发出 HeaderSwap() 不受此限
		
		--- 2008-04-21
		Add2-1: 增加 nMinLock，最小锁定列数，防止锁定列被误解锁。但由程序发出 HeaderLock() 不受此限。
		Add2-2: 增加 lAlignment ，允许读取 Column.Header 的 Alignment 设置。
		Add2-3: 双击列宽调整条自动列宽
		
		Fix2-2: 修复拆分到至表格最右端不是对象的问题。
		Fix2-2: 修复双击列宽调整条的 AutoFit 
		Fix2-3: 修复当派生 ManyHeader 后，反复加载派生出来的不同样式的表头在切换时会挂掉。
		Fix2-4: 修复当表格选定行不可视时，表单离开焦点，表头消失的问题。
		Fix2-5: 修复列宽调整条位置错误
		Fix2-6: 修复虽然锁定组的左列，同时将组其他列隐藏时无法取消把组从锁中撤销的问题。
		--- 2008-04-20
		Fix1-1: 修复大范围锁定列时数组溢出
		Fix1-2: 修复 Vfp9 SP2 表头不能滚动的问题（SP1 未测试，也许会变成它不行了）
		Fix1-3: 修复 dkfdtf 提到的双击表格左上四方块的 AutoFit 问题
		
		重要:
			一、被绘制的表格对象它的每一个 Column 将会被新增两个属性 nIndex, aRefHeaders。
				如果你的表格列有使用到这两个属性之一，你将不能正常使用这个类或者你的程序。
			二、当表格被 SplitBar 拆分后，表格的同层容器将会添加一个本类的实例对象。
			三、表格所在的表单将会被新增一个名为 __UnLockScreen 的对象。
				如果你的表单使用到这个名称的对象，你将不能正常使用这个类或者你的程序。
			四、每一个标头的 LineTop、LineBottom、LineLeft、LineRight、Header1 成员皆可自由设置属性，以便组合出各种不同表格效果
		
		等待解决的问题:
			* 一、表格不能进行拆分 pass
			* 二、表格不能锁列 pass
			* 三、跨栏锁定组某个列时有问题 pass
			四、表格在水平滚动条单击时将锁屏，因此无法拖动水平滚动，也无法及时显示水平拖动的状态
			* 五、运行时用户自定义拆并组及保存配置 Pass
			六、锁右列
			七、Grid.AllowCellSelection = .F. 时必须要随便写一行 Valid 事件的问题。
			八、考虑使用 Skin 的方案
			九、？？拆分后再取消拆分，表头似乎消失了
		
		约定:
			*-- 以下文本所指的 ManyHeader 总是指放置在表单的本类派生对象名
			*-- 以下文本所指的 Grid 总是指与本类派生对象 HeaderInit 后绑定的表格对象
			*-- 以下文本所指的 Column? 总是指表格的 Column 列
			*-- 以下文本所指的 ColumnOrder 总是指 Column 的 ColumnOrder 属性
			*-- 以下文本所指的 Header 总是指 ManyHeader 中的标头成员
			*-- 以下文本所指的 Form 总是指放放置 ManyHeader 与 Grid 表单对象
		说明:
			*-- 当组内的所有列都不可移动时，组标头也不可移动
			*-- 当组内的所有列都不可调整大小时，组标头也不可调整大小
			*-- 调整组标头大小时，总是均分宽度到可调整大小的组内列成员上，无法均分的余数被加到最后一列。
		
			*-- 属性说明：
			nMinLock
			*-- 最小锁定列，锁定控制不能解除小于该列的锁。
			*-- 注1：由程序指令发出的 HeaderLock(0) 并不受此限制
			lAlignment
			*-- 是否使用 Column.Header.Alignment 设置。默认为 .F.。
			nDeleteMask
			*-- 常量，指出表格的 DeleteMask 占用的宽度
			nRecordMask
			*-- 常量，指出表格的 RecordMask 占用的宽度
			nTopOffset
			*-- 顶部偏移，如果表格另有其他外观效果，允许标头按此值往下移动，可以是正负值
			nLeftOffset
			*-- 左边偏移，如果表格另有有其他外观效果，允许标头按此值调宽 Left 与 Width，可以是正负值
			nRef
			*-- 说明这个标头是表格对象的第几个实例标头，通常用于对 Column.aRefHeaders[nRef] 中的存取（只读）。
			*-- 注1: 第一个实例对象，nRef 为 1.
			*-- 注2: 每一个实例对象被拆分后，nRef 为 2.
			nPanel 
			*-- 指出链接拆分表格的哪一边，0 = 右，1 = 左（默认）
			lSplitBar
			*-- 表格拆分时，是否自动拆分。默认为 .T.，但自动拆分的表头将不响应用户事件
			*-- 表格需要拆分并分别响应事件时，该值必须为 .F.，并且在表格的同层容器内放置两个 ManyHeader
			oRefGrid
			*-- 指向 InitHeader 中指定的表格对象（只读）
			oRefPanel
			*-- 当表格自动拆分时，这里将指向被拆分的标头（只读）
			*-- 注1：被拆分的表格同样也自动具有 oRefPanel 指向。大意如下：A -> B -> A
			oRefControl
			*-- 指向额外附加的工具组（只读）
		
			*-- 方法说明：
			InitHeader(oGrid)
			*-- 说  明: 初始化表头对象，表格与本类派生的实例对象必须属于同一对象层上
			*-- 参  数:
				* oGrid		与本类实例对象同一对象容器层的表格对象
			*-- 返回值: 无。
			MergeHeader(nStart, nEnd, "cCaption")
			*-- 说  明:	合并表格列做为一个新组标头，nStart 与 nEnd 均指表格的 ColumnOrder。
			*-- 参  数:
				* nStart	合并组的起始列，指 Grid.Column.ColumnOrder
				* nEnd 		合并组的终止列，指 Grid.Column.ColumnOrder
				* cCaption	合并组的标题名
			*-- 返回值: 该组列标头对象
			*-- 注1: 如果指定的范围内有任一列己是组成员，新组将拥有这个对象，而对象的原组将失去这个成员。
			*-- 注2: 如果新组成员不属于任何组，表格 ColumnOrder 保持不变。
			*-- 注3: 如果新组的成员属于某一个组，并且是左列或者右列，那么在原组的最左或者最右边创建新组，表格 ColumnOrder 保持不变。
			*-- 注4: 如果新组的成员属于某一个组，并且不是左列或者右列，那么在原组的最左边创建新组，表格 ColumnOrder 被自动调整
			*-- 注5: 在准备 MergeHeader 时，不要有任何变量指向合并范围内的标头对象，该对象可能会在 MergeHeader 后被释放。
			*-- 注5: 虽然普通标头永远不会被释放，但是其属性信息己立即发生变化，再对其操作会引发意外。
		
			GetHeaderLeft(oHeader)
			*-- 说  明:	获取 toHeader 左邻标头对象，如果对象 Visible = .F. 表示该对象不可视
			*-- 参  数:
				* oHeader		标头对象
			*-- 返回值: 对象或者 NULL
			GetHeaderRight(oHeader)
			*-- 说  明:	获取 toHeader 右邻标头对象，如果对象 Visible = .F. 表示该对象不可视
			*-- 参  数:
				* oHeader		标头对象
			*-- 返回值: 对象或者 NULL
			GetColumn(nColumnOrder)
			*-- 说  明:	获取指定表格 Column 对象
			*-- 参  数:
				* nColumnOrder		表格的 ColumnOrder 序。
			*-- 返回值: 对象
			*-- 注1:通过返回的对象的 aRefHeaders[nRef] 指向对应的标头
			*-- 注2:通过标头的 oRefup 属性指向其组标头
			HeaderRedraw()
			*-- 说  明: 重画标头内对象
			*-- 返回值: 无
			HeaderResize()
			*-- 说  明: 重画标头位置及大小，一般在表格改变大小与改变位置时使用
			*-- 返回值: 无
			HeaderDelete(<oHeader|nColumnOrder>)
			*-- 说  明: 从组标头删除一个成员
			*-- 参  数:
				* oHeader|nColumnOrder		组标头成员对象或者指定 ColumnOrder 
			*-- 返回值: 无
			*-- 注1: 如果指定的标头是组中最左或者最右列，则删除后表格的 ColumnOrder 不变化。
			*-- 注2: 如果指定的标头不是组中的最左列或者最右列，则该列往右移，做为组的左邻对象
			*-- 注3: 如果组删除组后只剩下一个组成员，则该组标头自动被删除
			HeaderSwap(oHeaderA, oHeaderB)
			*-- 说  明: 将指定的两个标头交换 ColumnOrder 位置
			*-- 参  数:
				* oHeaderA		指定标头A
				* oHeaderB		指定标头B
			*-- 注 1: 如果 oHeaderA 或者 oHeaderB 是普通成员，直接对调
			*-- 注 2: 如果 oHeaderA 或者 oHeaderB 是同组成员，直接对调
			*-- 注 3: 如果 oHeaderA 或者 oHeaderB 是组标头或者都是不同组的成员，则整个组都会对调。
			HeaderLock(nVal)
			*-- 说  明:从表格当前的 LeftColumn 起，往右锁定 tnVal 段列
			*-- 参  数:nVal
				* 将要锁定的列数
			*-- 注1: 当锁定后，LeftColumn 之前的列将被移到锁定标头右端
			*--	注2: vfp9 默认使用 LockColumns 或 LockColumnsLeft
		
			*-- 事件说明
			OnClick(oHeder)
			*-- 标头鼠标左键单击事件
			*-- 参数
				* oHeader 	为发生该事件标头实例对象
			*-- 注1: 默认执行表格原 Column.Header 对应事件。在此事件的自定义代码将覆盖默认事件。
			OnRightClick(oHeder)
			*-- 标头鼠标右键单击事件
			*-- 参数
				* oHeader 	为发生该事件标头实例对象
			*-- 注1: 默认执行表格原 Column.Header 对应事件。在此事件的自定义代码将覆盖默认事件。
			OnDblClick(toHeder)
			*-- 标头鼠标左键双击事件
			*-- 参数
				* toHeader 	为发生该事件标头实例对象
			*-- 注1: 默认执行表格原 Column.Header 对应事件。在此事件的自定义代码将覆盖默认事件。
			OnDrag(oHeder, nType)
			*-- 完成一次拖放后，发生此事件
			*-- 参数
				* oHeader 	为发生该事件标头实例对象
				* nType		移动类型，0 列左移，1 列右移
			OnStyle(oHeader, oColumnHeader)
			*-- 创建一个标头后发生此事件
			*-- 参数
				* oHeader 			为发生该事件标头实例对象
				* oColumnHeader		表格相应列标头的实例对象
			*-- 注1: 该事件有默认设置代码，在此事件的自定义代码将覆盖默认事件。
			*-- 注2: 标头 oHeader 成员说明
			*-- 	oHeader.Header1 		Label 对象，除了 Name 全部属性可设置。
			*-- 	oHeader.LineTop 		Line 对象，除了 Name 全部属性可设置。
			*-- 	oHeader.LineBottom 		Line 对象，除了 Name 全部属性可设置。
			*-- 	oHeader.LineLeft 		Line 对象，除了 Name 全部属性可设置。
			*-- 	oHeader.LineRight 		Line 对象，除了 Name 全部属性可设置。
			*-- 注3: Header1、LineTop、LineLeft 在每一次 HeaderRedraw 时都会再次设整其 Left, Top, Width, Height
			*-- 注4: 表格对象每一次滚动都会执行 HeaderRedraw
			OnResize(oHeader)
			*-- 当一个标头发生 Resize 事件后触发此事件
			*-- 参数
				* oHeader 			为发生该事件标头实例对象
			*-- 注: 一般用于自定义表头风格时使用
		
			*-- 原表格列 Column 新增属性说明
			Column.nIndex		数值，表格列顺序号
			Column.aRefHeaders 	数组对象引用，指向与其相对应的列标头。
								当一个表格与多个表头绑定时，aRefHeaders 维数将递增
		
			*-- 子对象标头 Header 属性说明
			*-- Header 对象为一个容器对象，设置其属性有效
			Header.nType 		数值型，标头类型 0 普通，1 组内标头，2 组标头
			Header.lMovable 	逻辑型，列是否可移动，默认取表格列的 Movable 值
			Header.lResizable 	逻辑型，列是否可调整大小，默认取表格列的 Resizable 值
			Header.nMegeCount 	数值型，标头组的成员数。
			Header.oRefup		对象引用，用于组内成员指向它的组标头，组标头与普通标头此值为 NULL
			Header.aRefColumns 	数组对象引用，枚举该标头相对于表格的 Column 成员，对于组标头，会有多个成员。
			*-- 子对象标头 Header 方法说明
			Header.HeaderSort(0|1)
			*-- 说   明: 只有组标头可用，对组成员按目前的 ColumnOrder 排序
			*-- 参   数:
				* 0			升序
				* 1			降序
			*-- 在移动标头时，会频繁地调整成员顺序，为确保顺序是期望的，请在枚举成员时对其进行排序
		
		
			其他......
			*-- 事件中 toHeader 关于标头类型的判定
			Do Case
			Case toHeader.nType = 0
				*-- 对象是普通标头
			Case toHeader.nType = 1
				*-- 对象是组内标头
			Case toHeader.nType = 2
				*-- 对象是组标头
			EndCase
		
		
			1. InitHeader 后普通标头的名称与表格列同名，可以使用与原表格列同名的对象来引用这个标头内的对象，并设置其属性。
				Samples: 
					Form.ManyHeader.Column1.Header1.Caption = "新的名称"
					Form.ManyHeader.Column1.BackColor = Rgb(255, 0, 0)
		
			2. 表格每一列新增的 oRefHeader 将指向本类中与其相对应的对象。
				Samples: 
					Form.Grid.Column1.oRefHeader.Caption = "新的名称"
					Form.Grid.Column1.oRefHeader.BackColor = Rgb(255, 0, 0)
		
			3. 组名称总是用 Sys(2015) 随机生成，如果你未保存合并组后返回对象，那么只能使用其组成员的 oRefup 来找到这个列对象。
				Samples:
					lo = Form.ManyHeader.MergeHeader(1, 2, "新的合并")
					lo.Caption = "新的合并2"
					以下是等价操作:
					Form.ManyHeader.Column1.oRefup.Caption = "新的合并2"
					以下是等价操作:
					Form.Grid.Column1.aRefHeaders[1].oRefup.Caption = "新的合并2"
					
			4. 通过枚举合并组的 aRefColumns 数组可获取被它合并的所有列对象
				Samples:
					For Each loColumn In Form.ManyHeader.Column1.oRefup.aRefColumns
						? loColumn.ControlSource
					EndFor
		
			5. 通过枚举表格列 aRefHeaders 数组可获取与列相对应的标头成员
				Samples:
					For Each lo In Form.Grid.Column1.aRefHeaders
						? lo.Caption = "更改所有标头的标题"
					EndFor
			6. 你可以在运行时更改表格 Column 对象的名称，但这个类对应的名称不会更改。
			7. 本类暂时不能在运行时新增、删除列。如果有此类情况，请重新 HeaderInit()。
		EndText
	ENDPROC

	PROCEDURE bindevents		&& 绑定表格对象的属性
		*-- 支持 BindEvents 的 vfp 版本取消注释与添加 BindEvent
		
		#If Version(5) > 600
			BindEvent(ThisForm, "LostFocus", This, "ev_FormLostFocus")
		
			BindEvent(This.oRefGrid, "AfterRowColChange", This, "Ev_AfterRowColChange")
			BindEvent(This.oRefGrid, "MouseDown", This, "Ev_MouseDown")
			BindEvent(This.oRefGrid, "MouseUp", This, "Ev_MouseUp")
			BindEvent(This.oRefGrid, "KeyPress", This, "Ev_KeyPress")
			BindEvent(This.oRefGrid, "Scrolled", This, "Ev_Scrolled")
			BindEvent(This.oRefGrid, "Valid", This, "Ev_Valid")
			BindEvent(This.oRefGrid, "Resize", This, "HeaderResize")
			BindEvent(This.oRefGrid, "Moved", This, "HeaderResize")
			BindEvent(This.oRefGrid, "AutoFit", This, "HeaderRedraw", 1)
		#EndIf
		
		*!*	If This.nVfpVer > 600
		*!*		BindEvent(ThisForm, "LostFocus", This, "ev_FormLostFocus")
		
		*!*		BindEvent(This.oRefGrid, "AfterRowColChange", This, "Ev_AfterRowColChange")
		*!*		BindEvent(This.oRefGrid, "MouseDown", This, "Ev_MouseDown")
		*!*		BindEvent(This.oRefGrid, "MouseUp", This, "Ev_MouseUp")
		*!*		BindEvent(This.oRefGrid, "KeyPress", This, "Ev_KeyPress")
		*!*		BindEvent(This.oRefGrid, "Scrolled", This, "Ev_Scrolled")
		*!*		BindEvent(This.oRefGrid, "Valid", This, "Ev_Valid")
		*!*		BindEvent(This.oRefGrid, "Resize", This, "HeaderResize")
		*!*		BindEvent(This.oRefGrid, "Moved", This, "HeaderResize")
		*!*		BindEvent(This.oRefGrid, "AutoFit", This, "HeaderRedraw", 1)
		*!*	EndIf
		
		
		*!*	在nFlags 位 事件类型 说明 
		*!*	0
		*!*	 000
		*!*	 FoxPro 对象
		*!*	 在事件代码之前调用代理代码。(默认)
		*!*	 
		*!*	1
		*!*	 001
		*!*	 FoxPro 对象
		*!*	 在代理代码之前调用事件代码。
		*!*	 
		*!*	2
		*!*	 010
		*!*	 FoxPro 对象
		*!*	 通过简单方式调用，不触发事件(调用代理代码)。
		*!*	 
		*!*	31
		*!*	 011
		*!*	 FoxPro 对象
		*!*	 在代理代码之前调用事件代码。当简单方式调用发生时，不触发事件(调用代理代码)。
		*!*	 
		*!*	4
		*!*	 100
		*!*	 Windows Message
		*!*	 当用户事件代码在执行时，防止类似事件的递归。
	ENDPROC

	HIDDEN PROCEDURE controlcreate		&& 创建表头额外的控制
		#If Version(5) > 600
		If This.lLock
			This.NewObject(Sys(2015), "_do_Controls", This.ClassLibrary)
			This.oRefControl = This.Controls(This.ControlCount)
			This.oRefControl.Move(0, 0)
			This.oRefControl.Visible = .T.
			If This.ControlCount - 1 > 0
				This.HeaderRedraw()
			EndIf
		EndIf
		#EndIf
	ENDPROC

	PROCEDURE controldestory		&& 锁毁额外的表头控制
		If Not IsNull(This.oRefControl)
			This.RemoveObject(This.oRefControl.Name)
			This.oRefControl = NULL
		EndIf
		
		
	ENDPROC

	PROCEDURE Destroy
		Private loColumn, lnRef, lnMax
		Local loColumn, lnRef, lnMax
		
		If Not IsNull(This.oRefGrid) And VarType(This.oRefGrid) = "O"
			#If Version(5) > 600
				UnBindEvent(ThisForm, "LostFocus", This, "ev_FormLostFocus")
		
				UnBindEvent(This.oRefGrid, "AfterRowColChange", This, "Ev_AfterRowColChange")
				UnBindEvent(This.oRefGrid, "MouseDown", This, "Ev_MouseDown")
				UnBindEvent(This.oRefGrid, "MouseUp", This, "Ev_MouseUp")
				UnBindEvent(This.oRefGrid, "KeyPress", This, "Ev_KeyPress")
				UnBindEvent(This.oRefGrid, "Scrolled", This, "Ev_Scrolled")
				UnBindEvent(This.oRefGrid, "Valid", This, "Ev_Valid")
				UnBindEvent(This.oRefGrid, "Resize", This, "HeaderResize")
				UnBindEvent(This.oRefGrid, "Moved", This, "HeaderResize")
				UnBindEvent(This.oRefGrid, "AutoFit", This, "HeaderRedraw")
			#EndIf
		
			loColumn = This.oRefGrid.Columns(1)
			lnRef = This.nRef
			lnMax = ALen(loColumn.aRefHeaders) - 1
			loColumn = NULL
			For Each loColumn In This.oRefGrid.Columns
				*-- 只能是数组中的最后一个成员才删除，防止数组递升
				*-- 但不能防止表头卸掉、加载、卸掉、加载如此重复……
				If m.lnRef = m.lnMax
					ADel(loColumn.aRefHeaders, m.lnRef)
					Dimension loColumn.aRefHeaders[m.lnMax]
				Else
					loColumn.aRefHeaders[m.lnRef] = NULL
				EndIf
			EndFor
			This.oRefGrid = NULL
		EndIf
	ENDPROC

	PROCEDURE ev_afterrowcolchange		&& 表格的 AfterRowColChange  事件
		LPARAMETERS nColIndex
		
		Private lnLeftColumn, llLockScreen
		Local lnLeftColumn, llLockScreen 
		
		*-- 绑定表格的 AfterRowColChange  滚动事件，vfp6 下需手工指定
		If Not VarType(This.oRefGrid) = "O" Or IsNull(This.oRefGrid)
			Return
		EndIf
		
		llLockScreen = ThisForm.LockScreen
		ThisForm.LockScreen = .T.
		
		Do Case
		Case This.oRefGrid.Panel = This.nPanel
			lnLeftColumn = This.GetLeftColumn()
			If m.lnLeftColumn <> This.nLeftColumn
				This.nLeftColumn = m.lnLeftColumn
				This.HeaderLockEx()
				This.HeaderRedraw()
			EndIf
		
		Case Not IsNull(This.oRefPanel)
			lnLeftColumn = This.oRefPanel.GetLeftColumn()
			If m.lnLeftColumn <> This.oRefPanel.nLeftColumn
				This.oRefPanel.nLeftColumn = m.lnLeftColumn
				This.oRefPanel.HeaderLockEx()
				This.oRefPanel.HeaderRedraw()
			EndIf
		EndCase
		
		ThisForm.LockScreen = m.llLockScreen
		
	ENDPROC

	PROCEDURE ev_formlostfocus		&& 当离开表单时发生此事件
		If Not IsNull(This.oRefGrid) And VarType(This.oRefGrid) = "O"
			This.oRefGrid.Refresh()
			This.HeaderRedraw()
		EndIf
	ENDPROC

	PROCEDURE ev_keypress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		If Not IsNull(This.oRefGrid) And Not This.oRefGrid.AllowCellSelection
			This.UnLockScreen()
		EndIf
		
		
		
	ENDPROC

	PROCEDURE ev_mousedown		&& 表格的 MouseDown 事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*-- 绑定表格的 MouseDown 滚动事件，vfp6 下需手工指定
		
		Private lnWhere_Out
		Local lnWhere_Out
		
		If Not VarType(This.oRefGrid) = "O" Or IsNull(This.oRefGrid)
			Return
		EndIf
		
		lnWhere_Out = 0
		This.oRefGrid.GridHitTest(m.nXCoord, m.nYCoord, @lnWhere_Out)
		This.nWhere_Out = m.lnWhere_Out
		
		Do Case
		Case m.lnWhere_Out = 11 	&& 左上四方块
			If Second() <= This.nClickSecond + _DblClick
				This.nClickSecond = Iif(ThisForm.LockScreen = .F., -1, -2)
				ThisForm.LockScreen = .T.
			Else
				This.nClickSecond = Second()
			EndIf
		
		Case m.lnWhere_Out = 5 ;	&& 表格拆分条
		Or m.lnWhere_Out = 13 ;		&& 标头高度调整
		Or m.lnWhere_Out = 16 		&& 水平滚动条
			This.UnLockScreen()
		
		EndCase
	ENDPROC

	PROCEDURE ev_mouseup		&& 绑定表格的 MouseUp 事件
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		*!*	5 拆分条，左底端那个小黑块
		*!*	6 删除条 DeleteMask
		*!*	11 左顶端上的那个四方形？
		*!*	12 记录指示条 RecordMask
		*!*	13 表头高度调整条
		*!*	16 水平滚动条
		*!*	17 垂直滚动条
		
		Private llLokScreen
		Local llLockScreen
		
		If This.lMaster
			llLockScreen = ThisForm.LockScreen
			ThisForm.LockScreen = .T.
		
			If InList(This.nWhere_Out, 5, 11, 13)
				This.HeaderResize()
		
				If This.oRefGrid.Partition > 0
					If Not IsNull(This.oRefPanel)
						This.oRefPanel.HeaderResize()
					EndIf
				Else
					This.PanelDestroy()
				EndIf
			EndIf
		
			Do Case
			Case This.nClickSecond >= 0
				ThisForm.LockScreen = m.llLockScreen
			Case This.nClickSecond = -2
				*-- 双击了左上四方块
				ThisForm.LockScreen = .T.
			Otherwise
				ThisForm.LockScreen = .F.
			EndCase
		EndIf
		
		
	ENDPROC

	PROCEDURE ev_scrolled		&& 表格滚动事件
		LPARAMETERS nDirection
		
		*-- 绑定表格的 Scrolled 滚动事件，vfp6 需要手工指定
		
		If Not VarType(This.oRefGrid) = "O" Or IsNull(This.oRefGrid)
			Return
		EndIf
		
		If VarType(m.nDirection) = "N" And m.nDirection >= 4
			Do Case
			Case This.oRefGrid.Panel = This.nPanel
				This.nLeftColumn = This.GetLeftColumn()
				This.HeaderLockEx()
				This.HeaderRedraw()
		
			Case Not IsNull(This.oRefPanel)
				This.oRefPanel.nLeftColumn = This.oRefPanel.GetLeftColumn()
				This.oRefPanel.HeaderLockEx()
				This.oRefPanel.HeaderRedraw()
		
			EndCase
		EndIf
	ENDPROC

	PROCEDURE ev_valid		&& 表格的 GridValid 事件
		
		*-- 绑定表格的 Valid 滚动事件，vfp6 下需手工指定
		
		This.UnLockScreen()
	ENDPROC

	PROCEDURE getcolumn		&& 返回指定索引号的表格列对象。
		LPARAMETERS tnOrder
		
		*-- 返回表格列对象
		*-- 参数
			* tnOrder 		指定表格的 ColumnOrder 
		*-- 返回值
			* 对象值 		对应 ColumnOrder 的 Column 对象
		
		Return This.oRefGrid.Columns(AScan(This.aColumn, m.tnOrder))
		
	ENDPROC

	PROCEDURE getcolumnheader		&& 获取指定表格列对象的 Header 对象
		LPARAMETERS toColumn
		*-- 
		*-- 返回 Column 对象的 Header 对象
		*-- 参数
			* toColumn 	表格 Column 对象
		*-- 返回值
			* toColumn.Header 对象
		
		Private loHeader
		Local loHeader
		For Each m.loHeader In toColumn.Controls
			If Upper(m.loHeader.BaseClass) = "HEADER"
				Return m.loHeader
			EndIf
		EndFor
		
		Return NULL
		
	ENDPROC

	PROCEDURE getcolumnvisible		&& 修正 ObjToClient 在 Vfp9 sp2 下的问题。
		LPARAMETERS toColumn
		
		*-- 
		*-- 关于列锁定后被隐藏：
		*-- vfp 之  前  ObjToClient(m.toColumn, 2) = 0
		*-- vfp sp2 中 ObjToClient(m.toColumn, 2) = ObjToClient(m.Grid, 2)
		*-- 
		
		If toColumn.Visible 
			If m.toColumn.ControlCount > 0
				Return ObjToClient(m.toColumn.Controls(1), 2) > 0
			Else
				Return Not ObjToClient(m.toColumn, 2) = ObjToClient(m.toColumn.Parent, 2)
			EndIf
		Else
			If Not Version(6) > 600
				Return .T.
			Else
				Return .F.
			EndIf
		EndIf
		
		*!*	If toColumn.Visible And ObjToClient(m.toColumn.Controls(1), 2) > 0
		*!*		Return .T.
		*!*	Else
		*!*		Return .F.
		*!*	EndIf
		
	ENDPROC

	PROCEDURE getgridcolumn		&& 获取表格列信息。数组行对应 Order，值对应 Column(lnIndex) 值。
		*-- 保存表格列 Columns(Index) 与 Column. ColumnOrder 的对应关系
		*-- 通过检索 ColumnOrder 获取 Columns(Index) 的 Index 值，从而确定列对象
		*-- 数组行表示 ColumnOrder 
		*-- 数组值表示 Columns(nIndex)
		
		Private lnIndex, loGrid
		Local lnIndex, loGrid
		
		loGrid = This.oRefGrid
		If loGrid.ColumnCount > 0
			Dimension This.aColumn[loGrid.ColumnCount]
			For m.lnIndex = 1 To loGrid.ColumnCount
				This.aColumn[m.lnIndex] = loGrid.Columns(m.lnIndex).ColumnOrder
			EndFor
		Else
			Dimension This.aColumn[1]
			This.aColumn = NULL
		EndIf
	ENDPROC

	PROCEDURE getgroupmax		&& 获取组中最大 ColumnOrder
		LPARAMETERS toHeader
		
		*-- 获取一个组标头中最大 ColumnOrder
		*-- 参数
			* toHeader 	标头组对象
		*-- 返回值
			* 数值		标头组对象最大的 ColumnOrder，
		*-- 注：可由 GetColumn(GetGroupMax()) 返回表格列
		
		*!*	Return toHeader.aRefColumns[toHeader.nMergeCount].ColumnOrder
		
		Private lnMaxOrder, loColumn
		Local lnMaxOrder, loColumn
		
		lnMaxOrder = 0
		For Each loColumn In toHeader.aRefColumns
			lnMaxOrder = Max(loColumn.ColumnOrder, m.lnMaxOrder)
		EndFor
		
		Return m.lnMaxOrder
	ENDPROC

	PROCEDURE getgroupmin		&& 获取组中最小 ColumnOrder
		LPARAMETERS toHeader
		
		*-- 获取一个组标头中最小 ColumnOrder
		*-- 参数
			* toHeader 	标头组对象
		*-- 返回值
			* 数值		标头组对象最小的 ColumnOrder，
		*-- 注：可由 GetColumn(GetGroupMin()) 返回表格列
		
		*!*	Return toHeader.aRefColumns[1].ColumnOrder
		
		Private lnMinOrder, loColumn
		Local lnMinOrder, loColumn
		
		lnMinOrder = This.oRefGrid.ColumnCount
		For Each loColumn In toHeader.aRefColumns
			lnMinOrder = Min(loColumn.ColumnOrder, lnMinOrder)
		EndFor
		
		Return m.lnMinOrder
	ENDPROC

	PROCEDURE getheaderleft		&& 获取指定标头的左邻 Header
		LPARAMETERS toHeader
		
		*-- 获取指定标头的左邻标头，该对象可能 Visible = .F.
		*-- 参数
			* toHeader 		本类实例化标头对象
		*-- 返回值
			* NULL 或者 toHeader 左邻的标头对象
		*-- 注：对于组标头，左邻对象只能是组内对象，返回对象有可能 Visible = .F.
		
		Local loColumn, lnMinOrder, loHeader
		
		Do Case
		Case toHeader.nType = 0
		*-- 对象是普通标头
			If toHeader.aRefColumns[1].ColumnOrder = 1
				Return NULL
			EndIf
		
			loColumn = This.GetColumn(toHeader.aRefColumns[1].ColumnOrder - 1)
			loHeader = This.GetRefHeader(m.loColumn)	
			If Not IsNull(loHeader.oRefup)
				Return loHeader.oRefup
			Else
				Return m.loHeader
			EndIf
		
		Case toHeader.nType = 1
		*-- 对象是组内标头
			lnMinOrder = This.GetGroupMin(toHeader.oRefup)
			If m.lnMinOrder = toHeader.aRefColumns[1].ColumnOrder
				Return NULL
			Else
				loColumn = This.GetColumn(toHeader.aRefColumns[1].ColumnOrder - 1)
				Return This.GetRefHeader(m.loColumn)
			EndIf
		
		Case toHeader.nType = 2
		*-- 对象是组标头
			lnMinOrder = This.GetGroupMin(m.toHeader)
			If m.lnMinOrder = 1
				Return NULL
			Else
				loColumn = This.GetColumn(m.lnMinOrder - 1)
				loHeader = This.GetRefHeader(m.loColumn)
				If Not IsNull(loHeader.oRefup)
					Return loHeader.oRefup
				Else
					Return loHeader
				EndIf
			EndIf
		
		Otherwise
			Messagebox(ManyHeader_GetHeaderLeft_1 + Transform(toHeader.nType) + " ?", 64)
			* Messagebox("错误的 nType 值 " + Transform(toHeader.nType) + " ？", 16)
		
		EndCase
	ENDPROC

	PROCEDURE getheaderright		&& 获取指定标头对象的右邻 Header
		LPARAMETERS toHeader
		
		*-- 获取指定标头的右邻标头，该对象可能 Visible = .F.
		*-- 参数
			* toHeader 		本类实例化标头对象
		*-- 返回值
			* NULL 或者 toHeader 右邻的标头对象
		*-- 注：对于组标头，右邻对象只能是组内对象，返回对象有可能 Visible = .F.
		
		Local loColumn, lnMaxOrder, loHeader
		
		Do Case
		Case toHeader.nType = 0
		*-- 对象是普通标头
			If toHeader.aRefColumns[1].ColumnOrder >= This.oRefGrid.ColumnCount
				Return NULL
			EndIf
		
			loColumn = This.GetColumn(toHeader.aRefColumns[1].ColumnOrder + 1)
			loHeader = This.GetRefHeader(m.loColumn)
			If Not IsNull(loHeader.oRefup)
				Return loHeader.oRefup
			Else
				Return m.loHeader
			EndIf
		
		Case toHeader.nType = 1
		*-- 组内标头
		
			lnMaxOrder = This.GetGroupMax(toHeader.oRefup)
			If m.lnMaxOrder = toHeader.aRefColumns[1].ColumnOrder
				Return NULL
			Else
				loColumn = This.GetColumn(toHeader.aRefColumns[1].ColumnOrder + 1)
				loHeader = This.GetRefHeader(m.loColumn)
				Return m.loHeader
			EndIf
		
		Case toHeader.nType = 2
		*-- 对象是组标头
			lnMaxOrder = This.GetGroupMax(m.toHeader)
			If m.lnMaxOrder >= This.oRefGrid.ColumnCount
				Return NULL
			Else
				loColumn = This.GetColumn(m.lnMaxOrder + 1)
				loHeader = This.GetRefHeader(m.loColumn)
				If Not IsNull(loHeader.oRefup)
					Return loHeader.oRefup
				Else
					Return m.loHeader
				EndIf
			EndIf
		
		Otherwise
			Messagebox(ManyHeader_GetHeaderLeft_1 + Transform(toHeader.nType) + " ?", 64)
			* Messagebox("错误的 nType 值 " + Transform(toHeader.nType) + " ？", 0, "GetHeaderRight")
		
		EndCase
		
	ENDPROC

	PROCEDURE getleftcolumn		&& 未锁列时，返回 Grid.LeftColumn，锁列时，返回锁列后面的第一个可见列。
		Private lnIndex, loColumn
		Local lnIndex, loColumn
		
		Do Case
		Case This.oRefGrid.Panel = 1
			If This.oRefGrid.LockColumns = 0
				Return This.oRefGrid.LeftColumn
			Else
				For lnIndex = This.oRefGrid.LockColumns + 1 To This.oRefGrid.ColumnCount
					loColumn = This.GetColumn(m.lnIndex)
					If This.GetColumnVisible(m.loColumn)
						Return m.lnIndex 
					EndIf
				EndFor
			EndIf
		
		Case This.oRefGrid.Panel = 0
			If This.oRefGrid.LockColumnsLeft = 0
				Return This.oRefGrid.LeftColumn
			Else
				For lnIndex = This.oRefGrid.LockColumnsLeft + 1 To This.oRefGrid.ColumnCount
					loColumn = This.GetColumn(m.lnIndex)
					If This.GetColumnVisible(m.loColumn)
						Return m.lnIndex 
					EndIf
				EndFor
			EndIf
		
		EndCase
		
		Return 0
		
	ENDPROC

	PROCEDURE getrefheader		&& 获取表格 Column 指向的标头对象
		LPARAMETERS toColumn
		
		Return toColumn.aRefHeaders[This.nRef]
	ENDPROC

	PROCEDURE headerclear		&& 清除标头
		*-- 清除标头所有对象
		
		*-- 清除标头所有对象
		
		Do While This.ControlCount > 0
			This.RemoveObject(This.Controls(1).Name)
		EndDo
		This.ControlCreate()
		*!*	Do While This.ControlCount > This.nInitControls
		*!*		This.RemoveObject(This.Controls(This.nInitControls + 1).Name)
		*!*	EndDo
	ENDPROC

	HIDDEN PROCEDURE headerdel		&& 内用。删除一个组内标头或者组标头，如果组内组中间，则该列变成组的右邻对象。
		LPARAMETERS tvHeader
		
		*-- 删除一个组标头或者组内成员
		*-- 参数
			* tvHeader 		组内标头对象或者一个组标头对象，或者指定一个 ColumnOrder
		*-- 返回值
			* 无
		*-- 说明：如果删除的是组内标头，则有下列两种情况
		*-- 1 如果删除的标头是位于组的最左或者最左标头，则该组的位置保持不变
		*-- 2 如果删除标头不是组的最左或者最右标头，则是先将该列移到最右端后再删除。
		
		
		Private loHeader, loRefColumn, loRefHeader, lnIndex, loRefup, loColumn, llMovable, llResizable, lnMinOrder, lnMaxOrder
		Local loHeader, loRefColumn, loRefHeader, lnIndex, loRefup, loColumn, llMovable, llResizable, lnMinOrder, lnMaxOrder
		
		Do Case
		Case VarType(m.tvHeader) = "N" And BetWeen(m.tvHeader, 1, This.oRefGrid.ColumnCount)
			loHeader = This.GetRefHeader(This.GetColumn(m.tvHeader))
		
		Case VarType(m.tvHeader) = "O"
			loHeader = m.tvHeader
		
		Otherwise
			Return
		
		EndCase
		
		Do Case
		*-- 普通成员
		Case m.loHeader.nType = 0
		
		*-- 对象是组内成员
		Case m.loHeader.nType = 1 And Not Isnull(m.loHeader.oRefup)
			loRefup = m.loHeader.oRefup
			If BetWeen(loRefup.nMergeCount, 1, 2)
				*-- 组内成员小于两个时，再删除一个成员该组己无意义了
				This.HeaderDel(m.loRefup)
			Else
				loRefColumn = loHeader.aRefColumns[1]
				loRefHeader = This.GetRefHeader(m.loRefColumn)
				*-- 删除组标头对 Column 的引用
				For lnIndex = 1 To loRefup.nMergeCount
					If loRefup.aRefColumns[m.lnIndex] = m.loRefColumn
						ADel(loRefup.aRefColumns, m.lnIndex)
						Exit For
					EndIf
				EndFor
				*-- 重置数组大小，并切断标头与组的关系
				loRefup.nMergeCount = loRefup.nMergeCount - 1
				Dimension loRefup.aRefColumns[loRefup.nMergeCount]
				loRefHeader.nType = 0
				loRefHeader.oRefup = NULL
		
				*-- 重置组的 Movable, Resizable
				llMoveable = .F.
				llResizable = .F.
				For Each loColumn In loRefup.aRefColumns
					llMovable = Iif(m.loColumn.Movable, .T., m.llMoveable)
					llResizable = Iif(m.loColumn.Movable, .T., m.llResizable)
				EndFor
				loRefup.lMovable = m.llMovable
				loRefup.lResizable = m.llResizable
		
				*-- 如果被删除的列不是最左列或最右列，从组中移到最右边
				lnMinOrder = This.GetGroupMin(m.loRefup)
				lnMaxOrder = This.GetGroupMax(m.loRefup)
				If BetWeen(loRefColumn.ColumnOrder, m.lnMinOrder + 1,  m.lnMaxOrder - 1)
					Do While loRefColumn.ColumnOrder < m.lnMaxOrder
						loRefColumn.ColumnOrder = loRefColumn.ColumnOrder + 1
					EndDo
					This.GetGridColumn()
				EndIf
			EndIf
		
		Case loHeader.nType = 2
		*-- 对象是组成员
			For Each loColumn In loHeader.aRefColumns
				loRefHeader = This.GetRefHeader(m.loColumn)
				loRefHeader.nType = 0
				loRefHeader.oRefup = NULL
			EndFor
			This.RemoveObject(loHeader.Name)
		EndCase
	ENDPROC

	PROCEDURE headerdelete		&& 删除一个组内标头或者组标头，如果组内组中间，则该列变成组的右邻对象。
		LPARAMETERS tvHeader
		
		*-- 删除一个组标头或者组内成员
		*-- 参数
			* tvHeader 		组内标头对象或者一个组标头对象，或者指定一个 ColumnOrder
		*-- 返回值
			* 无
		*-- 说明：如果删除的是组内标头，则有下列两种情况
		*-- 1 如果删除的标头是位于组的最左或者最左标头，则该组的位置保持不变
		*-- 2 如果删除标头不是组的最左或者最右标头，则是先将该列移到最右端后再删除。
		Private loColumn, loHeader
		Local loColumn, loHeader
		
		If This.lMaster And Not IsNull(This.oRefPanel)
			If VarType(m.tvHeader) = "O"
				If m.tvHeader.nType = 2
					loColumn = tvHeader.aRefColumns[1]
				Else
					loColumn = tvHeader.aRefColumns[1]
				EndIf
				loHeader = loColumn.aRefHeaders[This.oRefPanel.nRef]
				If tvHeader.nType = 2
					This.oRefPanel.HeaderDelete(loHeader.oRefup)
				Else
					This.oRefPanel.HeaderDelete(m.loHeader)
				EndIf
			Else
				This.oRefPanel.HeaderDelete(m.tvHeader)
			EndIf
			This.oRefPanel.HeaderRedraw()
		EndIf
		
		This.GetGridColumn()
		This.HeaderDel(m.tvHeader)
		This.HeaderRedraw()
		
	ENDPROC

	PROCEDURE headerlock		&& 从表格 LeftColumn 起，锁定表头指定列数
		LPARAMETERS tnVal
		
		*-- 从表格当前的 LeftColumn 起，往右锁定 tnVal 段列
		*-- 参数
			* tnVal 	锁定列数
		*-- 说明
			* 当锁定后，LeftColumn 之前的列将被移到被锁定列后右端
			* vfp9 调用 LockColumn
		Private laColumns
		Private lnPanel, loGrid, lnLock, lnOrder, loColumn, loHeader, lnIndex, lnLoop, loRightColumn, llLockScreen
		Local Array laColumns[1]
		Local lnPanel, loGrid, lnLock, lnOrder, loColumn, loHeader, lnIndex, lnLoop, loRightColumn, llLockScreen
		
		If IsNull(This.oRefGrid) ;
		Or VarType(This.oRefGrid) <> "O" ;
		Or This.nLock = m.tnVal ;
		Or IsNull(This.oRefControl)
			Return
		EndIf
		
		loGrid = This.oRefGrid
		lnPanel = loGrid.Panel
		loGrid.Panel = This.nPanel
		
		If Not IsNull(This.oRefControl)
			This.oRefControl.SetWidth(0)
		EndIf
		*-- 检查锁定范围的环境，不允许锁非组的左起连续列
		If Not This.HeaderLockCheck(m.tnVal)
			*-- 显示错误
			This.HeaderRedraw()
			Messagebox(ManyHeader_HeaderLock_1)
			* Messagebox("不能锁组标头的部份列，请将组展开后从组的最左列往右依次锁列。", 64, "信息")
			Return .F.
		EndIf
		
		llLockScreen = ThisForm.LockScreen
		ThisForm.LockScreen = .T.
		*-- 记录需要移动的标头
		lnLock = 1
		lnOrder = 0
		For lnIndex = loGrid.LeftColumn To loGrid.ColumnCount
			loColumn = This.GetColumn(m.lnIndex)
			If Not This.GetColumnVisible(m.loColumn)
				Loop
			EndIf
		
			lnOrder = lnOrder + 1
			Dimension laColumns[m.lnOrder]
			laColumns[m.lnOrder] = m.loColumn
			lnLock = m.lnLock + 1
			If m.lnLock > m.tnVal
				Exit For
			EndIf
		EndFor
		
		*-- 记录下右邻对象，在移动列完成后恢复原视图
		If loColumn.ColumnOrder <> loGrid.ColumnCount
			loRightColumn = This.GetColumn(loColumn.ColumnOrder + 1)
		Else
			loRightColumn = NULL
		EndIf
		
		*-- 最后一个成员是组内标头，必须加上其右邻标头
		loHeader = This.GetRefHeader(m.loColumn)
		If loHeader.nType = 1
			loHeader = This.GetHeaderRight(m.loHeader)
			Do While Not IsNull(loHeader)
				lnOrder = m.lnOrder + 1
				Dimension laColumns[m.lnOrder]
				laColumns[m.lnOrder] = loHeader.aRefColumns
				loHeader = This.GetHeaderRight(m.loHeader)
			EndDo
		EndIf
		
		lnLoop = 0
		*-- 将锁定组成员往左移
		For lnIndex = 1 To m.lnOrder
			loColumn = laColumns[m.lnIndex]
			Do While loColumn.ColumnOrder > m.lnIndex
				lnLoop = lnLoop + 1
				loColumn.ColumnOrder = loColumn.ColumnOrder - 1
			EndDo
		EndFor
		If This.nPanel = 1
			loGrid.LockColumns = Max(m.tnVal, 0)
		Else
			loGrid.LockColumnsLeft = Max(m.tnVal, 0)
		EndIf
		
		*--
		*-- 恢复表格视图，如此处理真是土得掉渣 ：（
		*--
		*-- 一直滚动到让该列可视，终点 ColumnCount 防止出现不可能有可视的情况
		If Not IsNull(m.loRightColumn) And m.tnVal > 0
			For lnIndex = 1 To loGrid.ColumnCount
				If This.GetColumnVisible(m.loRightColumn)
					Exit For
				EndIf
				loGrid.DoScroll(5)
			EndFor
			*-- 让列不可视
			For lnIndex = 1 To loGrid.ColumnCount
				If Not This.GetColumnVisible(m.loRightColumn)
					Exit For
				EndIf
				loGrid.DoScroll(5)
			EndFor
			If Not This.GetColumnVisible(m.loRightColumn)
				loGrid.DoScroll(4)
			EndIf
		EndIf
		
		*--
		*-- 完成，更新信息
		*-- 
		loGrid.Panel = m.lnPanel
		This.GetGridColumn()
		This.HeaderRedraw()
		
		*-- 更新链接对象
		If Not IsNull(This.oRefPanel)
			This.oRefPanel.GetGridColumn()
			This.oRefPanel.HeaderRedraw()
		EndIf
		
		ThisForm.LockScreen = m.llLockScreen
		This.nLock = m.tnVal
		This.OnLock(m.tnVal)
	ENDPROC

	HIDDEN PROCEDURE headerlockcheck		&& 检查锁环境
		LPARAMETERS m.tnVal
		
		Private loCurColumn, loColumn, loHeader, nLock, lnOrder
		Local loCurColumn, loColumn, loHeader, lnLock, lnOrder
		
		If m.tnVal > 0
		*-- 合并锁定组前检是组状态，不允许仅锁组的中间至右端的部份
			lnLock = 0
			lnOrder = 1
			Do While m.lnLock < m.tnVal And m.lnOrder < This.oRefGrid.ColumnCount
				loCurColumn = This.GetColumn(m.lnOrder)
				loHeader = loCurColumn.aRefHeaders[This.nRef]
		
				*-- 锁列后收起的普通列，不检查，不计入锁定列
				If m.loHeader.nType = 0 ;
				And Not This.GetColumnVisible(m.loCurColumn)
					m.lnOrder = m.lnOrder + 1
					Loop
				EndIf
		
				*-- 锁列后的可见普通列，计入锁定列
				If m.loHeader.nType = 0
					m.lnOrder = m.lnOrder + 1
					m.lnLock = m.lnLock + 1
					Loop
				EndIf
		
				*-- 准备检查组标头
				m.loHeader = m.loHeader.oRefup
				If Not m.loHeader.Visible 
					*-- 整组不可见，不检查
					m.lnOrder = m.lnOrder + m.loHeader.nMergeCount
					Loop
				EndIf
		
				*-- 对于一个可视的组标头，到达锁定列之前如果有列被隐藏，则组不能被锁
				m.loHeader.HeaderSort(0)
				For Each loColumn In loHeader.aRefColumns
					If m.lnLock > m.tnVal
						Return .T.
					EndIf
					If Not This.GetColumnVisible(m.loColumn)
						Return .F.
					EndIf
					m.lnOrder = m.lnOrder + 1
					m.lnLock = m.lnLock + 1
				EndFor
			EndDo
		EndIf
		
		Return .T.
	ENDPROC

	PROCEDURE headerlockex		&& Vfp6 列锁定的修复操作
		
		
		*-- 为 vfp6 准备
		
		Private loColumn
		Local loColumn
		
		If .F. And This.nLock > 0
			loColumn = This.oRefGrid.Column1
			Do Case
			Case loColumn.ColumnOrder < This.nLeftColumn
				Do While loColumn.ColumnOrder < This.nLeftColumn
					loColumn.ColumnOrder = loColumn.ColumnOrder + 1
				EndDo
				This.GetGridColumn()
		
			Case loColumn.ColumnOrder > This.nLeftColumn
				Do While loColumn.ColumnOrder > This.nLeftColumn
					loColumn.ColumnOrder = loColumn.ColumnOrder - 1
				EndDo
				This.GetGridColumn()
		*!*			loColumn = This.GetColumn(This.nLeftColumn + 1)
		*!*			loColumn.SetFocus()
			EndCase
		
		EndIf
	ENDPROC

	PROCEDURE headerredraw		&& 按照表格信息，重画表格
		Private loLockup, lnIndex, loColumn, loHeader, lnLeft, lnTop, lnWidth, lnHeight, llLockScreen, lnPanel
		Local loLockup, lnIndex, loColumn, loHeader, lnLeft, lnTop, lnWidth, lnHeight, llLockScreen, lnPanel
		
		*-- 重画表头
		If Not VarType(This.oRefGrid) = "O" Or IsNull(This.oRefGrid)
			Return
		EndIf
		
		llLockScreen = ThisForm.LockScreen
		ThisForm.LockScreen = .T.
		
		lnPanel = This.oRefGrid.Panel
		This.oRefGrid.Panel = This.nPanel
		
		This.SetAll("Visible", .F., "_Do_HeaderBase")
		
		lnLeft = 0
		loLockUp = NULL
		loHeader = NULL
		loColumn = NULL
		For lnIndex = This.oRefGrid.LeftColumn To This.oRefGrid.ColumnCount
			*-- 是否到达锁定列位置
			If Not IsNull(This.oRefControl)
				If This.nPanel = 1 
					*-- 锁右边列
					If This.oRefGrid.LockColumns > 0 ;
					And m.lnIndex = This.oRefGrid.LockColumns + 1
						This.oRefControl.SetWidth(m.lnLeft)
						*-- 己知 vfp9 锁列后线条加粗，因此下一个列会右移一个象素
						* lnLeft = m.lnLeft + Iif(Version(5) > 600, 1, 0)
						lnLeft = m.lnLeft + 1
						If Not IsNull(loHeader) And Not IsNull(loHeader.oRefup)
							loLockup = loHeader.oRefup
						EndIf
					EndIf
				Else
					*-- 锁左边列
					If This.oRefGrid.LockColumnsLeft > 0 ;
					And m.lnIndex = This.oRefGrid.LockColumnsLeft + 1
						This.oRefControl.SetWidth(m.lnLeft)
						*-- 己知 vfp9 锁列后线条加粗，因此下一个列会右移一个象素
						lnLeft = m.lnLeft + 1
						If Not IsNull(loHeader) And Not IsNull(loHeader.oRefup)
							loLockup = loHeader.oRefup
						EndIf
					EndIf
				EndIf
			EndIf
			
			loColumn = This.GetColumn(m.lnIndex)
			*-- 控件不可视或者不在可视范围内
			If Version(5) > 600 ;
			And Not This.GetColumnVisible(m.loColumn)
				Loop
			EndIf
		
			loHeader = This.GetRefHeader(m.loColumn)
			lnTop = 0
			lnWidth = loColumn.Width + 1
			*-- 表格标头高为奇数时，加 1 值
			lnHeight = This.Height && + 1
		
			*-- 列宽己超出显示区域，计算出最后列的宽度
			If m.lnLeft + m.lnWidth > This.Width
				lnWidth = This.Width - m.lnLeft + 0
			EndIf
		
			*-- 当前列有合并标头，高度/2
			If Not IsNull(loHeader.oRefup)
				lnHeight = Int(m.lnHeight/2)
				lnTop = m.lnHeight
				If Not loHeader.oRefup.Visible
					*-- 第一次出现合并标头时，设置合并标头的 Left 与 Width
					loHeader.oRefup.Visible = .T.
					loHeader.oRefup.Move(m.lnLeft, 0, m.lnWidth, lnHeight)
				Else
					*-- 第二次出现合并标头时，合并标头加上当前列宽度
					loHeader.oRefup.Width = loHeader.oRefup.Width + m.lnWidth
					*-- 再次第二次出现组标头时并且是锁的那个组，宽度加 1
					If Not IsNull(m.loLockup) And m.loLockup = loHeader.oRefup
						m.loLockup = NULL
						loHeader.oRefup.Width = loHeader.oRefup.Width + 1
					EndIf
				EndIf
				*-- 标头高度为奇数时，取整会让高度少1个象素，这里补上
				lnHeight = m.lnHeight + Mod(This.Height, 2)
			EndIf
			loHeader.Move(m.lnLeft, m.lnTop, m.lnWidth, m.lnHeight)
			loHeader.Visible = .T.
			lnLeft = m.lnLeft + loHeader.Width
		
			If m.lnLeft >= This.Width
				*-- 超出所显示的宽度
				Exit
			EndIf
		EndFor
		
		If Not IsNull(This.oRefControl)
			This.oRefControl.Resize()
		EndIf
		This.oRefGrid.Panel = m.lnPanel
		ThisForm.LockScreen = m.llLockScreen
		This.Refresh()
	ENDPROC

	PROCEDURE headerresize		&& 根据表格信息，重新设置标头大小、座标等信息
		*-- 重画类派生实例的大小、位置与宽高
		
		Private loGrid, lnLeft, lnTop, lnWidth, lnHeight, lnScroll, lnPanel, llLockScreen
		Local loGrid, lnLeft, lnTop, lnWidth, lnHeight, lnScroll, lnPanel, llLockScreen
		
		If Not VarType(This.oRefGrid) = "O" Or IsNull(This.oRefGrid)
			This.Visible = .F.
			Return
		EndIf
		
		llLockScreen = ThisForm.LockScreen
		ThisForm.LockScreen = .T.
		
		loGrid = This.oRefGrid
		lnLeft = This.nLeftOffset + 1
		lnTop = This.nTopOffset + 1
		
		lnPanel = loGrid.Panel
		If This.nPanel = 1
			loGrid.Panel = 1
			lnLeft = lnLeft + loGrid.Partition
			lnWidth = loGrid.Width
		Else
			loGrid.Panel = 0
			lnWidth = loGrid.Partition + 1
		EndIf
		
		lnLeft = lnLeft + Iif(loGrid.RecordMark, This.nRecordMark, 0)
		lnLeft = lnLeft + Iif(loGrid.DeleteMark, This.nDeleteMark, 0)
		lnScroll = Iif(loGrid.ScrollBars > 1, SysMetric(5), 0)
		
		lnWidth = m.lnWidth - m.lnLeft - m.lnScroll - 1
		lnHeight = loGrid.HeaderHeight - m.lnTop + 1
		lnScroll = Iif(InList(loGrid.ScrollBars, 1, 3), SysMetric(7), 0)
		If lnHeight > loGrid.Height - m.lnScroll
			lnHeight = Max(0, loGrid.Height - m.lnScroll - 1)
		EndIf
		
		This.Move(loGrid.Left + m.lnLeft, loGrid.Top + m.lnTop, Max(m.lnWidth, 0), Max(m.lnHeight, 0))
		
		*!*	If m.lnWidth <= 0 Or m.lnHeight <= 0
		*!*		This.Visible = .F.
		*!*	Else
		*!*		This.Move(loGrid.Left + m.lnLeft, loGrid.Top + m.lnTop, m.lnWidth, m.lnHeight)
		*!*		This.Visible = .T.
		*!*	EndIf
		
		If This.lSplitBar And This.lMaster And loGrid.Partition > 0
			This.PanelCreate()
		EndIf
		
		loGrid.Panel = m.lnPanel
		This.HeaderRedraw()
		ThisForm.LockScreen = m.llLockScreen
	ENDPROC

	PROCEDURE headerswap		&& 交换两个标头位置
		LPARAMETERS toHeaderA, toHeaderB
		
		*-- 将 toHeaderA 与 toHeaderB 交换位置
		*-- 参数
			* toHeaderA 标头对象
			* toHeaderB 标头对象
		*-- 返回值
			* 无
		
		*-- 注1: 此处理方法只考虑 A 在 B 的左边，如果 A 在 B 的右边，则进入递归。
		
		Private loColumn, loHeaderA, loHeaderB, lnMinOrderA, lnMaxOrderA, lnMinOrderB, lnMaxOrderB
		Local loColumn, loHeaderA, loHeaderB, lnMinOrderA, lnMaxOrderA, lnMinOrderB, lnMaxOrderB
		
		*-- 参数修正到组标头
		loHeaderA = Iif(IsNull(toHeaderA.oRefup), toHeaderA, toHeaderA.oRefup)
		loHeaderB = Iif(IsNull(toHeaderB.oRefup), toHeaderB, toHeaderB.oRefup)
		
		Do Case
		*-- 
		*-- 非法情况判定
		*--
		Case toHeaderA.nType = 2 And toHeaderB.nType = 1 And toHeaderB.oRefup = m.toHeaderA
		*-- 尝标让子标头与组标头对调位置
			Messagebox(ManyHeader_HeaderSwap_1, 16, "错误")
			* Messagebox("不能执行这个操作！子标头与子标头的父标头无法对调顺序！", 16, "错误")
		Case toHeaderB.nType = 2 And toHeaderA.nType = 1 And toHeaderA.oRefup = m.toHeaderA
		*-- 尝标让子标头与组标头对调位置
			Messagebox(ManyHeader_HeaderSwap_1, 16, "错误")
			* Messagebox("不能执行这个操作！子标头与子标头的父标头无法对调顺序！", 16, "错误")
		
		*--
		*-- 基本情况判定
		*--
		*-- A, B 都是普通标头，直接交换
		Case toHeaderA.nType = 0 And toHeaderB.nType = 0
			toHeaderA.aRefColumns[1].ColumnOrder = toHeaderB.aRefColumns[1].ColumnOrder
		
		*-- A, B 是同一组的组内成员，直接交换
		Case toHeaderA.nType = 1 And toHeaderB.nType = 1 And toHeadera.oRefup = toHeaderB.oRefup
			toHeaderA.aRefColumns[1].ColumnOrder = toHeaderB.aRefColumns[1].ColumnOrder
		
		*-- A 是普通标头，B 是组标头
		Case loHeaderA.nType = 0 And loHeaderB.nType = 2
			lnOrder = loHeaderA.aRefColumns[1].ColumnOrder
			lnMinOrderB = This.GetGroupMin(m.loHeaderB)
			lnMaxOrderB = This.GetGroupMax(m.loHeaderB)
			If m.lnOrder < m.lnMinOrderB
				*-- 调整 A 往右移
				For lnLoop = 1 To m.lnMaxOrderB - m.lnOrder
					loHeaderA.aRefColumns[1].ColumnOrder = loHeaderA.aRefColumns[1].ColumnOrder + 1
				EndFor
				*-- 调整 B 往左移
				loHeaderB.HeaderSort(0)
				For lnLoop = 1 To m.lnMinOrderB - m.lnOrder - 1
					For Each loColumn In loHeaderB.aRefColumns
						loColumn.ColumnOrder = loColumn.ColumnOrder - 1
					EndFor
				EndFor
			Else
				This.HeaderSwap(m.loHeaderB, m.loHeaderA)
			EndIf
		
		*-- A 是组标头，B 是普通标头
		Case loHeaderA.nType = 2 And loHeaderB.nType = 0
			lnMinOrderA = This.GetGroupMin(m.loHeaderA)
			lnMaxOrderA = This.GetGroupMax(m.loHeaderA)
			loHeaderB.HeaderSort()
			lnOrder = loHeaderB.aRefColumns[1].ColumnOrder
			If m.lnMaxOrderA < m.lnOrder
				*-- 调整 A 往左移
				loHeaderA.HeaderSort(1)
				For Each loColumn In loHeaderA.aRefColumns
					For lnLoop = 1 To m.lnOrder - m.lnMaxOrderA
						loColumn.ColumnOrder = loColumn.ColumnOrder + 1
					EndFor
				EndFor
				*-- 调整 B 往右移
				loHeaderA.HeaderSort(0)
				For lnLoop = 1 To m.lnOrder - m.lnMaxOrderA - 1
					loHeaderB.aRefColumns[1].ColumnOrder = loHeaderB.aRefColumns[1].ColumnOrder - 1
				EndFor
			Else
				This.HeaderSwap(m.loHeaderB, m.loHeaderA)
			EndIf
		
		
		*-- A 是组标头，B 也是组标头
		Case loHeaderA.nType = 2 And loHeaderB.nType = 2
			lnMinOrderA = This.GetGroupMin(m.loHeaderA)
			lnMaxOrderA = This.GetGroupMax(m.loHeaderA)
			lnMinOrderB = This.GetGroupMin(m.loHeaderB)
			lnMaxOrderB = This.GetGroupMax(m.loHeaderB)
			If m.lnMinOrderA < m.lnMinOrderB
				*-- 调整 A 往左移
				loHeaderA.HeaderSort(1)
				For Each loColumn In loHeaderA.aRefColumns
					For lnLoop = 1 To m.lnMaxOrderB - m.lnMaxOrderA
						loColumn.ColumnOrder = loColumn.ColumnOrder + 1
					EndFor
				EndFor
				loHeaderB.HeaderSort(0)
				*-- 调整 B 往右移
				For Each loColumn In loHeaderB.aRefColumns
					For lnLoop = 1 To m.lnMinOrderB - m.lnMaxOrderA - 1
						loColumn.ColumnOrder = loColumn.ColumnOrder - 1
					EndFor
				EndFor
			Else
				This.HeaderSwap(m.loHeaderB, m.loHeaderA)
			EndIf
		
		Otherwise
		*!*		Set Assert On
		*!*		Assert .F. Message "Can not solve the problems!"
			Messagebox(ManyHeader_HeaderSwap_2, 16)
		
		EndCase
		
		This.GetGridColumn()
		This.HeaderRedraw()
		If Not IsNull(This.oRefPanel)
			This.oRefPanel.GetGridColumn()
			This.oRefPanel.HeaderRedraw()
		EndIf
	ENDPROC

	PROCEDURE initheader		&& 初始表类对象，与表格相绑定
		LPARAMETERS toGrid
		
		*-- 指定一个同层表格，按此表格绘制标头
		*-- 参数
			* toGrid	与本派生类同名的表格对象
		*-- 返回值
			* 无
		*-- 注：无
		
		Private llLockScreen, lnIndex, loColumn, loHeader, loColHeader, lnPanel
		Local llLockScreen, lnIndex, loColumn, loHeader, loColHeader, lnPanel
		
		If _Vfp.StartMode = 0 And PemStatus(toGrid, "AllowCellSelection", 5)
			If toGrid.AllowCellSelection = .F. And Not PemStatus(toGrid, "Valid", 0)
				Messagebox(ManyHeader_InitHeader_1, 64)
				* Messagebox("当 AllowCellSelection = .F. 时，表格的 Valid 至少需要一行空指令，请随便添加一行 * 指令。", 64)
			EndIf
		EndIf
		
		If Not Version(5) > 600
			This.nMinLock = 0
		EndIf
		
		llLockScreen = ThisForm.LockScreen
		ThisForm.LockScreen = .T.
		
		*-- 获取/加载解除表单 LockScreen 的计时器
		If Not Type("ThisForm.__UnLockScreen.Name") = "C"
			ThisForm.NewObject("__UnLockScreen", "_UnLockScreen", This.ClassLibrary)
		EndIf
		
		If Type("ThisForm.__UnLockScreen.Name") = "C"
			This.oRefTimer = ThisForm.__UnLockScreen
		Else
			This.oRefTimer = NULL
		EndIf
		
		*-- 锁定列
		If Not PemStatus(toGrid, "LockColumns", 5)
			toGrid.AddProperty("LockColumns", 0)
		EndIf
		If Not PemStatus(toGrid, "LockColumnsLeft", 5)
			toGrid.AddProperty("LockColumnsLeft", 0)
		EndIf
		
		lnPanel = toGrid.Panel
		If toGrid.SplitBar
			toGrid.PanelLink = .F.
			toGrid.Panel = 0
			toGrid.ScrollBars = Iif(InList(toGrid.ScrollBars, 0, 2), 0, 1)
		
			toGrid.Panel = m.lnPanel
			toGrid.PanelLink = .T.
		EndIf
		
		This.oRefGrid = m.toGrid
		This.GetGridColumn()
		
		This.HeaderClear()
		If This.nPanel = 1
			toGrid.LockColumns = Max(toGrid.LockColumns, This.nMinLock)
			This.nLock = toGrid.LockColumns
		Else
			toGrid.LockColumnsLeft = Max(toGrid.LockColumnsLeft, This.nMinLock)
			This.nLock = toGrid.LockColumnsLeft
		EndIf
		
		*-- 为第一次初始化创建 Column 的链接指向
		loColumn = toGrid.Columns(1)
		If This.nRef = -1
			If PemStatus(loColumn, "aRefHeaders", 5)
				*-- 引用数组己存在，数组维数加 1
				This.nRef = ALen(loColumn.aRefHeaders) + 1
			Else
				This.nRef = 1
			EndIf
		EndIf
		For m.lnIndex = 1 To toGrid.ColumnCount
			loColumn = toGrid.Columns(This.aColumn[m.lnIndex])
		
			*--
			This.NewObject(loColumn.Name, "_Do_HeaderBase", This.ClassLibrary)
			loHeader = This.Controls(This.ControlCount)
			loColHeader = This.GetColumnHeader(m.loColumn)
		
			*-- 建立标头与表格之间相互引用关系
			loHeader.aRefColumns[1] = m.loColumn
			If This.nRef = 1
				loColumn.AddProperty("aRefHeaders[1]", NULL)
			Else
				Dimension loColumn.aRefHeaders[This.nRef]
			EndIf
			loColumn.aRefHeaders[This.nRef] = m.loHeader
		
			*-- 表头标签的基本属性
			loHeader.Caption = loColHeader.Caption
			loHeader.nAlignment = Iif(This.lAlignment, loColHeader.Alignment, loHeader.nAlignment)
			loHeader.lResizable = loColumn.Resizable
			loHeader.lMovable = loColumn.Movable
			loColumn.AddProperty("nIndex", This.aColumn[m.lnIndex])
		
			*-- 标头属性设置
			If This.lMaster
				This.OnStyle(m.loHeader, m.loColHeader)
			Else
				If Not IsNull(This.oRefPanel)
					This.oRefPanel.OnStyle(m.loHeader, m.loColHeader)
				EndIf
			EndIf
			m.loHeader.lInit = .T.
		EndFor
		This.nLeftColumn = toGrid.LeftColumn
		
		This.HeaderResize()
		If This.lMaster 
			If toGrid.Partition > 0
				If IsNull(This.oRefPanel)
					This.PanelCreate()
				EndIf
				This.oRefPanel.InitHeader(m.toGrid)
			Else
				This.PanelDestroy()
			EndIf
		EndIf
		This.BindEvents()
		This.Zorder(0)
		This.Visible = .T.
		ThisForm.LockScreen = m.llLockScreen
	ENDPROC

	HIDDEN PROCEDURE llock_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		This.lLock = m.vNewVal
		
		If m.vNewVal
			This.ControlCreate()
		Else
			This.ControlDestory()
		EndIf
		
		
		If This.lMaster And Not IsNull(This.oRefPanel)
			This.oRefPanel.lLock = m.vNewVal
		EndIf
	ENDPROC

	HIDDEN PROCEDURE mergecleartry		&& 在不改变 ColumnOrder 的前提下，尝试合并后废弃的组。
		LPARAMETERS tnStart, tnEnd
		
		
		*-- 清除 tnStart 到 tnEnd 之间的合并组信息，可能的话删除组。
		*-- 参数
			* tnStart 	表格列 ColumnOrder 始
			* tnEnd  	表格列 ColumnOrder 终
		*-- 返回值
			* 无
		*-- 注：在这里删除列必须在不能改变列 ColumnOrder 顺序的前提下
		
		Private loHeaderA, loHeaderB, loHeader, loColumn, lnMinOrder, lnMaxOrder
		Local loHeaderA, loHeaderB, loHeader, loColumn, lnMinOrder, lnMaxOrder
		
		loColumn = This.GetColumn(m.tnStart)
		loHeaderA = This.GetRefHeader(m.loColumn)
		loColumn = This.GetColumn(m.tnEnd)
		loHeaderB = This.GetRefHeader(m.loColumn)
		
		Do Case
		*-- A、B 都不是组，正序删除组
		Case IsNull(loHeaderA.oRefup) And IsNull(loHeaderB.oRefup)
			For lnIndex = m.tnStart To m.tnEnd
				This.HeaderDel(m.lnIndex)
			EndFor
		
		*-- A 不是组 B 是，正序删除组
		Case IsNull(loHeaderA.oRefup) And Not IsNull(loHeaderB.oRefup)
			For lnIndex = m.tnStart To m.tnEnd
				This.HeaderDel(m.lnIndex)
			EndFor
		
		*-- A 是组 B 不是，倒序删除组
		Case Not IsNull(loHeaderA.oRefup) And Isnull(loHeaderB.oRefup)
			For lnIndex = m.tnEnd To m.tnStart
				This.HeaderDel(m.lnIndex)
			EndFor
		
		*-- A B 是同一个组，从首列或者尾列删除列标头
		Case loHeaderA.oRefup = loHeaderB.oRefup
			lnMinOrder = This.GetGroupMin(loHeaderA.oRefup)
			lnMaxOrder = This.GetGroupMax(loHeaderA.oRefup)
		
			Do Case
			*-- 从首列正序删除组信息
			Case m.lnMinOrder = m.tnStart
				For lnIndex = m.tnStart To m.tnEnd
					This.HeaderDel(m.lnIndex)
				EndFor
		
			*-- 从尾列倒序删除组信息
			Case m.lnMaxOrder = m.tnEnd
				For lnIndex = m.tnEnd To m.tnStart Step - 1
					This.HeaderDel(m.lnIndex)
				EndFor
		
			Otherwise
			*-- 合并列正好在两中间，需要移动位置而无法删除
			EndCase
			
		
		*-- A B 不是同一个组，需要三种删除方法
		Case loHeaderA.oRefup <> loHeaderB.oRefup
			lnMaxOrder = This.GetGroupMax(loHeaderA.oRefup)
			*-- A 组倒序删除
			For lnIndex = m.lnMaxOrder To m.tnStart Step -1
				This.HeaderDel(m.lnIndex)
			EndFor
			*-- B 组正序删除
			lnMinOrder = This.GetGroupMin(loHeaderB.oRefup)
			*-- A 组倒序删除
			For lnIndex = m.lnMinOrder To m.tnEnd
				This.HeaderDel(m.lnIndex)
			EndFor
			*-- 中间部份正序删除
			For lnIndex = m.lnMaxOrder To m.lnMinOrder
				This.HeaderDel(m.lnIndex)
			EndFor
		EndCase
	ENDPROC

	PROCEDURE mergeheader		&& 合并表格列
		LPARAMETERS tnStart, tnEnd, tcCaption
		
		*-- 指定表格列的 ColumnOrder 顺序合并单元格，当单元格被重复合并时，那上一次合并的组会被断掉
		*-- 参数说明
			* tnStart 		合并单元格的起始列
			* tnEnd 		合并单元格的终止列
			* tcCaption 	合并后单元格的标题
		*-- 返回值 
			* 合并组标头对象
		
		*-- 注：默认下合并后的单元格取表格 tnStart 列的风格
		
		Private llError, lnIndex, lnCount, lnOrder, loMergeHeader, loColumn, loHeader, llResizable, llMovable
		Local llError, lnIndex, lnCount, lnOrder, loMergeHeader, loColumn, loHeader, llResizable, llMovable
		
		llError = .T.
		Do Case
		Case VarType(This.oRefGrid) <> "O" Or IsNull(This.oRefGrid)
			Messagebox(ManyHeader_MergeHeader_1, 16)
			* Messagebox("ManyHeader 未与 GRID 对象相绑定或者 GRID 对象己无效！", 16)
		Case Not VarType(m.tcCaption) = "C"
			Messagebox(ManyHeader_MergeHeader_2, 16)
			* Messagebox(未指定合并后组标头的标题！", 16)
		Case Not VarType(m.tnStart) = "N" Or Not VarType(m.tnEnd) = "N" 
			Messagebox(ManyHeader_MergeHeader_3, 16)
			* Messagebox("未指定将要合并的列范围！", 16)
		Case m.tnStart > m.tnEnd
			Messagebox(ManyHeader_MergeHeader_4, 16)
			* Messagebox("合并列的起始位置应该大于终止位置！", 16)
		Case Not m.tnStart > 0
			Messagebox(ManyHeader_MergeHeader_5, 16)
			* Messagebox("指定的列范围非法！起始列应大于 0。", 16)
		Case m.tnEnd > This.oRefGrid.ColumnCount
			Messagebox(ManyHeader_MergeHeader_6, 16)
			* Messagebox("指定的列范围非法！终止列不能大于表格列的总数。", 16)
		Otherwise
			llError = .F.
		EndCase
		
		If m.llError
			Return 
		EndIf
		
		*-- 清理掉新的合并后，己经失效的组信息
		This.MergeClearTry(tnStart, tnEnd)
		
		loMergeHeader = NULL
		This.NewObject("_" + Sys(2015), "_Do_HeaderBase", This.ClassLibrary)
		loMergeHeader = This.Controls(This.ControlCount)
		lnCount = m.tnEnd - m.tnStart + 1
		Dimension loMergeHeader.aRefColumns[m.lnCount]
		
		llResizable = .F.
		llMovable = .F.
		
		*-- 倒序合并，方便将组内再合并的成员排到最后
		For m.lnIndex = m.lnCount To 1 Step - 1
			*-- 取出对应 Order 表格列的名
			loColumn = This.GetColumn(m.lnIndex + m.tnStart - 1)
			llResizable = Iif(loColumn.Resizable, .T., m.llResizable)
			llMovable = Iif(loColumn.Movable, .T., m.llMovable)
			loHeader = This.GetRefHeader(m.loColumn)
		
			*-- 保存被合并列对象名称的引用
			loMergeHeader.aRefColumns[m.lnIndex] = m.loColumn
		
			*-- 没有全部被清理，同组成员必须退到组的最后面
			If loHeader.nType = 1
				This.HeaderDel(This.GetRefHeader(m.loColumn))
			EndIf
			loHeader.nType = 1
			loHeader.oRefup = m.loMergeHeader
		EndFor
		
		*-- 合并列的属性设置
		loHeader = This.GetColumnHeader(loMergeHeader.aRefColumns[1])
		With loMergeHeader
			.Caption = m.tcCaption
			.nAlignment = Iif(This.lAlignment, loHeader.Alignment, .nAlignment)
			.lResizable = m.llResizable
			.lMovable = m.llMovable
			.nType = 2
			.Height = This.Height / 2
			.nMergeCount = m.lnCount
		
			*-- 合并列样式默认取第一个被合并列的样式
			If This.lMaster
				This.OnStyle(m.loMergeHeader, m.loHeader)
			Else
				If Not IsNull(This.oRefPanel)
					This.oRefPanel.OnStyle(m.loMergeHeader, This.GetColumnHeader(.aRefColumns[1]))
				EndIf
			EndIf
			.lInit = .T.
		EndWith
		
		This.HeaderRedraw()
		If This.lMaster And Not IsNull(This.oRefPanel)
		With This.oRefPanel
			.MergeHeader(m.tnStart, m.tnEnd, m.tcCaption)
			.GetGridColumn()
			.HeaderRedraw()
		EndWith
		EndIf
		
		Return loMergeHeader
	ENDPROC

	PROCEDURE onclick		&& 标头单击事件，默认执行表格列标头 Click 事件
		LPARAMETERS toHeader
		
		*-- 在标头上的鼠标左键单击事件
		*-- 参数
			* toHeader 		发生右击事件的列标头对象
		*-- 注：默认情况下，执行表格对应列标头的 Click 事件
		
		If toHeader.nMergeCount = 0
			toHeader = This.GetColumnHeader(toHeader.aRefColumns[1])
			toHeader.Click()
		EndIf
	ENDPROC

	PROCEDURE ondblclick		&& 标头双击事件，默认执行表格列标头 Click 事件
		LPARAMETERS toHeader
		
		*-- 在标头上的鼠标左键双击事件
		*-- 参数
			* toHeader 		发生左键双击事件的列标头对象
		*-- 注：默认情况下，执行表格对应列标头的 DbltClick 事件
		
		If toHeader.nMergeCount = 0
			toHeader = This.GetColumnHeader(toHeader.aRefColumns[1])
			toHeader.DBLClick()
		EndIf
	ENDPROC

	PROCEDURE ondrag		&& 当某列被拖动移动位置后，触发本事件。0 左移，1 右移。
		LPARAMETERS toHeader, tnType
		
		*-- 当完成一个拖动后，发生此事件
		*-- 参数
			* toHeader 		被拖动的标头对象
			* tnType 		0 列左移，1 列右移
	ENDPROC

	PROCEDURE onlock		&& 当锁定列或解除锁定后，发生此事件
		LPARAMETERS tnVal
		
		
		
	ENDPROC

	PROCEDURE onmouseenter		&& 当鼠标移入标头对象内发生此事件
		LPARAMETERS toHeader, nButton, nShift, nXCoord, nYCoord
		
		If Not This.lMaster And Not IsNull(This.oRefpanel)
			This.oRefpanel.OnMouseEnter(m.toHeader, m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE onmouseleave		&& 当鼠标移出标头后发生此事件
		LPARAMETERS toHeader, nButton, nShift, nXCoord, nYCoord
		
		If Not This.lMaster And Not IsNull(This.oRefpanel)
			This.oRefpanel.OnMouseLeave(m.toHeader, m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		EndIf
	ENDPROC

	PROCEDURE onresize		&& 当标头宽茺发生变化，发生此事件
		LPARAMETERS toHeader
		
		If Not This.lMaster And Not IsNull(This.oRefpanel)
			This.oRefPanel.OnResize(m.toHeader)
		EndIf
	ENDPROC

	PROCEDURE onrightclick		&& 标头单击事件，默认执行表格列标头 RightClick 事件
		LPARAMETERS toHeader
		
		*-- 在标头上的鼠标右键单击事件
		*-- 参数
			* toHeader 		发生右击事件的列标头对象
		*-- 注：默认情况下，执行表格对应列标头的 RightClick 事件
		
		If toHeader.nMergeCount = 0
			toHeader = This.GetColumnHeader(toHeader.aRefColumns[1])
			toHeader.RightClick()
		EndIf
	ENDPROC

	PROCEDURE onstyle		&& 当创建一个表头后，都会触发此事件，可在此设置标头样式。
		LPARAMETERS toHeader, toColumnHeader
		
		With toHeader
			.Header1.ForeColor	= m.toColumnHeader.ForeColor
			.Header1.FontBold	= m.toColumnHeader.FontBold
			.Header1.FontName	= m.toColumnHeader.FontName
			.Header1.FontSize	= m.toColumnHeader.FontSize
				
			If .BackColor # m.toColumnHeader.BackColor
				.BackStyle		= 1
				.BackColor		= m.toColumnHeader.BackColor
			EndIf
		EndWith
	ENDPROC

	PROCEDURE panelcreate		&& 创建链接表格对象
		LPARAMETERS toGrid
		
		Private loHeader
		Local loHeader
		
		If IsNull(This.oRefPanel)
			This.Parent.NewObject(Sys(2015), This.Class, This.ClassLibrary)
			This.oRefPanel = This.Parent.Controls(This.Parent.ControlCount)
			This.oRefPanel.nPanel = Iif(This.nPanel = 1, 0, 1)
			This.oRefPanel.lSplitBar = .F.
			This.oRefPanel.lMaster = .F.
			This.oRefPanel.lLock = This.lLock
			This.oRefPanel.Picture = This.Picture
			This.oRefPanel.oRefPanel = This
			
			This.oRefPanel.InitHeader(This.oRefGrid)
			*-- 复制组标头
			For Each loHeader In This.Controls
				If Upper(loHeader.Class) = Upper("_Do_HeaderBase") ;
				And loHeader.nType = 2
					This.oRefPanel.MergeHeader( ;
						This.GetGroupMin(m.loHeader), ;
						This.GetGroupMax(m.loHeader), ;
						loHeader.Caption)
				EndIf
			EndFor
		EndIf
		
		*!*	This.oRefPanel.InitHeader(This.oRefGrid)
		*!*	This.oRefPanel.HeaderResize()
		*!*	This.oRefPanel.HeaderRedraw()
	ENDPROC

	PROCEDURE paneldestroy		&& 销毁拆分后的面板控件
		If Not IsNull(This.oRefPanel)
			This.oRefPanel.Destroy()
			This.Parent.RemoveObject(This.oRefPanel.Name)
			This.oRefPanel = NULL
		EndIf
	ENDPROC

	PROCEDURE Refresh
		If Not IsNull(This.oRefControl)
			This.oRefControl.Zorder(0)
		EndIf
	ENDPROC

	HIDDEN PROCEDURE unlockscreen
		
		*-- 在表格失去焦点前或水平滚动进锁屏
		
		If VarType(This.oRefTimer) = "O" And Not IsNull(This.oRefTimer)
			ThisForm.LockScreen = .T.
			This.oRefTimer.Enabled = .T.
		EndIf
	ENDPROC

	PROCEDURE visible_assign
		LPARAMETERS vNewVal
		*To do: 为 Assign 方法程序修改此例程
		This.Visible = m.vNewVal
		
		If This.lMaster And Not IsNull(This.oRefPanel)
			This.oRefPanel.Visible = m.vNewVal
		EndIf
	ENDPROC

ENDDEFINE
